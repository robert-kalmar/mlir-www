<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Interfaces - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.64.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Interfaces/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>Interfaces</h1><p>MLIR is a generic and extensible framework, representing different
dialects with their own operations, attributes, types, and so on.
MLIR Dialects can express operations with a wide variety of semantics
and different levels of abstraction. The downside to this is that MLIR
transformations and analyses need to account for the semantics of
every operation, or handle operations conservatively. Without care,
this can result in code with special-cases for each supported
operation type. To combat this, MLIR provides the concept of
<code>interfaces</code>.</p><h2 id=motivation>Motivation&nbsp;<a class=headline-hash href=#motivation>¶</a></h2><p>Interfaces provide a generic way of interacting with the IR. The goal is to be
able to express transformations/analyses in terms of these interfaces without
encoding specific knowledge about the exact operation or dialect involved. This
makes the compiler more extensible by allowing the addition of new dialects and
operations in a decoupled way with respect to the implementation of
transformations/analyses.</p><h3 id=dialect-interfaces>Dialect Interfaces&nbsp;<a class=headline-hash href=#dialect-interfaces>¶</a></h3><p>Dialect interfaces are generally useful for transformation passes or analyses
that want to operate generically on a set of attributes/operations/types, which
might even be defined in different dialects. These interfaces generally involve
wide coverage over the entire dialect and are only used for a handful of
transformations/analyses. In these cases, registering the interface directly on
each operation is overly complex and cumbersome. The interface is not core to
the operation, just to the specific transformation. An example of where this
type of interface would be used is inlining. Inlining generally queries
high-level information about the operations within a dialect, like legality and
cost modeling, that often is not specific to one operation.</p><p>A dialect interface can be defined by inheriting from the CRTP base class
<code>DialectInterfaceBase::Base</code>. This class provides the necessary utilities for
registering an interface with the dialect so that it can be looked up later.
Once the interface has been defined, dialects can override it using
dialect-specific information. The interfaces defined by a dialect are registered
in a similar mechanism to Attributes, Operations, Types, etc.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>/// Define an Inlining interface to allow for dialects to opt-in.
</span><span class=c1></span><span class=k>class</span> <span class=nc>DialectInlinerInterface</span> <span class=o>:</span>
    <span class=k>public</span> <span class=n>DialectInterface</span><span class=o>:</span><span class=o>:</span><span class=n>Base</span><span class=o>&lt;</span><span class=n>DialectInlinerInterface</span><span class=o>&gt;</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
  <span class=c1>/// Returns true if the given region &#39;src&#39; can be inlined into the region
</span><span class=c1></span>  <span class=c1>/// &#39;dest&#39; that is attached to an operation registered to the current dialect.
</span><span class=c1></span>  <span class=c1>/// &#39;valueMapping&#39; contains any remapped values from within the &#39;src&#39; region.
</span><span class=c1></span>  <span class=c1>/// This can be used to examine what values will replace entry arguments into
</span><span class=c1></span>  <span class=c1>/// the &#39;src&#39; region, for example.
</span><span class=c1></span>  <span class=k>virtual</span> <span class=kt>bool</span> <span class=n>isLegalToInline</span><span class=p>(</span><span class=n>Region</span> <span class=o>*</span><span class=n>dest</span><span class=p>,</span> <span class=n>Region</span> <span class=o>*</span><span class=n>src</span><span class=p>,</span>
                               <span class=n>BlockAndValueMapping</span> <span class=o>&amp;</span><span class=n>valueMapping</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span><span class=p>;</span>

<span class=c1>/// Override the inliner interface to add support for inlining affine
</span><span class=c1></span><span class=c1>/// operations.
</span><span class=c1></span><span class=k>struct</span> <span class=nc>AffineInlinerInterface</span> <span class=o>:</span> <span class=k>public</span> <span class=n>DialectInlinerInterface</span> <span class=p>{</span>
  <span class=c1>/// Affine structures have specific inlining constraints.
</span><span class=c1></span>  <span class=kt>bool</span> <span class=nf>isLegalToInline</span><span class=p>(</span><span class=n>Region</span> <span class=o>*</span><span class=n>dest</span><span class=p>,</span> <span class=n>Region</span> <span class=o>*</span><span class=n>src</span><span class=p>,</span>
                       <span class=n>BlockAndValueMapping</span> <span class=o>&amp;</span><span class=n>valueMapping</span><span class=p>)</span> <span class=k>const</span> <span class=k>final</span> <span class=p>{</span>
    <span class=p>.</span><span class=p>.</span><span class=p>.</span>
  <span class=p>}</span>
<span class=p>}</span><span class=p>;</span>

<span class=c1>/// Register the interface with the dialect.
</span><span class=c1></span><span class=n>AffineDialect</span><span class=o>:</span><span class=o>:</span><span class=n>AffineDialect</span><span class=p>(</span><span class=n>MLIRContext</span> <span class=o>*</span><span class=n>context</span><span class=p>)</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span> <span class=p>{</span>
  <span class=n>addInterfaces</span><span class=o>&lt;</span><span class=n>AffineInlinerInterface</span><span class=o>&gt;</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>Once registered, these interfaces can be queried from the dialect by
the transformation/analysis that wants to use them, without
determining the particular dialect subclass:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>Dialect</span> <span class=o>*</span><span class=n>dialect</span> <span class=o>=</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>;</span>
<span class=k>if</span> <span class=p>(</span><span class=k>auto</span> <span class=o>*</span><span class=n>interface</span> <span class=o>=</span> <span class=n>dialect</span><span class=o>-</span><span class=o>&gt;</span><span class=n>getInterface</span><span class=o>&lt;</span><span class=n>DialectInlinerInterface</span><span class=o>&gt;</span><span class=p>(</span><span class=p>)</span><span class=p>)</span>
    <span class=p>.</span><span class=p>.</span><span class=p>.</span> <span class=c1>// The dialect provides this interface.
</span></code></pre></div><h4 id=dialectinterfacecollections>DialectInterfaceCollections&nbsp;<a class=headline-hash href=#dialectinterfacecollections>¶</a></h4><p>An additional utility is provided via DialectInterfaceCollection. This CRTP
class allows for collecting all of the dialects that have registered a given
interface within the context.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>class</span> <span class=nc>InlinerInterface</span> <span class=o>:</span> <span class=k>public</span>
    <span class=n>DialectInterfaceCollection</span><span class=o>&lt;</span><span class=n>DialectInlinerInterface</span><span class=o>&gt;</span> <span class=p>{</span>
  <span class=c1>/// The hooks for this class mirror the hooks for the DialectInlinerInterface,
</span><span class=c1></span>  <span class=c1>/// with default implementations that call the hook on the interface for a
</span><span class=c1></span>  <span class=c1>/// given dialect.
</span><span class=c1></span>  <span class=k>virtual</span> <span class=kt>bool</span> <span class=nf>isLegalToInline</span><span class=p>(</span><span class=n>Region</span> <span class=o>*</span><span class=n>dest</span><span class=p>,</span> <span class=n>Region</span> <span class=o>*</span><span class=n>src</span><span class=p>,</span>
                               <span class=n>BlockAndValueMapping</span> <span class=o>&amp;</span><span class=n>valueMapping</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
    <span class=k>auto</span> <span class=o>*</span><span class=n>handler</span> <span class=o>=</span> <span class=n>getInterfaceFor</span><span class=p>(</span><span class=n>dest</span><span class=o>-</span><span class=o>&gt;</span><span class=n>getContainingOp</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
    <span class=k>return</span> <span class=n>handler</span> <span class=o>?</span> <span class=n>handler</span><span class=o>-</span><span class=o>&gt;</span><span class=n>isLegalToInline</span><span class=p>(</span><span class=n>dest</span><span class=p>,</span> <span class=n>src</span><span class=p>,</span> <span class=n>valueMapping</span><span class=p>)</span> <span class=o>:</span> <span class=nb>false</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span><span class=p>;</span>

<span class=n>MLIRContext</span> <span class=o>*</span><span class=n>ctx</span> <span class=o>=</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>;</span>
<span class=n>InlinerInterface</span> <span class=nf>interface</span><span class=p>(</span><span class=n>ctx</span><span class=p>)</span><span class=p>;</span>
<span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>interface</span><span class=p>.</span><span class=n>isLegalToInline</span><span class=p>(</span><span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>)</span><span class=p>)</span>
   <span class=p>.</span><span class=p>.</span><span class=p>.</span>
</code></pre></div><h3 id=attributeoperationtype-interfaces>Attribute/Operation/Type Interfaces&nbsp;<a class=headline-hash href=#attributeoperationtype-interfaces>¶</a></h3><p>Attribute/Operation/Type interfaces, as the names suggest, are those registered
at the level of a specific attribute/operation/type. These interfaces provide
access to derived objects by providing a virtual interface that must be
implemented. As an example, the <code>Linalg</code> dialect may implement an interface that
provides general queries about some of the dialects library operations. These
queries may provide things like: the number of parallel loops; the number of
inputs and outputs; etc.</p><p>These interfaces are defined by overriding the CRTP base class <code>AttrInterface</code>,
<code>OpInterface</code>, or <code>TypeInterface</code> respectively. These classes take, as a
template parameter, a <code>Traits</code> class that defines a <code>Concept</code> and a <code>Model</code>
class. These classes provide an implementation of concept-based polymorphism,
where the Concept defines a set of virtual methods that are overridden by the
Model that is templated on the concrete object type. It is important to note
that these classes should be pure in that they contain no non-static data
members. Objects that wish to override this interface should add the provided
trait <code>*Interface&lt;..>::Trait</code> to the trait list upon registration.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>struct</span> <span class=nc>ExampleOpInterfaceTraits</span> <span class=p>{</span>
  <span class=c1>/// Define a base concept class that defines the virtual interface that needs
</span><span class=c1></span>  <span class=c1>/// to be overridden.
</span><span class=c1></span>  <span class=k>struct</span> <span class=nc>Concept</span> <span class=p>{</span>
    <span class=k>virtual</span> <span class=o>~</span><span class=n>Concept</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
    <span class=k>virtual</span> <span class=kt>unsigned</span> <span class=nf>getNumInputs</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>)</span> <span class=k>const</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
  <span class=p>}</span><span class=p>;</span>

  <span class=c1>/// Define a model class that specializes a concept on a given operation type.
</span><span class=c1></span>  <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>OpT</span><span class=o>&gt;</span>
  <span class=k>struct</span> <span class=nc>Model</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Concept</span> <span class=p>{</span>
    <span class=c1>/// Override the method to dispatch on the concrete operation.
</span><span class=c1></span>    <span class=kt>unsigned</span> <span class=nf>getNumInputs</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>)</span> <span class=k>const</span> <span class=k>final</span> <span class=p>{</span>
      <span class=k>return</span> <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>cast</span><span class=o>&lt;</span><span class=n>OpT</span><span class=o>&gt;</span><span class=p>(</span><span class=n>op</span><span class=p>)</span><span class=p>.</span><span class=n>getNumInputs</span><span class=p>(</span><span class=p>)</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>}</span><span class=p>;</span>
<span class=p>}</span><span class=p>;</span>

<span class=k>class</span> <span class=nc>ExampleOpInterface</span> <span class=o>:</span> <span class=k>public</span> <span class=n>OpInterface</span><span class=o>&lt;</span><span class=n>ExampleOpInterface</span><span class=p>,</span>
                                              <span class=n>ExampleOpInterfaceTraits</span><span class=o>&gt;</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
  <span class=c1>/// Use base class constructor to support LLVM-style casts.
</span><span class=c1></span>  <span class=k>using</span> <span class=n>OpInterface</span><span class=o>&lt;</span><span class=n>ExampleOpInterface</span><span class=p>,</span> <span class=n>ExampleOpInterfaceTraits</span><span class=o>&gt;</span><span class=o>:</span><span class=o>:</span><span class=n>OpInterface</span><span class=p>;</span>

  <span class=c1>/// The interface dispatches to &#39;getImpl()&#39;, an instance of the concept.
</span><span class=c1></span>  <span class=kt>unsigned</span> <span class=nf>getNumInputs</span><span class=p>(</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
    <span class=k>return</span> <span class=n>getImpl</span><span class=p>(</span><span class=p>)</span><span class=o>-</span><span class=o>&gt;</span><span class=n>getNumInputs</span><span class=p>(</span><span class=n>getOperation</span><span class=p>(</span><span class=p>)</span><span class=p>)</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span><span class=p>;</span>

</code></pre></div><p>Once the interface has been defined, it is registered to an operation by adding
the provided trait <code>ExampleOpInterface::Trait</code>. Using this interface is just
like using any other derived operation type, i.e. casting:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>/// When defining the operation, the interface is registered via the nested
</span><span class=c1></span><span class=c1>/// &#39;Trait&#39; class provided by the &#39;OpInterface&lt;&gt;&#39; base class.
</span><span class=c1></span><span class=k>class</span> <span class=nc>MyOp</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Op</span><span class=o>&lt;</span><span class=n>MyOp</span><span class=p>,</span> <span class=n>ExampleOpInterface</span><span class=o>:</span><span class=o>:</span><span class=n>Trait</span><span class=o>&gt;</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
  <span class=c1>/// The definition of the interface method on the derived operation.
</span><span class=c1></span>  <span class=kt>unsigned</span> <span class=n>getNumInputs</span><span class=p>(</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>;</span> <span class=p>}</span>
<span class=p>}</span><span class=p>;</span>

<span class=c1>/// Later, we can query if a specific operation(like &#39;MyOp&#39;) overrides the given
</span><span class=c1></span><span class=c1>/// interface.
</span><span class=c1></span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span> <span class=o>=</span> <span class=p>.</span><span class=p>.</span><span class=p>.</span><span class=p>;</span>
<span class=k>if</span> <span class=p>(</span><span class=n>ExampleOpInterface</span> <span class=n>example</span> <span class=o>=</span> <span class=n>dyn_cast</span><span class=o>&lt;</span><span class=n>ExampleOpInterface</span><span class=o>&gt;</span><span class=p>(</span><span class=n>op</span><span class=p>)</span><span class=p>)</span>
  <span class=n>llvm</span><span class=o>:</span><span class=o>:</span><span class=n>errs</span><span class=p>(</span><span class=p>)</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=s>num inputs = </span><span class=s>&#34;</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=n>example</span><span class=p>.</span><span class=n>getNumInputs</span><span class=p>(</span><span class=p>)</span> <span class=o>&lt;</span><span class=o>&lt;</span> <span class=sa></span><span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</code></pre></div><h4 id=utilizing-the-ods-framework>Utilizing the ODS Framework&nbsp;<a class=headline-hash href=#utilizing-the-ods-framework>¶</a></h4><p>Operation interfaces require a bit of boiler plate to connect all of the pieces
together. The ODS(Operation Definition Specification) framework provides
simplified mechanisms for
<a href=/docs/OpDefinitions/#interfaces>defining interfaces</a>
.</p><p>As an example, using the ODS framework would allow for defining the example
interface above as:</p><div class=highlight><pre class=chroma><code class=language-tablegen data-lang=tablegen><span class=k>def</span> <span class=nv>ExampleOpInterface</span> <span class=p>:</span> <span class=nv>OpInterface</span><span class=p>&lt;</span><span class=s>&#34;ExampleOpInterface&#34;</span><span class=p>&gt;</span> <span class=p>{</span>
  <span class=k>let</span> <span class=nv>description</span> <span class=p>=</span> <span class=s>[{
</span><span class=s>    This is an example interface definition.
</span><span class=s>  }]</span><span class=p>;</span>

  <span class=k>let</span> <span class=nv>methods</span> <span class=p>=</span> <span class=p>[</span>
    <span class=nv>InterfaceMethod</span><span class=p>&lt;</span>
      <span class=s>&#34;Get the number of inputs for the current operation.&#34;</span><span class=p>,</span>
      <span class=s>&#34;unsigned&#34;</span><span class=p>,</span> <span class=s>&#34;getNumInputs&#34;</span>
    <span class=p>&gt;</span><span class=p>,</span>
  <span class=p>]</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><h4 id=operation-interface-list>Operation Interface List&nbsp;<a class=headline-hash href=#operation-interface-list>¶</a></h4><p>MLIR includes standard interfaces providing functionality that is
likely to be common across many different operations. Below is a list
of some key interfaces that may be used directly by any dialect. The
format of the header for each interface section goes as follows:</p><ul><li><code>Interface class name</code><ul><li>(<code>C++ class</code> &ndash; <code>ODS class</code>(if applicable))</li></ul></li></ul><h5 id=callinterfaces>CallInterfaces&nbsp;<a class=headline-hash href=#callinterfaces>¶</a></h5><ul><li><code>CallOpInterface</code> - Used to represent operations like &lsquo;call&rsquo;<ul><li><code>CallInterfaceCallable getCallableForCallee()</code></li></ul></li><li><code>CallableOpInterface</code> - Used to represent the target callee of call.<ul><li><code>Region * getCallableRegion()</code></li><li><code>ArrayRef&lt;Type> getCallableResults()</code></li></ul></li></ul><h5 id=regionkindinterfaces>RegionKindInterfaces&nbsp;<a class=headline-hash href=#regionkindinterfaces>¶</a></h5><ul><li><code>RegionKindInterface</code> - Used to describe the abstract semantics of regions.<ul><li><code>RegionKind getRegionKind(unsigned index)</code> - Return the kind of the region with the given index inside this operation.<ul><li>RegionKind::Graph - represents a graph region without control flow semantics</li><li>RegionKind::SSACFG - represents an
<a href=/docs/LangRef/#modeling-control-flow>SSA-style control flow</a>
region with basic blocks and reachability</li></ul></li><li><code>hasSSADominance(unsigned index)</code> - Return true if the region with the given index inside this operation requires dominance.</li></ul></li></ul><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/GenericDAGRewriter/ title="Generic DAG Rewriter Infrastructure"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Generic DAG Rewriter Infrastructure</a>
<a class="nav nav-next" href=/docs/CAPI/ title="MLIR C API">Next - MLIR C API <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Debugging/>Debugging</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=/docs/Dialects/Linalg/>'linalg' Dialect</a></li><li><a href=/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li><a href=/docs/Dialects/OpenMPDialect/>'omp' Dialect</a></li><li><a href=/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>'spv' Dialect</a></li><li><a href=/docs/Dialects/Standard/>'std' Dialect</a></li><li><a href=/docs/Dialects/Vector/>'vector' Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Rationale/UsageOfConst/>Usage of 'Const' in MLIR, for core IR types</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=/docs/Tutorials/DefiningAttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li></ul></li><li><a href=/docs/ReducerPasses/></a></li><li><a href=/docs/SCFPasses/></a></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/GenericDAGRewriter/>Generic DAG Rewriter Infrastructure</a></li><li class=active><a href=/docs/Interfaces/>Interfaces</a></li><li><a href=/docs/CAPI/>MLIR C API</a></li><li><a href=/docs/LangRef/>MLIR Language Reference</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=/docs/OpDefinitions/>Operation Definition Specification (ODS)</a></li><li><a href=/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=/docs/Passes/>Passes</a></li><li><a href=/docs/Quantization/>Quantization</a></li><li><a href=/docs/ShapeInference/>Shape Inference</a></li><li><a href=/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/Traits/>Traits</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>