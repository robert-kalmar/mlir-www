<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Code Documentation on MLIR</title><link>https://mlir.llvm.org/docs/</link><description>Recent content in Code Documentation on MLIR</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 29 Nov 2019 15:26:15 +0000</lastBuildDate><atom:link href="https://mlir.llvm.org/docs/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://mlir.llvm.org/docs/ReducerPasses/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/ReducerPasses/</guid><description>-reduction-tree: A general reduction tree pass for the MLIR Reduce Tool</description></item><item><title/><link>https://mlir.llvm.org/docs/SCFPasses/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/SCFPasses/</guid><description>-for-loop-specialization: Specialize for loops for vectorization -parallel-loop-fusion: Fuse adjacent parallel loops -parallel-loop-specialization: Specialize parallel loops for vectorization -parallel-loop-tiling: Tile parallel loops Options -parallel-loop-tile-sizes : Factors to tile parallel loops by</description></item><item><title>Background: declarative builders API</title><link>https://mlir.llvm.org/docs/EDSC/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/EDSC/</guid><description>The main purpose of the declarative builders API is to provide an intuitive way of constructing MLIR programmatically. In the majority of cases, the IR we wish to construct exhibits structured control-flow. The Declarative builders in the EDSC library (Embedded Domain Specific Constructs) provide an API to make MLIR construction and manipulation very idiomatic, for the structured control-flow case, in C++.
ScopedContext mlir::edsc::ScopedContext provides an implicit thread-local context, supporting a simple declarative API with globally accessible builders.</description></item><item><title>Conversion to the LLVM Dialect</title><link>https://mlir.llvm.org/docs/ConversionToLLVMDialect/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/ConversionToLLVMDialect/</guid><description>Conversion from the Standard to the LLVM Dialect can be performed by the specialized dialect conversion pass by running:
mlir-opt -convert-std-to-llvm &amp;lt;filename.mlir&amp;gt; It performs type and operation conversions for a subset of operations from standard dialect (operations on scalars and vectors, control flow operations) as described in this document. We use the terminology defined by the LLVM IR Dialect description throughout this document.
Type Conversion Scalar Types Index Type Vector Types Memref Types Function Types Calling Convention Function Signature Conversion Result Packing Calling Convention for Ranked memref Calling Convention for Unranked memref C-compatible wrapper emission Repeated Successor Removal Default Memref Model Memref Descriptor Index Linearization Type Conversion Scalar Types Scalar types are converted to their LLVM counterparts if they exist.</description></item><item><title>Diagnostic Infrastructure</title><link>https://mlir.llvm.org/docs/Diagnostics/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Diagnostics/</guid><description>Source Locations CallSite Location FileLineCol Location Fused Location Name Location Opaque Location Unknown Location Diagnostic Engine Constructing a Diagnostic Diagnostic Appending arguments Attaching notes InFlight Diagnostic Diagnostic Configuration Options Print Operation On Diagnostic Print StackTrace On Diagnostic Common Diagnostic Handlers Scoped Diagnostic Handler SourceMgr Diagnostic Handler SourceMgr Diagnostic Verifier Handler Parallel Diagnostic Handler This document presents an introduction to using and interfacing with MLIR&amp;rsquo;s diagnostics infrastructure.</description></item><item><title>Dialect Conversion</title><link>https://mlir.llvm.org/docs/DialectConversion/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/DialectConversion/</guid><description>This document describes a framework in MLIR in which to perform operation conversions between, and within dialects. This framework allows for transforming illegal operations to those supported by a provided conversion target, via a set of pattern-based operation rewriting patterns.
Modes of Conversion Conversion Target Recursive Legality Rewrite Pattern Specification Restrictions Type Conversion Type Converter Conversion Patterns Region Signature Conversion To utilize the framework, a few things must be provided:</description></item><item><title>Generic DAG Rewriter Infrastructure</title><link>https://mlir.llvm.org/docs/GenericDAGRewriter/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/GenericDAGRewriter/</guid><description>Introduction and Motivation The goal of a compiler IR is to represent code - at various levels of abstraction which pose different sets of tradeoffs in terms of representational capabilities and ease of transformation. However, the ability to represent code is not itself very useful - you also need to be able to implement those transformations.
There are many different sorts of compiler transformations, but this document focuses on a particularly important class of transformation that comes up repeatedly at scale, and is important for the immediate goals of MLIR: that of pattern matching on a set of operations and replacing with another set.</description></item><item><title>Interfaces</title><link>https://mlir.llvm.org/docs/Interfaces/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Interfaces/</guid><description>MLIR is a generic and extensible framework, representing different dialects with their own operations, attributes, types, and so on. MLIR Dialects can express operations with a wide variety of semantics and different levels of abstraction. The downside to this is that MLIR transformations and analyses need to account for the semantics of every operation, or handle operations conservatively. Without care, this can result in code with special-cases for each supported operation type.</description></item><item><title>MLIR C API</title><link>https://mlir.llvm.org/docs/CAPI/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/CAPI/</guid><description>Current status: Under development, API unstable, built by default.
Design Many languages can interoperate with C but have a harder time with C++ due to name mangling and memory model differences. Although the C API for MLIR can be used directly from C, it is primarily intended to be wrapped in higher-level language- or library-specific constructs. Therefore the API tends towards simplicity and feature minimalism.
Note: while the C API is expected to be more stable than C++ API, it currently offers no stability guarantees.</description></item><item><title>MLIR Language Reference</title><link>https://mlir.llvm.org/docs/LangRef/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/LangRef/</guid><description>MLIR (Multi-Level IR) is a compiler intermediate representation with similarities to traditional three-address SSA representations (like LLVM IR or SIL ), but which introduces notions from polyhedral loop optimization as first-class concepts. This hybrid design is optimized to represent, analyze, and transform high level dataflow graphs as well as target-specific code generated for high performance data parallel systems. Beyond its representational capabilities, its single continuous design provides a framework to lower from dataflow graphs to high-performance target-specific code.</description></item><item><title>Operation Canonicalization</title><link>https://mlir.llvm.org/docs/Canonicalization/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Canonicalization/</guid><description>Canonicalization is an important part of compiler IR design: it makes it easier to implement reliable compiler transformations and to reason about what is better or worse in the code, and it forces interesting discussions about the goals of a particular level of IR. Dan Gohman wrote an article exploring these issues; it is worth reading if you&amp;rsquo;re not familiar with these concepts.
Most compilers have canonicalization passes, and sometimes they have many different ones (e.</description></item><item><title>Operation Definition Specification (ODS)</title><link>https://mlir.llvm.org/docs/OpDefinitions/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/OpDefinitions/</guid><description>In addition to specializing the mlir::Op C++ template, MLIR also supports defining operations in a table-driven manner. This is achieved via TableGen , which is both a generic language and its tooling to maintain records of domain-specific information. Facts regarding an operation are specified concisely into a TableGen record, which will be expanded into an equivalent mlir::Op C++ template specialization at compiler build time.
This manual explains in detail all the available mechanisms for defining operations in such a table-driven manner.</description></item><item><title>Pass Infrastructure</title><link>https://mlir.llvm.org/docs/PassManagement/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/PassManagement/</guid><description>Operation Pass OperationPass : Op-Specific OperationPass : Op-Agnostic Analysis Management Querying Analyses Preserving Analyses Pass Failure Pass Manager OpPassManager Pass Registration Pass Pipeline Registration Textual Pass Pipeline Specification Instance Specific Pass Options Pass Statistics Declarative Pass Specification Tablegen Specification Pass Instrumentation Standard Instrumentations Crash and Failure Reproduction Local Reproducer Generation Passes represent the basic infrastructure for transformation and optimization.</description></item><item><title>Passes</title><link>https://mlir.llvm.org/docs/Passes/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Passes/</guid><description>This document describes the available MLIR passes and their contracts.
General Transformation Passes -affine-loop-fusion: Fuse affine loop nests -affine-pipeline-data-transfer: Pipeline non-blocking data transfers between explicitly managed levels of the memory hierarchy -buffer-placement: Optimizes placement of alloc and dealloc operations -canonicalize: Canonicalize operations -copy-removal: Remove the redundant copies from input IR -cse: Eliminate common sub-expressions -inline: Inline function calls -loop-coalescing: Coalesce nested loops with independent bounds into a single loop -loop-invariant-code-motion: Hoist loop invariant instructions outside of the loop -memref-dataflow-opt: Perform store/load forwarding for memrefs -normalize-memrefs: Normalize memrefs -parallel-loop-collapsing: Collapse parallel loops to use less induction variables -print-cfg-graph: Print CFG graph per-Region -print-op-graph: Print op graph per-Region -print-op-stats: Print statistics of operations -sccp: Sparse Conditional Constant Propagation -snapshot-op-locations: Generate new locations from the current IR -strip-debuginfo: Strip debug info from all operations -symbol-dce: Eliminate dead symbols Conversion Passes -convert-affine-for-to-gpu: Convert top-level AffineFor Ops to GPU kernels -convert-avx512-to-llvm: Convert the operations from the avx512 dialect into the LLVM dialect -convert-gpu-launch-to-vulkan-launch: Convert gpu.</description></item><item><title>Quantization</title><link>https://mlir.llvm.org/docs/Quantization/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Quantization/</guid><description>This document outlines the design of the MLIR quantization system. While the term &amp;ldquo;quantization&amp;rdquo; is highly overloaded, in this case, it refers to a fairly narrow scope of techniques in use to enable conversion of floating-point computations to corresponding and plausible variants expressed in integer math for inference, as has historically been supported by low-bit depth inference engines such as TFLite, various accelerator hardware, and many DSPs.
Much of this is inspired by the approach taken in this paper with many extensions and adaptations folded in.</description></item><item><title>Shape Inference</title><link>https://mlir.llvm.org/docs/ShapeInference/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/ShapeInference/</guid><description>Shape inference as discussed here is considered a specific instance of type inference for ShapedType . Type constraints are along (at least) three axis: 1) elemental type, 2) rank (including static or dynamic), 3) dimensions. While some operations have no compile time fixed shape (e.g., output shape is dictated by data) we could still have some knowledge of constraints/bounds in the system for that operation (e.g., the output of a tf.</description></item><item><title>SPIR-V Dialect to LLVM Dialect conversion manual</title><link>https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/</guid><description>This manual describes the conversion from SPIR-V Dialect to LLVM Dialect . It assumes familiarity with both, and describes the design choices behind the modelling of SPIR-V concepts in LLVM Dialect. The conversion is an ongoing work, and is expected to grow as more features are implemented.
Conversion can be performed by invoking an appropriate conversion pass:
mlir-opt -convert-spirv-to-llvm &amp;lt;filename.mlir&amp;gt; This pass performs type and operation conversions for SPIR-V operations as described in this document.</description></item><item><title>Symbols and Symbol Tables</title><link>https://mlir.llvm.org/docs/SymbolsAndSymbolTables/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/SymbolsAndSymbolTables/</guid><description>Symbol Defining a Symbol Symbol Table Referencing a Symbol Manipulating a Symbol Symbol Visibility With Regions , the multi-level aspect of MLIR is structural in the IR. A lot of infrastructure within the compiler is built around this nesting structure; including the processing of operations within the pass manager . One advantage of the MLIR design is that it is able to process operations in parallel, utilizing multiple threads.</description></item><item><title>Table-driven Declarative Rewrite Rule (DRR)</title><link>https://mlir.llvm.org/docs/DeclarativeRewrites/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/DeclarativeRewrites/</guid><description>In addition to subclassing the mlir::RewritePattern C++ class, MLIR also supports defining rewrite rules in a declarative manner. Similar to Op Definition Specification (ODS), this is achieved via TableGen , which is a language to maintain records of domain-specific information. The rewrite rules are specified concisely in a TableGen record, which will be expanded into an equivalent mlir::RewritePattern subclass at compiler build time.
This manual explains in detail all of the available mechanisms for defining rewrite rules in such a declarative manner.</description></item><item><title>Traits</title><link>https://mlir.llvm.org/docs/Traits/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Traits/</guid><description>Defining a Trait Parametric Traits Attaching a Trait Attaching Operation Traits in ODS Using a Trait Operation Traits List AffineScope AutomaticAllocationScope Broadcastable Commutative Function-Like HasParent IsolatedFromAbove Single Block with Implicit Terminator Symbol SymbolTable Terminator MLIR allows for a truly open ecosystem, as any dialect may define attributes, operations, and types that suit a specific level of abstraction. Traits are a mechanism which abstracts implementation details and properties that are common across many different attributes/operations/types/etc.</description></item></channel></rss>