<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::Type Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">12.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1Type.html">Type</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmlir_1_1Type-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::Type Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Instances of the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> class are uniqued, have an immutable identifier and an optional mutable component.  
 <a href="classmlir_1_1Type.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="Types_8h_source.html">mlir/IR/Types.h</a>&quot;</code></p>
<div class="dynheader">
Inheritance diagram for mlir::Type:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1Type__inherit__graph.png" border="0" usemap="#mlir_1_1Type_inherit__map" alt="Inheritance graph"/></div>
<map name="mlir_1_1Type_inherit__map" id="mlir_1_1Type_inherit__map">
<area shape="rect" id="node2" href="classmlir_1_1detail_1_1Interface.html" title="mlir::detail::Interface\l\&lt; ConcreteType, Type,\l Traits, Type, TypeTrait\l::TraitBase \&gt;" alt="" coords="143,5,302,76"/>
<area shape="rect" id="node4" href="classmlir_1_1LLVM_1_1LLVMType.html" title="Base class for LLVM dialect types. " alt="" coords="145,101,301,127"/>
<area shape="rect" id="node6" href="classmlir_1_1quant_1_1QuantizedType.html" title="Base class for all quantized types known to this dialect. " alt="" coords="133,151,312,178"/>
<area shape="rect" id="node7" href="classmlir_1_1ShapedType.html" title="This is a common base class between Vector, UnrankedTensor, RankedTensor, and MemRef types because th..." alt="" coords="161,202,285,229"/>
<area shape="rect" id="node10" href="classmlir_1_1spirv_1_1SPIRVType.html" title="mlir::spirv::SPIRVType" alt="" coords="144,253,301,279"/>
<area shape="rect" id="node3" href="classmlir_1_1TypeInterface.html" title="This class represents the base of a type interface. " alt="" coords="373,20,542,61"/>
<area shape="rect" id="node5" href="classmlir_1_1LLVM_1_1LLVMVectorType.html" title="LLVM dialect vector type, represents a sequence of elements that can be processed as one..." alt="" coords="360,101,555,127"/>
<area shape="rect" id="node8" href="classmlir_1_1BaseMemRefType.html" title="Base MemRef for Ranked and Unranked variants. " alt="" coords="377,151,537,178"/>
<area shape="rect" id="node9" href="classmlir_1_1TensorType.html" title="Tensor types represent multi&#45;dimensional arrays, and have two variants: RankedTensorType and Unranked..." alt="" coords="397,202,517,229"/>
<area shape="rect" id="node11" href="classmlir_1_1spirv_1_1CompositeType.html" title="mlir::spirv::CompositeType" alt="" coords="368,253,547,279"/>
<area shape="rect" id="node12" href="classmlir_1_1spirv_1_1ScalarType.html" title="mlir::spirv::ScalarType" alt="" coords="381,303,534,330"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mlir::Type:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1Type__coll__graph.png" border="0" usemap="#mlir_1_1Type_coll__map" alt="Collaboration graph"/></div>
<map name="mlir_1_1Type_coll__map" id="mlir_1_1Type_coll__map">
<area shape="rect" id="node2" href="classmlir_1_1TypeStorage.html" title="Base storage class appearing in a Type. " alt="" coords="13,96,139,123"/>
<area shape="rect" id="node3" href="classmlir_1_1StorageUniquer_1_1BaseStorage.html" title="This class acts as the base storage that all storage classes must derived from. " alt="" coords="5,5,147,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab90b5287ad4211defb81009855047557"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ab90b5287ad4211defb81009855047557">Kind</a> { <br />
&#160;&#160;<a class="el" href="classmlir_1_1Type.html#ab90b5287ad4211defb81009855047557a0e7baa30be66118faf0a000eb6d5c052">Function</a>, 
<a class="el" href="classmlir_1_1Type.html#ab90b5287ad4211defb81009855047557a29757f2265087eaa32051dc000f55bd0">Opaque</a>, 
<a class="el" href="classmlir_1_1Type.html#ab90b5287ad4211defb81009855047557a40d878fc34e40e22a30c4c0316443b09">LAST_BUILTIN_TYPE</a> = Opaque, 
<a class="el" href="classmlir_1_1Type.html#ab90b5287ad4211defb81009855047557a2a3698ae6ae4e77082b2f91425a993ad">DEFINE_SYM_KIND_RANGE</a>, 
<br />
&#160;&#160;<a class="el" href="classmlir_1_1Type.html#ab90b5287ad4211defb81009855047557a2a3698ae6ae4e77082b2f91425a993ad">DEFINE_SYM_KIND_RANGE</a>
<br />
 }<tr class="memdesc:ab90b5287ad4211defb81009855047557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer identifier for all the concrete type kinds.  <a href="classmlir_1_1Type.html#ab90b5287ad4211defb81009855047557">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ab90b5287ad4211defb81009855047557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd35e3f5186bd1c0e4c4f53f69aad716"><td class="memTemplParams" colspan="2">template&lt;typename ConcreteType , typename BaseType , typename StorageType , template&lt; typename T &gt; class... Traits&gt; </td></tr>
<tr class="memitem:acd35e3f5186bd1c0e4c4f53f69aad716"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#acd35e3f5186bd1c0e4c4f53f69aad716">TypeBase</a> = <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">detail::StorageUserBase</a>&lt; ConcreteType, <a class="el" href="classmlir_1_1detail_1_1BaseType.html">BaseType</a>, StorageType, <a class="el" href="structmlir_1_1detail_1_1TypeUniquer.html">detail::TypeUniquer</a>, Traits... &gt;</td></tr>
<tr class="memdesc:acd35e3f5186bd1c0e4c4f53f69aad716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for implementing types.  <a href="#acd35e3f5186bd1c0e4c4f53f69aad716">More...</a><br /></td></tr>
<tr class="separator:acd35e3f5186bd1c0e4c4f53f69aad716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89de246b01ef652963e1ddde953d62e7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">ImplType</a> = <a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td></tr>
<tr class="separator:a89de246b01ef652963e1ddde953d62e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5472fc9326984b512232b1ac27114629"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a5472fc9326984b512232b1ac27114629">Type</a> ()</td></tr>
<tr class="separator:a5472fc9326984b512232b1ac27114629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8871458ee7b2abdca3e94788ae3048"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#aaa8871458ee7b2abdca3e94788ae3048">Type</a> (const <a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">ImplType</a> *<a class="el" href="classmlir_1_1Type.html#a54af6c081e012a32bba9b650480c6c06">impl</a>)</td></tr>
<tr class="separator:aaa8871458ee7b2abdca3e94788ae3048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237023ae4dcab369d064457a10bcf518"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a237023ae4dcab369d064457a10bcf518">Type</a> (const <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;other)=default</td></tr>
<tr class="separator:a237023ae4dcab369d064457a10bcf518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860e9e7612215565aadad622ccf4cbb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a860e9e7612215565aadad622ccf4cbb0">operator=</a> (const <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;other)=default</td></tr>
<tr class="separator:a860e9e7612215565aadad622ccf4cbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53df1249058e8c2ec0fa70f172f0b59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ac53df1249058e8c2ec0fa70f172f0b59">operator==</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> other) const</td></tr>
<tr class="separator:ac53df1249058e8c2ec0fa70f172f0b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1be45203a0010965388d41e712dc268"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ad1be45203a0010965388d41e712dc268">operator!=</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> other) const</td></tr>
<tr class="separator:ad1be45203a0010965388d41e712dc268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb8b20e59002a0fedfcb93e314b416f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#afeb8b20e59002a0fedfcb93e314b416f">operator bool</a> () const</td></tr>
<tr class="separator:afeb8b20e59002a0fedfcb93e314b416f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac516f7c8eb957068555b5781d78f23af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ac516f7c8eb957068555b5781d78f23af">operator!</a> () const</td></tr>
<tr class="separator:ac516f7c8eb957068555b5781d78f23af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd295cf88ab7faa33601d3bbee5c4b8"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:adcd295cf88ab7faa33601d3bbee5c4b8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#adcd295cf88ab7faa33601d3bbee5c4b8">isa</a> () const</td></tr>
<tr class="separator:adcd295cf88ab7faa33601d3bbee5c4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297bb52f523ab1064dc72f39a451cb18"><td class="memTemplParams" colspan="2">template&lt;typename First , typename Second , typename... Rest&gt; </td></tr>
<tr class="memitem:a297bb52f523ab1064dc72f39a451cb18"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a297bb52f523ab1064dc72f39a451cb18">isa</a> () const</td></tr>
<tr class="separator:a297bb52f523ab1064dc72f39a451cb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8d33d03b9736dfcc3cc0e9351b1826"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a6b8d33d03b9736dfcc3cc0e9351b1826"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a6b8d33d03b9736dfcc3cc0e9351b1826">dyn_cast</a> () const</td></tr>
<tr class="separator:a6b8d33d03b9736dfcc3cc0e9351b1826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ca8bbee5e3e8a02e0df18897981edf"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a33ca8bbee5e3e8a02e0df18897981edf"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a33ca8bbee5e3e8a02e0df18897981edf">dyn_cast_or_null</a> () const</td></tr>
<tr class="separator:a33ca8bbee5e3e8a02e0df18897981edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9c3e06d3b23ad9457c13cb828a7c48"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a1a9c3e06d3b23ad9457c13cb828a7c48"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a1a9c3e06d3b23ad9457c13cb828a7c48">cast</a> () const</td></tr>
<tr class="separator:a1a9c3e06d3b23ad9457c13cb828a7c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf7dade447f73f5b04c46fcf616b68c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#accf7dade447f73f5b04c46fcf616b68c">getTypeID</a> ()</td></tr>
<tr class="memdesc:accf7dade447f73f5b04c46fcf616b68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a unique identifier for the concrete type.  <a href="#accf7dade447f73f5b04c46fcf616b68c">More...</a><br /></td></tr>
<tr class="separator:accf7dade447f73f5b04c46fcf616b68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770133e69450b7252813d64642b3d6c5"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a770133e69450b7252813d64642b3d6c5">getKind</a> () const</td></tr>
<tr class="memdesc:a770133e69450b7252813d64642b3d6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the classification for this type.  <a href="#a770133e69450b7252813d64642b3d6c5">More...</a><br /></td></tr>
<tr class="separator:a770133e69450b7252813d64642b3d6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3951cad794a5bc5ad086158c20f8e50e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a3951cad794a5bc5ad086158c20f8e50e">getContext</a> () const</td></tr>
<tr class="memdesc:a3951cad794a5bc5ad086158c20f8e50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the LLVMContext in which this type was uniqued.  <a href="#a3951cad794a5bc5ad086158c20f8e50e">More...</a><br /></td></tr>
<tr class="separator:a3951cad794a5bc5ad086158c20f8e50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21810b671ec68509499ee2d4f10a8a6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Dialect.html">Dialect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a21810b671ec68509499ee2d4f10a8a6b">getDialect</a> () const</td></tr>
<tr class="memdesc:a21810b671ec68509499ee2d4f10a8a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dialect this type is registered to.  <a href="#a21810b671ec68509499ee2d4f10a8a6b">More...</a><br /></td></tr>
<tr class="separator:a21810b671ec68509499ee2d4f10a8a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04cd125cd035f98f0bbbdec875f4f90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ae04cd125cd035f98f0bbbdec875f4f90">isIndex</a> ()</td></tr>
<tr class="separator:ae04cd125cd035f98f0bbbdec875f4f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219cbb23b0bbf98773dc73d5ba5b13ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a219cbb23b0bbf98773dc73d5ba5b13ed">isBF16</a> ()</td></tr>
<tr class="separator:a219cbb23b0bbf98773dc73d5ba5b13ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf9ffe711f6a40ec2558f094e0fe3d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#addf9ffe711f6a40ec2558f094e0fe3d0">isF16</a> ()</td></tr>
<tr class="separator:addf9ffe711f6a40ec2558f094e0fe3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee1dfc71fe79d72fb86df381afa28f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a2ee1dfc71fe79d72fb86df381afa28f8">isF32</a> ()</td></tr>
<tr class="separator:a2ee1dfc71fe79d72fb86df381afa28f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15aebbbf2b0d7cefda956b63af8ee0d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a15aebbbf2b0d7cefda956b63af8ee0d4">isF64</a> ()</td></tr>
<tr class="separator:a15aebbbf2b0d7cefda956b63af8ee0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ffc49524ecdd46d15a8449e23267b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ad3ffc49524ecdd46d15a8449e23267b1">isInteger</a> (unsigned width)</td></tr>
<tr class="memdesc:ad3ffc49524ecdd46d15a8449e23267b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an integer type with the specified width.  <a href="#ad3ffc49524ecdd46d15a8449e23267b1">More...</a><br /></td></tr>
<tr class="separator:ad3ffc49524ecdd46d15a8449e23267b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae898f9e92614ee853dae9550f0c0cb42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ae898f9e92614ee853dae9550f0c0cb42">isSignlessInteger</a> ()</td></tr>
<tr class="memdesc:ae898f9e92614ee853dae9550f0c0cb42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a signless integer type (with the specified width).  <a href="#ae898f9e92614ee853dae9550f0c0cb42">More...</a><br /></td></tr>
<tr class="separator:ae898f9e92614ee853dae9550f0c0cb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7f725d5ba2ed45e6cf96e55340df92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a2c7f725d5ba2ed45e6cf96e55340df92">isSignlessInteger</a> (unsigned width)</td></tr>
<tr class="separator:a2c7f725d5ba2ed45e6cf96e55340df92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad42bce36d1e840c0062f47b6217697"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#acad42bce36d1e840c0062f47b6217697">isSignedInteger</a> ()</td></tr>
<tr class="memdesc:acad42bce36d1e840c0062f47b6217697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a signed integer type (with the specified width).  <a href="#acad42bce36d1e840c0062f47b6217697">More...</a><br /></td></tr>
<tr class="separator:acad42bce36d1e840c0062f47b6217697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65d5882f70083eb6c559cb89e773fcd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#aa65d5882f70083eb6c559cb89e773fcd">isSignedInteger</a> (unsigned width)</td></tr>
<tr class="separator:aa65d5882f70083eb6c559cb89e773fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f201aa3fa231a5ffc7d69398d037943"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a2f201aa3fa231a5ffc7d69398d037943">isUnsignedInteger</a> ()</td></tr>
<tr class="memdesc:a2f201aa3fa231a5ffc7d69398d037943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an unsigned integer type (with the specified width).  <a href="#a2f201aa3fa231a5ffc7d69398d037943">More...</a><br /></td></tr>
<tr class="separator:a2f201aa3fa231a5ffc7d69398d037943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7c507dfd35359a3f18ae5af691cca2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#aac7c507dfd35359a3f18ae5af691cca2">isUnsignedInteger</a> (unsigned width)</td></tr>
<tr class="separator:aac7c507dfd35359a3f18ae5af691cca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae211db2caefd9718134acd88becc670c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ae211db2caefd9718134acd88becc670c">getIntOrFloatBitWidth</a> ()</td></tr>
<tr class="memdesc:ae211db2caefd9718134acd88becc670c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bit width of an integer or a float type, assert failure on other types.  <a href="#ae211db2caefd9718134acd88becc670c">More...</a><br /></td></tr>
<tr class="separator:ae211db2caefd9718134acd88becc670c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05ab14ebc486cbf6f9dcb927798b50c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ac05ab14ebc486cbf6f9dcb927798b50c">isSignlessIntOrIndex</a> ()</td></tr>
<tr class="memdesc:ac05ab14ebc486cbf6f9dcb927798b50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a signless integer or index type.  <a href="#ac05ab14ebc486cbf6f9dcb927798b50c">More...</a><br /></td></tr>
<tr class="separator:ac05ab14ebc486cbf6f9dcb927798b50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fbea201d963746a7087848dd458e58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a53fbea201d963746a7087848dd458e58">isSignlessIntOrIndexOrFloat</a> ()</td></tr>
<tr class="memdesc:a53fbea201d963746a7087848dd458e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a signless integer, index, or float type.  <a href="#a53fbea201d963746a7087848dd458e58">More...</a><br /></td></tr>
<tr class="separator:a53fbea201d963746a7087848dd458e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54918532e69215a77134665764abfe03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a54918532e69215a77134665764abfe03">isSignlessIntOrFloat</a> ()</td></tr>
<tr class="memdesc:a54918532e69215a77134665764abfe03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true of this is a signless integer or a float type.  <a href="#a54918532e69215a77134665764abfe03">More...</a><br /></td></tr>
<tr class="separator:a54918532e69215a77134665764abfe03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4fa1595a42d6b3ae872fc303249b5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a6a4fa1595a42d6b3ae872fc303249b5e">isIntOrIndex</a> ()</td></tr>
<tr class="memdesc:a6a4fa1595a42d6b3ae872fc303249b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an integer (of any signedness) or an index type.  <a href="#a6a4fa1595a42d6b3ae872fc303249b5e">More...</a><br /></td></tr>
<tr class="separator:a6a4fa1595a42d6b3ae872fc303249b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f2df233ac9b650c85992d365b08419"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#af2f2df233ac9b650c85992d365b08419">isIntOrFloat</a> ()</td></tr>
<tr class="memdesc:af2f2df233ac9b650c85992d365b08419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an integer (of any signedness) or a float type.  <a href="#af2f2df233ac9b650c85992d365b08419">More...</a><br /></td></tr>
<tr class="separator:af2f2df233ac9b650c85992d365b08419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4258b26dd83dba9fc87fc7220639bf4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ad4258b26dd83dba9fc87fc7220639bf4">isIntOrIndexOrFloat</a> ()</td></tr>
<tr class="memdesc:ad4258b26dd83dba9fc87fc7220639bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an integer (of any signedness), index, or float type.  <a href="#ad4258b26dd83dba9fc87fc7220639bf4">More...</a><br /></td></tr>
<tr class="separator:ad4258b26dd83dba9fc87fc7220639bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f326ccb845e5e7f384a8069153f305"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a94f326ccb845e5e7f384a8069153f305">print</a> (raw_ostream &amp;os)</td></tr>
<tr class="memdesc:a94f326ccb845e5e7f384a8069153f305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the current type.  <a href="#a94f326ccb845e5e7f384a8069153f305">More...</a><br /></td></tr>
<tr class="separator:a94f326ccb845e5e7f384a8069153f305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975aa15f5744af5a899e491135ab1384"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a975aa15f5744af5a899e491135ab1384">dump</a> ()</td></tr>
<tr class="separator:a975aa15f5744af5a899e491135ab1384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1035844c344d17a9e6081c6a0e101b80"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a1035844c344d17a9e6081c6a0e101b80">getAsOpaquePointer</a> () const</td></tr>
<tr class="memdesc:a1035844c344d17a9e6081c6a0e101b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for supporting PointerLikeTypeTraits.  <a href="#a1035844c344d17a9e6081c6a0e101b80">More...</a><br /></td></tr>
<tr class="separator:a1035844c344d17a9e6081c6a0e101b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225471c06d85dd43b0848a90d68adb18"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlir_1_1AbstractType.html">AbstractType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a225471c06d85dd43b0848a90d68adb18">getAbstractType</a> ()</td></tr>
<tr class="memdesc:a225471c06d85dd43b0848a90d68adb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the abstract type descriptor for this type.  <a href="#a225471c06d85dd43b0848a90d68adb18">More...</a><br /></td></tr>
<tr class="separator:a225471c06d85dd43b0848a90d68adb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a20187f3bc53c94040a83d41de0119a59"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a20187f3bc53c94040a83d41de0119a59">classof</a> (<a class="el" href="classmlir_1_1Type.html">Type</a>)</td></tr>
<tr class="separator:a20187f3bc53c94040a83d41de0119a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b903c935dfc504b4f4e3f77939b113"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a58b903c935dfc504b4f4e3f77939b113">getFromOpaquePointer</a> (const void *pointer)</td></tr>
<tr class="separator:a58b903c935dfc504b4f4e3f77939b113"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a54af6c081e012a32bba9b650480c6c06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">ImplType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a54af6c081e012a32bba9b650480c6c06">impl</a></td></tr>
<tr class="separator:a54af6c081e012a32bba9b650480c6c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a54ee333db7234f6ada1036072a24b877"><td class="memItemLeft" align="right" valign="top">::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a54ee333db7234f6ada1036072a24b877">hash_value</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> arg)</td></tr>
<tr class="separator:a54ee333db7234f6ada1036072a24b877"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Instances of the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> class are uniqued, have an immutable identifier and an optional mutable component. </p>
<p>They wrap a pointer to the storage object owned by <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR modules. ">MLIRContext</a>. Therefore, instances of <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> are passed around by value.</p>
<p>Some types are "primitives" meaning they do not have any parameters, for example the Index type. Parametric types have additional information that differentiates the types of the same kind between them, for example the Integer type has bitwidth, making i8 and i16 belong to the same kind by be different instances of the <a class="el" href="classmlir_1_1IntegerType.html" title="Integer types can have arbitrary bitwidth up to a large fixed limit. ">IntegerType</a>. <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> parameters are part of the unique immutable key. The mutable component of the type can be modified after the type is created, but cannot affect the identity of the type.</p>
<p>Types are constructed and uniqued via the '<a class="el" href="structmlir_1_1detail_1_1TypeUniquer.html" title="A utility class to get, or create, unique instances of types within an MLIRContext. ">detail::TypeUniquer</a>' class.</p>
<p>Derived type classes are expected to implement several required implementation hooks:</p><ul>
<li>Optional:<ul>
<li>static <a class="el" href="structmlir_1_1LogicalResult.html" title="Values that can be used to signal success/failure. ">LogicalResult</a> verifyConstructionInvariants(<a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> loc, Args... args)<ul>
<li>This method is invoked when calling the '<a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a858ef61c81f98e989e04ca730496269c" title="Get or create a new ConcreteT instance within the ctx. ">TypeBase::get</a>/getChecked' methods to ensure that the arguments passed in are valid to construct a type instance with.</li>
<li>This method is expected to return failure if a type cannot be constructed with 'args', success otherwise.</li>
<li>'args' must correspond with the arguments passed into the '<a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a858ef61c81f98e989e04ca730496269c" title="Get or create a new ConcreteT instance within the ctx. ">TypeBase::get</a>' call after the type kind.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a> storage objects inherit from <a class="el" href="classmlir_1_1TypeStorage.html" title="Base storage class appearing in a Type. ">TypeStorage</a> and contain the following:</p><ul>
<li>The type kind (for LLVM-style RTTI).</li>
<li>The dialect that defined the type.</li>
<li>Any parameters of the type.</li>
<li>An optional mutable component. For non-parametric types, a convenience DefaultTypeStorage is provided. Parametric storage types must derive <a class="el" href="classmlir_1_1TypeStorage.html" title="Base storage class appearing in a Type. ">TypeStorage</a> and respect the following:</li>
<li>Define a type alias, KeyTy, to a type that uniquely identifies the instance of the type within its kind.<ul>
<li>The key type must be constructible from the values passed into the <a class="el" href="structmlir_1_1detail_1_1TypeUniquer.html#acdabc2f7217d189350aca91d32a3dd66" title="Get an uniqued instance of a type T. ">detail::TypeUniquer::get</a> call after the type kind.</li>
<li>If the KeyTy does not have an <a class="el" href="structllvm_1_1DenseMapInfo.html">llvm::DenseMapInfo</a> specialization, the storage class must define a hashing method: 'static unsigned hashKey(const KeyTy &amp;)'</li>
</ul>
</li>
<li>Provide a method, 'bool operator==(const KeyTy &amp;) const', to compare the storage instance against an instance of the key type.</li>
<li>Provide a static construction method: 'DerivedStorage *construct(TypeStorageAllocator &amp;, const KeyTy &amp;key)' that builds a unique instance of the derived storage. The arguments to this function are an allocator to store any uniqued data within the context and the key type for this storage.</li>
<li>If they have a mutable component, this component must not be a part of </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00085">85</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a89de246b01ef652963e1ddde953d62e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89de246b01ef652963e1ddde953d62e7">&#9670;&nbsp;</a></span>ImplType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">mlir::Type::ImplType</a> =  <a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00110">110</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="acd35e3f5186bd1c0e4c4f53f69aad716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd35e3f5186bd1c0e4c4f53f69aad716">&#9670;&nbsp;</a></span>TypeBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , typename BaseType , typename StorageType , template&lt; typename T &gt; class... Traits&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1Type.html#acd35e3f5186bd1c0e4c4f53f69aad716">mlir::Type::TypeBase</a> =  <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">detail::StorageUserBase</a>&lt;ConcreteType, <a class="el" href="classmlir_1_1detail_1_1BaseType.html">BaseType</a>, StorageType, <a class="el" href="structmlir_1_1detail_1_1TypeUniquer.html">detail::TypeUniquer</a>, Traits...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility class for implementing types. </p>

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00108">108</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ab90b5287ad4211defb81009855047557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90b5287ad4211defb81009855047557">&#9670;&nbsp;</a></span>Kind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classmlir_1_1Type.html#ab90b5287ad4211defb81009855047557">mlir::Type::Kind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer identifier for all the concrete type kinds. </p>
<p>Note: This is not an enum class as each dialect will likely define a separate enumeration for the specific types that they define. Not being an enum class also simplifies the handling of type kinds by not requiring casts for each use. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab90b5287ad4211defb81009855047557a0e7baa30be66118faf0a000eb6d5c052"></a>Function&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab90b5287ad4211defb81009855047557a29757f2265087eaa32051dc000f55bd0"></a>Opaque&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab90b5287ad4211defb81009855047557a40d878fc34e40e22a30c4c0316443b09"></a>LAST_BUILTIN_TYPE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab90b5287ad4211defb81009855047557a2a3698ae6ae4e77082b2f91425a993ad"></a>DEFINE_SYM_KIND_RANGE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab90b5287ad4211defb81009855047557a2a3698ae6ae4e77082b2f91425a993ad"></a>DEFINE_SYM_KIND_RANGE&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00092">92</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5472fc9326984b512232b1ac27114629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5472fc9326984b512232b1ac27114629">&#9670;&nbsp;</a></span>Type() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mlir::Type::Type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00112">112</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="aaa8871458ee7b2abdca3e94788ae3048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8871458ee7b2abdca3e94788ae3048">&#9670;&nbsp;</a></span>Type() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::Type::Type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">ImplType</a> *&#160;</td>
          <td class="paramname"><em>impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00113">113</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00191">mlir::StandardAttributes::Type</a>.</p>

</div>
</div>
<a id="a237023ae4dcab369d064457a10bcf518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237023ae4dcab369d064457a10bcf518">&#9670;&nbsp;</a></span>Type() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::Type::Type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1a9c3e06d3b23ad9457c13cb828a7c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9c3e06d3b23ad9457c13cb828a7c48">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">U mlir::Type::cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00328">328</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="QuantTypes_8cpp_source.html#l00146">mlir::quant::QuantizedType::castFromExpressedType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00102">mlir::quant::QuantizedType::castFromStorageType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00171">mlir::quant::QuantizedType::castToExpressedType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00122">mlir::quant::QuantizedType::castToStorageType()</a>, <a class="el" href="Attributes_8cpp_source.html#l01188">mlir::DenseFPElementsAttr::classof()</a>, <a class="el" href="Attributes_8cpp_source.html#l01207">mlir::DenseIntElementsAttr::classof()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00674">computeTensorReshapeCollapsedType()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00568">convertReassociationIndicesToMaps()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00234">convertScalarType()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00082">createConstantAllBitsSet()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00095">createFPConstant()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00027">createGlobalVarForEntryPointArgument()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02178">createScopedSubViewIntersection()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00064">doubleBuffer()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00095">extractOne()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00435">mlir::StructBuilder::extractPtr()</a>, <a class="el" href="VectorOps_8cpp_source.html#l02079">extractShape()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01720">foldTransferMaskAttribute()</a>, <a class="el" href="UniformSupport_8cpp_source.html#l00021">mlir::quant::ExpressedToQuantizedConverter::forInputType()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01709">generateCopy()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01620">generatePointWiseCopy()</a>, <a class="el" href="Attributes_8cpp_source.html#l00312">mlir::IntegerAttr::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l00802">mlir::DenseElementsAttr::get()</a>, <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l00237">getAtomicOpScope()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00249">mlir::spirv::CompositeType::getCapabilities()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00148">mlir::spirv::ArrayType::getCapabilities()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00570">mlir::spirv::RuntimeArrayType::getCapabilities()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00350">mlir::spirv::CooperativeMatrixNVType::getCapabilities()</a>, <a class="el" href="Attributes_8cpp_source.html#l00995">mlir::DenseElementsAttr::getComplexFloatValues()</a>, <a class="el" href="Attributes_8cpp_source.html#l00971">mlir::DenseElementsAttr::getComplexIntValues()</a>, <a class="el" href="AffineOps_8h_source.html#l00141">mlir::AffineDmaStartOp::getDstMemorySpace()</a>, <a class="el" href="AffineOps_8h_source.html#l00136">mlir::AffineDmaStartOp::getDstMemRefRank()</a>, <a class="el" href="AffineOps_8h_source.html#l00131">mlir::AffineDmaStartOp::getDstMemRefType()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00650">mlir::MemRefDescriptor::getElementType()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01027">mlir::spirv::MatrixType::getElementType()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00221">mlir::spirv::CompositeType::getExtensions()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00143">mlir::spirv::ArrayType::getExtensions()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00564">mlir::spirv::RuntimeArrayType::getExtensions()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00341">mlir::spirv::CooperativeMatrixNVType::getExtensions()</a>, <a class="el" href="Attributes_8cpp_source.html#l00982">mlir::DenseElementsAttr::getFloatValues()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02000">getFullMemRefAsRegion()</a>, <a class="el" href="Loops_8cpp_source.html#l00165">getInputAndOutputIndices()</a>, <a class="el" href="LinalgTraits_8h_source.html#l00221">mlir::OpTrait::linalg::StructuredOpTraits&lt; ConcreteType &gt;::getInputOutputShapedTypes()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00134">mlir::detail::FloatAttributeStorage::getKey()</a>, <a class="el" href="LinalgToSPIRV_8cpp_source.html#l00028">getLocalInvocationDimSize()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00122">getMemRefAlignment()</a>, <a class="el" href="Dialect_2StandardOps_2EDSC_2Builders_8cpp_source.html#l00017">getMemRefSizes()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01584">getMultiLevelStrides()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00277">getOrCreateUnrolledVectorSlice()</a>, <a class="el" href="Serializer_8cpp_source.html#l00091">getPhiIncomingBlock()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00093">mlir::quant::QuantizedType::getQuantizedElementType()</a>, <a class="el" href="Attributes_8cpp_source.html#l01105">mlir::DenseIntOrFPElementsAttr::getRawComplex()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00277">mlir::spirv::CompositeType::getSizeInBytes()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00154">mlir::spirv::ArrayType::getSizeInBytes()</a>, <a class="el" href="AffineOps_8h_source.html#l00120">mlir::AffineDmaStartOp::getSrcMemorySpace()</a>, <a class="el" href="AffineOps_8h_source.html#l00099">mlir::AffineDmaStartOp::getSrcMemRefType()</a>, <a class="el" href="AffineOps_8h_source.html#l00170">mlir::AffineDmaStartOp::getTagMemRefRank()</a>, <a class="el" href="AffineOps_8h_source.html#l00300">mlir::AffineDmaWaitOp::getTagMemRefRank()</a>, <a class="el" href="AffineOps_8h_source.html#l00165">mlir::AffineDmaStartOp::getTagMemRefType()</a>, <a class="el" href="AffineOps_8h_source.html#l00283">mlir::AffineDmaWaitOp::getTagMemRefType()</a>, <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>, <a class="el" href="Attributes_8cpp_source.html#l00451">mlir::ElementsAttr::getType()</a>, <a class="el" href="Attributes_8cpp_source.html#l01268">mlir::SparseElementsAttr::getValue()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00270">mlir::Builder::getZeroAttr()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00491">inferExtractOpResultType()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01322">inferStridedSliceOpResultType()</a>, <a class="el" href="MemoryPromotion_8cpp_source.html#l00134">insertCopies()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00068">insertOne()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00084">mlir::quant::QuantizedType::isCompatibleExpressedType()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00600">isIdentitySuffix()</a>, <a class="el" href="Tiling_8cpp_source.html#l00225">makeTiledViews()</a>, <a class="el" href="GPUOpsLowering_8h_source.html#l00028">mlir::GPUFuncOpLowering&lt; AllocaAddrSpace &gt;::matchAndRewrite()</a>, <a class="el" href="OpToFuncCallLowering_8h_source.html#l00041">mlir::OpToFuncCallLowering&lt; SourceOp &gt;::matchAndRewrite()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00481">mlir::MemRefDescriptor::MemRefDescriptor()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00072">minusOneIntegerAttribute()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00089">mlir::OperandElementTypeIterator::OperandElementTypeIterator()</a>, <a class="el" href="Attributes_8cpp_source.html#l00664">mlir::DenseElementsAttr::IntElementIterator::operator*()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00115">optionallyTruncateOrExtend()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00560">parseCallOp()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00851">mlir::detail::Parser::parseElementsLiteralType()</a>, <a class="el" href="Ops_8cpp_source.html#l00552">parseGenericAtomicRMWOp()</a>, <a class="el" href="NVVMDialect_8cpp_source.html#l00047">parseNVVMShflSyncBflyOp()</a>, <a class="el" href="Ops_8cpp_source.html#l02475">parseSubViewOp()</a>, <a class="el" href="Ops_8cpp_source.html#l01682">parseTensorFromElementsOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01866">print()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01441">printDenseElementsAttrImpl()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00487">printLandingpadOp()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l03383">mlir::LLVMTypeConverter::promoteOneMemRefDescriptor()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00046">mlir::replaceAllMemRefUsesWith()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00110">reshapeLoad()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00098">mlir::ResultElementTypeIterator::ResultElementTypeIterator()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00218">mlir::LLVM::LLVMType::setStructTyBody()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00592">mlir::MemRefDescriptor::size()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02348">mlir::vector::splitFullAndPartialTransfer()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00452">mlir::ComplexStructBuilder::undef()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00489">mlir::MemRefDescriptor::undef()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00743">mlir::UnrankedMemRefDescriptor::undef()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00367">unrollSingleResultStructuredOp()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00904">vectorizeConstant()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l01384">mlir::LLVM::detail::vectorOneToOneRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02049">verify()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00679">verifyAtomicUpdateOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00307">verifyCastOp()</a>, <a class="el" href="Attributes_8cpp_source.html#l00262">mlir::FloatAttr::verifyConstructionInvariants()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00996">mlir::spirv::MatrixType::verifyConstructionInvariants()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03030">verifyCopyMemory()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00457">verifyLoadStorePtrAndValTypes()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02831">verifyPointerAndCoopMatrixType()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01495">verifyTransferOp()</a>, <a class="el" href="BufferPlacement_8cpp_source.html#l00070">walkReturnOperations()</a>, and <a class="el" href="StandardToLLVM_8cpp_source.html#l01019">wrapExternalFunction()</a>.</p>

</div>
</div>
<a id="a20187f3bc53c94040a83d41de0119a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20187f3bc53c94040a83d41de0119a59">&#9670;&nbsp;</a></span>classof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::Type::classof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00133">133</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="a975aa15f5744af5a899e491135ab1384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975aa15f5744af5a899e491135ab1384">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Type::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l02351">2351</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00347">print()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_8cpp_source.html#l00337">mlirAttributeDump()</a>, <a class="el" href="IR_8cpp_source.html#l00236">mlirOperationDump()</a>, and <a class="el" href="IR_8cpp_source.html#l00327">mlirTypeDump()</a>.</p>

</div>
</div>
<a id="a6b8d33d03b9736dfcc3cc0e9351b1826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8d33d03b9736dfcc3cc0e9351b1826">&#9670;&nbsp;</a></span>dyn_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">U mlir::Type::dyn_cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00322">322</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l01118">appendMangledType()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00100">mlir::barePtrFuncArgTypeConverter()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01240">buildLLVMFunctionType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00867">buildLogicalBinaryOp()</a>, <a class="el" href="Ops_8cpp_source.html#l02850">mlir::canFoldIntoConsumerOp()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00286">canRegisterAlias()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00742">mlir::spirv::SPIRVType::classof()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00585">mlir::spirv::ScalarType::classof()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00166">mlir::spirv::CompositeType::classof()</a>, <a class="el" href="UniformSupport_8cpp_source.html#l00035">mlir::quant::ExpressedToQuantizedConverter::convert()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00343">convertMemrefType()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00234">convertScalarType()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00305">convertTensorType()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00095">createFPConstant()</a>, <a class="el" href="LayoutUtils_8cpp_source.html#l00020">mlir::VulkanLayoutUtils::decorateType()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00783">forwardPassthroughAttributes()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00544">generateTransferOpSlices()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00053">getBitWidth()</a>, <a class="el" href="Attributes_8cpp_source.html#l00947">mlir::DenseElementsAttr::getBoolValues()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00352">mlir::detail::getDenseElementBitWidth()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00883">getElementPtrType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00558">getElementType()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00021">mlir::getElementTypeOrSelf()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00228">getEnclosingforOps()</a>, <a class="el" href="Ops_8cpp_source.html#l00789">getI1SameShape()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00699">getInsertExtractValueElementType()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00209">getLoadStoreElementType()</a>, <a class="el" href="Serializer_8cpp_source.html#l00091">getPhiIncomingBlock()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00093">mlir::quant::QuantizedType::getQuantizedElementType()</a>, <a class="el" href="Traits_8cpp_source.html#l00091">getShape()</a>, <a class="el" href="Operation_8cpp_source.html#l00714">getTensorOrVectorElementType()</a>, <a class="el" href="Ops_8cpp_source.html#l02984">getTensorTypeFromMemRefType()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00265">getTransferOpAdapter()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00160">getTypeNumBytes()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00796">getUnaryOpResultType()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l01354">handleMultidimensionalVectors()</a>, <a class="el" href="MemoryPromotion_8cpp_source.html#l00134">insertCopies()</a>, <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l00221">isAllocationSupported()</a>, <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l00032">isBoolScalarOrVector()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00052">isFnEntryBlock()</a>, <a class="el" href="LayoutUtils_8cpp_source.html#l00152">mlir::VulkanLayoutUtils::isLegalType()</a>, <a class="el" href="NormalizeMemRefs_8cpp_source.html#l00090">isMemRefNormalizable()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00043">mlir::isOpaqueTypeWithName()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00035">isSignedIntegerOrVector()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00044">isUnsignedIntegerOrVector()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l01017">mlir::spirv::MatrixType::isValidColumnType()</a>, <a class="el" href="Attributes_8cpp_source.html#l00870">isValidIntOrFloat()</a>, <a class="el" href="QuantOps_8cpp_source.html#l00045">isValidQuantizationSpec()</a>, <a class="el" href="GPUOpsLowering_8h_source.html#l00028">mlir::GPUFuncOpLowering&lt; AllocaAddrSpace &gt;::matchAndRewrite()</a>, <a class="el" href="BufferPlacement_8h_source.html#l00236">mlir::detail::BufferAssignmentCallOpConverter&lt; allowMemrefFunctionResults &gt;::matchAndRewrite()</a>, <a class="el" href="DialectConversion_8h_source.html#l00218">mlir::TypeConverter::materializeTargetConversion()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00072">minusOneIntegerAttribute()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00154">optionallyBroadcast()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00136">parseAllocaOp()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00198">parseAndVerifyMatrixType()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00154">parseAndVerifyType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01045">parseAtomicCompareExchangeWeakOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00636">parseAtomicUpdateOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00560">parseCallOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00062">parseCmpOp()</a>, <a class="el" href="OpImplementation_8h_source.html#l00677">mlir::OpAsmParser::parseColonType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01258">parseCompositeConstructOp()</a>, <a class="el" href="Shape_8cpp_source.html#l00363">parseConstShapeOp()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00344">mlir::detail::Parser::parseDecOrHexAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00405">parseElementAttrHexValues()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00664">parseExtractElementOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00524">parseExtractOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00782">parseInsertElementOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00352">parseInvokeOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01191">parseOuterProductOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01171">parseShuffleVectorOp()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">mlir::detail::Parser::parseToken()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00314">mlir::DialectAsmParser::parseType()</a>, <a class="el" href="OpImplementation_8h_source.html#l00638">mlir::OpAsmParser::parseType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02698">parseVariableOp()</a>, <a class="el" href="Ops_8cpp_source.html#l02095">print()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeParser_8cpp_source.html#l00345">printUniformQuantizedPerAxisType()</a>, <a class="el" href="QuantizeUtils_8cpp_source.html#l00127">mlir::quant::quantizeAttr()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00429">mlir::StructBuilder::StructBuilder()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00059">mlir::structFuncArgTypeConverter()</a>, <a class="el" href="TypeRange_8cpp_source.html#l00025">mlir::TypeRange::TypeRange()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00044">unwrap()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l01384">mlir::LLVM::detail::vectorOneToOneRewrite()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00984">verify()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00307">verifyCastOp()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00073">mlir::verifyCompatibleShape()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00031">mlir::quant::QuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="Attributes_8cpp_source.html#l00352">mlir::IntegerAttr::verifyConstructionInvariants()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l00226">verifyOutputShape()</a>.</p>

</div>
</div>
<a id="a33ca8bbee5e3e8a02e0df18897981edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ca8bbee5e3e8a02e0df18897981edf">&#9670;&nbsp;</a></span>dyn_cast_or_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">U mlir::Type::dyn_cast_or_null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00325">325</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00039">diag()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00486">getVectorElementwiseOpUnrollState()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00600">isIdentitySuffix()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00367">unrollSingleResultStructuredOp()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l02034">verify()</a>.</p>

</div>
</div>
<a id="a225471c06d85dd43b0848a90d68adb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225471c06d85dd43b0848a90d68adb18">&#9670;&nbsp;</a></span>getAbstractType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlir_1_1AbstractType.html">AbstractType</a>&amp; mlir::Type::getAbstractType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the abstract type descriptor for this type. </p>

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00203">203</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="a1035844c344d17a9e6081c6a0e101b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1035844c344d17a9e6081c6a0e101b80">&#9670;&nbsp;</a></span>getAsOpaquePointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void* mlir::Type::getAsOpaquePointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for supporting PointerLikeTypeTraits. </p>

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00195">195</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Types_8h_source.html#l00354">llvm::PointerLikeTypeTraits&lt; mlir::Type &gt;::getAsVoidPointer()</a>, <a class="el" href="LLVMTypes_8h_source.html#l00576">llvm::PointerLikeTypeTraits&lt; mlir::LLVM::LLVMType &gt;::getAsVoidPointer()</a>, <a class="el" href="CoreAPIs_8cpp_source.html#l00085">mlirParseType()</a>, and <a class="el" href="Attributes_8cpp_source.html#l00035">mlir::AttributeStorage::setType()</a>.</p>

</div>
</div>
<a id="a3951cad794a5bc5ad086158c20f8e50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3951cad794a5bc5ad086158c20f8e50e">&#9670;&nbsp;</a></span>getContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> * Type::getContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the LLVMContext in which this type was uniqued. </p>

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00028">28</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMTypes_8h_source.html#l00229">mlir::LLVM::LLVMType::createStructTy()</a>, <a class="el" href="FakeQuantSupport_8cpp_source.html#l00108">mlir::quant::fakeQuantAttrsToType()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00097">mlir::ComplexType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00124">mlir::spirv::ArrayType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00203">mlir::quant::AnyQuantizedType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00492">mlir::spirv::PointerType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00550">mlir::spirv::RuntimeArrayType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00238">mlir::quant::UniformQuantizedType::get()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00230">mlir::LLVM::LLVMArrayType::get()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00243">mlir::LLVM::LLVMFunctionType::get()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00271">mlir::VectorType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00293">mlir::quant::UniformQuantizedPerAxisType::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l00220">mlir::FloatAttr::get()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00281">mlir::LLVM::LLVMPointerType::get()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00325">mlir::RankedTensorType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00322">mlir::spirv::CooperativeMatrixNVType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00986">mlir::spirv::MatrixType::get()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00355">mlir::UnrankedTensorType::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l00306">mlir::IntegerAttr::get()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00346">mlir::LLVM::LLVMFixedVectorType::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l00431">mlir::StringAttr::get()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00358">mlir::LLVM::LLVMScalableVectorType::get()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00467">mlir::UnrankedMemRefType::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l00441">mlir::TypeAttr::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l01045">mlir::DenseStringElementsAttr::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l01216">mlir::OpaqueElementsAttr::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l01247">mlir::SparseElementsAttr::get()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00394">mlir::MemRefType::getChecked()</a>, <a class="el" href="Attributes_8cpp_source.html#l00047">mlir::Attribute::getContext()</a>, <a class="el" href="Value_8h_source.html#l00111">mlir::Value::getContext()</a>, <a class="el" href="Ops_8cpp_source.html#l00789">getI1SameShape()</a>, <a class="el" href="Serializer_8cpp_source.html#l00091">getPhiIncomingBlock()</a>, <a class="el" href="Attributes_8cpp_source.html#l01092">mlir::DenseIntOrFPElementsAttr::getRaw()</a>, <a class="el" href="LLVMTypes_8h_source.html#l00196">mlir::LLVM::LLVMType::getStructTy()</a>, <a class="el" href="Ops_8cpp_source.html#l02984">getTensorTypeFromMemRefType()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00589">parseSymbol()</a>, <a class="el" href="Value_8cpp_source.html#l00047">mlir::Value::setType()</a>, and <a class="el" href="StandardToLLVM_8cpp_source.html#l00044">unwrap()</a>.</p>

</div>
</div>
<a id="a21810b671ec68509499ee2d4f10a8a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21810b671ec68509499ee2d4f10a8a6b">&#9670;&nbsp;</a></span>getDialect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Dialect.html">Dialect</a> Type::getDialect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dialect this type is registered to. </p>

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00024">24</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="QuantTypes_8cpp_source.html#l00027">mlir::quant::QuantizedType::classof()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00030">mlir::LLVM::LLVMType::classof()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00034">mlir::LLVM::LLVMType::getDialect()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00312">mlir::TensorType::isValidElementType()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00154">parseAndVerifyType()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01441">printDenseElementsAttrImpl()</a>, and <a class="el" href="SPIRVOps_8cpp_source.html#l01467">verify()</a>.</p>

</div>
</div>
<a id="a58b903c935dfc504b4f4e3f77939b113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b903c935dfc504b4f4e3f77939b113">&#9670;&nbsp;</a></span>getFromOpaquePointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Type.html">Type</a> mlir::Type::getFromOpaquePointer </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00198">198</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00191">mlir::StandardAttributes::Type</a>.</p>

<p class="reference">Referenced by <a class="el" href="Diagnostics_8cpp_source.html#l00051">mlir::DiagnosticArgument::getAsType()</a>, <a class="el" href="Types_8h_source.html#l00357">llvm::PointerLikeTypeTraits&lt; mlir::Type &gt;::getFromVoidPointer()</a>, <a class="el" href="Attributes_8cpp_source.html#l00032">mlir::AttributeStorage::getType()</a>, <a class="el" href="CoreAPIs_8cpp_source.html#l00036">makeFunctionType()</a>, <a class="el" href="CoreAPIs_8cpp_source.html#l00056">makeIntegerAttr()</a>, and <a class="el" href="CoreAPIs_8cpp_source.html#l00025">makeMemRefType()</a>.</p>

</div>
</div>
<a id="ae211db2caefd9718134acd88becc670c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae211db2caefd9718134acd88becc670c">&#9670;&nbsp;</a></span>getIntOrFloatBitWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Type::getIntOrFloatBitWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the bit width of an integer or a float type, assert failure on other types. </p>

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00171">171</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardTypes_8h_source.html#l00240">mlir::ShapedType::kDynamicSize</a>, and <a class="el" href="StandardTypes_8h_source.html#l00241">mlir::ShapedType::kDynamicStrideOrOffset</a>.</p>

<p class="reference">Referenced by <a class="el" href="Promotion_8cpp_source.html#l00070">allocBuffer()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00304">buildAttributeAPInt()</a>, <a class="el" href="LayoutUtils_8cpp_source.html#l00020">mlir::VulkanLayoutUtils::decorateType()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00053">getBitWidth()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00352">mlir::detail::getDenseElementBitWidth()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00188">mlir::ShapedType::getElementTypeBitWidth()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00167">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00160">getTypeNumBytes()</a>, and <a class="el" href="SPIRVOps_8cpp_source.html#l00307">verifyCastOp()</a>.</p>

</div>
</div>
<a id="a770133e69450b7252813d64642b3d6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770133e69450b7252813d64642b3d6c5">&#9670;&nbsp;</a></span>getKind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Type::getKind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the classification for this type. </p>

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00022">22</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVTypes_8cpp_source.html#l00742">mlir::spirv::SPIRVType::classof()</a>, <a class="el" href="LLVMTypeSyntax_8cpp_source.html#l00025">getTypeKeyword()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00270">mlir::Builder::getZeroAttr()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01441">printDenseElementsAttrImpl()</a>, and <a class="el" href="Shape_8cpp_source.html#l00051">verifyShapeOrExtentTensorOp()</a>.</p>

</div>
</div>
<a id="accf7dade447f73f5b04c46fcf616b68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf7dade447f73f5b04c46fcf616b68c">&#9670;&nbsp;</a></span>getTypeID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a> mlir::Type::getTypeID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a unique identifier for the concrete type. </p>
<p>This is used to support dynamic type casting. </p>

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00137">137</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="AffineExpr_8h_source.html#l00210">mlir::hash_value()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00347">print()</a>.</p>

</div>
</div>
<a id="adcd295cf88ab7faa33601d3bbee5c4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd295cf88ab7faa33601d3bbee5c4b8">&#9670;&nbsp;</a></span>isa() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::Type::isa </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00312">312</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="QuantTypes_8cpp_source.html#l00146">mlir::quant::QuantizedType::castFromExpressedType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00102">mlir::quant::QuantizedType::castFromStorageType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00171">mlir::quant::QuantizedType::castToExpressedType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00122">mlir::quant::QuantizedType::castToStorageType()</a>, <a class="el" href="Ops_8cpp_source.html#l01209">mlir::ConstantFloatOp::classof()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00742">mlir::spirv::SPIRVType::classof()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00166">mlir::spirv::CompositeType::classof()</a>, <a class="el" href="StandardTypes_8h_source.html#l00626">mlir::ShapedType::classof()</a>, <a class="el" href="StandardTypes_8h_source.html#l00631">mlir::TensorType::classof()</a>, <a class="el" href="StandardTypes_8h_source.html#l00622">mlir::BaseMemRefType::classof()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00330">mlir::LLVM::LLVMVectorType::classof()</a>, <a class="el" href="Attributes_8cpp_source.html#l01188">mlir::DenseFPElementsAttr::classof()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00084">convertRangeType()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00082">createConstantAllBitsSet()</a>, <a class="el" href="LayoutUtils_8cpp_source.html#l00020">mlir::VulkanLayoutUtils::decorateType()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00212">mlir::edsc::op::eq()</a>, <a class="el" href="UniformSupport_8cpp_source.html#l00021">mlir::quant::ExpressedToQuantizedConverter::forInputType()</a>, <a class="el" href="Attributes_8cpp_source.html#l00802">mlir::DenseElementsAttr::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l01247">mlir::SparseElementsAttr::get()</a>, <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l00237">getAtomicOpScope()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00053">getBitWidth()</a>, <a class="el" href="Traits_8cpp_source.html#l00106">mlir::OpTrait::util::getBroadcastedType()</a>, <a class="el" href="Attributes_8cpp_source.html#l00995">mlir::DenseElementsAttr::getComplexFloatValues()</a>, <a class="el" href="Attributes_8cpp_source.html#l00971">mlir::DenseElementsAttr::getComplexIntValues()</a>, <a class="el" href="Ops_8cpp_source.html#l00789">getI1SameShape()</a>, <a class="el" href="Serializer_8cpp_source.html#l00091">getPhiIncomingBlock()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00093">mlir::quant::QuantizedType::getQuantizedElementType()</a>, <a class="el" href="Attributes_8cpp_source.html#l01092">mlir::DenseIntOrFPElementsAttr::getRaw()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00265">getTransferOpAdapter()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00160">getTypeNumBytes()</a>, <a class="el" href="LinalgTraits_8h_source.html#l00342">mlir::OpTrait::linalg::StructuredOpTraits&lt; ConcreteType &gt;::hasBufferSemantics()</a>, <a class="el" href="Traits_8cpp_source.html#l00163">hasTensorOrVectorType()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00181">mlir::detail::IntegerAttributeStorage::IntegerAttributeStorage()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00163">isAccessIndexInvariant()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00084">mlir::quant::QuantizedType::isCompatibleExpressedType()</a>, <a class="el" href="BufferPlacement_8cpp_source.html#l00717">mlir::BufferAssignmentTypeConverter::isConvertedMemref()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00052">isFnEntryBlock()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00600">isIdentitySuffix()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00072">isMemRefDereferencingOp()</a>, <a class="el" href="NormalizeMemRefs_8cpp_source.html#l00090">isMemRefNormalizable()</a>, <a class="el" href="UniformSupport_8cpp_source.html#l00016">isQuantizablePrimitiveType()</a>, <a class="el" href="StandardTypes_8h_source.html#l00337">mlir::VectorType::isValidElementType()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00312">mlir::TensorType::isValidElementType()</a>, <a class="el" href="StandardTypes_8h_source.html#l00430">mlir::BaseMemRefType::isValidElementType()</a>, <a class="el" href="Attributes_8cpp_source.html#l00870">isValidIntOrFloat()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00113">mlir::LLVM::LLVMType::isValidPointerElementType()</a>, <a class="el" href="QuantOps_8cpp_source.html#l00045">isValidQuantizationSpec()</a>, <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00112">mlir::edsc::ops::linalg_generic_pointwise()</a>, <a class="el" href="Attributes_8cpp_source.html#l01139">mappingHelper()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01579">mlir::ContractionOpToMatmulOpLowering::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01890">mlir::ContractionOpLowering::matchAndRewrite()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00218">mlir::edsc::op::ne()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01124">mlir::AffineDmaWaitOp::parse()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01447">parseConstantOp()</a>, <a class="el" href="Shape_8cpp_source.html#l00363">parseConstShapeOp()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00344">mlir::detail::Parser::parseDecOrHexAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00405">parseElementAttrHexValues()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00851">mlir::detail::Parser::parseElementsLiteralType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00270">mlir::detail::Parser::parseFloatAttr()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01907">parseGlobalVariableOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01734">print()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01441">printDenseElementsAttrImpl()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00611">printGPUFuncOp()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00242">mlir::edsc::op::sge()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00236">mlir::edsc::op::sgt()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00230">mlir::edsc::op::sle()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00224">mlir::edsc::op::slt()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l00059">mlir::structFuncArgTypeConverter()</a>, <a class="el" href="EDSC_2Builders_8h_source.html#l00140">mlir::edsc::StructuredIndexed::StructuredIndexed()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00266">mlir::edsc::op::uge()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00260">mlir::edsc::op::ugt()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00254">mlir::edsc::op::ule()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00248">mlir::edsc::op::ult()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00904">vectorizeConstant()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00942">vectorizeOperand()</a>, <a class="el" href="StandardToLLVM_8cpp_source.html#l01384">mlir::LLVM::detail::vectorOneToOneRewrite()</a>, <a class="el" href="Shape_8cpp_source.html#l00878">verify()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00220">mlir::quant::AnyQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00259">mlir::quant::UniformQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00314">mlir::quant::UniformQuantizedPerAxisType::verifyConstructionInvariants()</a>, <a class="el" href="Attributes_8cpp_source.html#l00251">verifyFloatTypeInvariants()</a>, <a class="el" href="Attributes_8cpp_source.html#l00341">verifyIntegerTypeInvariants()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00226">verifyOutputShape()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02831">verifyPointerAndCoopMatrixType()</a>, <a class="el" href="Operation_8cpp_source.html#l00963">mlir::OpTrait::impl::verifyResultsAreFloatLike()</a>, and <a class="el" href="Shape_8cpp_source.html#l00051">verifyShapeOrExtentTensorOp()</a>.</p>

</div>
</div>
<a id="a297bb52f523ab1064dc72f39a451cb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297bb52f523ab1064dc72f39a451cb18">&#9670;&nbsp;</a></span>isa() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename Second , typename... Rest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::Type::isa </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00318">318</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="a219cbb23b0bbf98773dc73d5ba5b13ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219cbb23b0bbf98773dc73d5ba5b13ed">&#9670;&nbsp;</a></span>isBF16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isBF16 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00025">25</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardTypes_8h_source.html#l00044">mlir::StandardTypes::BF16</a>.</p>

<p class="reference">Referenced by <a class="el" href="QuantTypes_8h_source.html#l00113">mlir::quant::QuantizedType::isSigned()</a>, and <a class="el" href="SPIRVDialect_8cpp_source.html#l00154">parseAndVerifyType()</a>.</p>

</div>
</div>
<a id="addf9ffe711f6a40ec2558f094e0fe3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf9ffe711f6a40ec2558f094e0fe3d0">&#9670;&nbsp;</a></span>isF16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isF16 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00026">26</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardTypes_8h_source.html#l00045">mlir::StandardTypes::F16</a>.</p>

<p class="reference">Referenced by <a class="el" href="QuantTypes_8h_source.html#l00113">mlir::quant::QuantizedType::isSigned()</a>.</p>

</div>
</div>
<a id="a2ee1dfc71fe79d72fb86df381afa28f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee1dfc71fe79d72fb86df381afa28f8">&#9670;&nbsp;</a></span>isF32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isF32 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00027">27</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardTypes_8h_source.html#l00046">mlir::StandardTypes::F32</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00265">getTransferOpAdapter()</a>, <a class="el" href="QuantTypes_8h_source.html#l00113">mlir::quant::QuantizedType::isSigned()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l00065">verify()</a>.</p>

</div>
</div>
<a id="a15aebbbf2b0d7cefda956b63af8ee0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15aebbbf2b0d7cefda956b63af8ee0d4">&#9670;&nbsp;</a></span>isF64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isF64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00028">28</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardTypes_8h_source.html#l00047">mlir::StandardTypes::F64</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeDetail_8h_source.html#l00134">mlir::detail::FloatAttributeStorage::getKey()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00265">getTransferOpAdapter()</a>, <a class="el" href="QuantTypes_8h_source.html#l00113">mlir::quant::QuantizedType::isSigned()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l00065">verify()</a>.</p>

</div>
</div>
<a id="ae04cd125cd035f98f0bbbdec875f4f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04cd125cd035f98f0bbbdec875f4f90">&#9670;&nbsp;</a></span>isIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00030">30</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeParser_8cpp_source.html#l00304">buildAttributeAPInt()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00125">ceilDivPositive()</a>, <a class="el" href="Ops_8cpp_source.html#l01235">mlir::ConstantIndexOp::classof()</a>, <a class="el" href="Attributes_8cpp_source.html#l00312">mlir::IntegerAttr::get()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00352">mlir::detail::getDenseElementBitWidth()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00167">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00181">mlir::detail::IntegerAttributeStorage::IntegerAttributeStorage()</a>, <a class="el" href="QuantTypes_8h_source.html#l00113">mlir::quant::QuantizedType::isSigned()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00132">mlir::isValidDim()</a>, <a class="el" href="Attributes_8cpp_source.html#l00870">isValidIntOrFloat()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00222">mlir::isValidSymbol()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00153">parseGenericOp()</a>, <a class="el" href="Ops_8cpp_source.html#l01485">mlir::DmaStartOp::verify()</a>, <a class="el" href="Ops_8cpp_source.html#l01610">mlir::DmaWaitOp::verify()</a>, and <a class="el" href="Ops_8cpp_source.html#l01706">verify()</a>.</p>

</div>
</div>
<a id="ad3ffc49524ecdd46d15a8449e23267b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ffc49524ecdd46d15a8449e23267b1">&#9670;&nbsp;</a></span>isInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isInteger </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an integer type with the specified width. </p>

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00033">33</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeDetail_8h_source.html#l00501">mlir::detail::DenseIntOrFPElementsAttributeStorage::construct()</a>, <a class="el" href="Attributes_8cpp_source.html#l00773">mlir::DenseElementsAttr::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l01247">mlir::SparseElementsAttr::get()</a>, <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l00237">getAtomicOpScope()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00419">mlir::detail::DenseIntOrFPElementsAttributeStorage::getKey()</a>, <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l00032">isBoolScalarOrVector()</a>, <a class="el" href="QuantTypes_8h_source.html#l00113">mlir::quant::QuantizedType::isSigned()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00167">mlir::edsc::op::negate()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00396">mlir::detail::DenseIntOrFPElementsAttributeStorage::operator==()</a>, <a class="el" href="Dialect_2Affine_2EDSC_2Builders_8cpp_source.html#l00178">mlir::edsc::op::operator||()</a>, and <a class="el" href="AttributeParser_8cpp_source.html#l00405">parseElementAttrHexValues()</a>.</p>

</div>
</div>
<a id="af2f2df233ac9b650c85992d365b08419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f2df233ac9b650c85992d365b08419">&#9670;&nbsp;</a></span>isIntOrFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isIntOrFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an integer (of any signedness) or a float type. </p>

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00089">89</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Attributes_8cpp_source.html#l00785">mlir::DenseElementsAttr::get()</a>, <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00053">getBitWidth()</a>, <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l00221">isAllocationSupported()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00052">isFnEntryBlock()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01579">mlir::ContractionOpToMatmulOpLowering::matchAndRewrite()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00405">parseElementAttrHexValues()</a>, and <a class="el" href="StandardTypes_8cpp_source.html#l00107">mlir::ComplexType::verifyConstructionInvariants()</a>.</p>

</div>
</div>
<a id="a6a4fa1595a42d6b3ae872fc303249b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4fa1595a42d6b3ae872fc303249b5e">&#9670;&nbsp;</a></span>isIntOrIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isIntOrIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an integer (of any signedness) or an index type. </p>

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00087">87</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Attributes_8cpp_source.html#l01207">mlir::DenseIntElementsAttr::classof()</a>, <a class="el" href="Attributes_8cpp_source.html#l00794">mlir::DenseElementsAttr::get()</a>, and <a class="el" href="AttributeParser_8cpp_source.html#l00405">parseElementAttrHexValues()</a>.</p>

</div>
</div>
<a id="ad4258b26dd83dba9fc87fc7220639bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4258b26dd83dba9fc87fc7220639bf4">&#9670;&nbsp;</a></span>isIntOrIndexOrFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isIntOrIndexOrFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an integer (of any signedness), index, or float type. </p>

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00091">91</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Attributes_8cpp_source.html#l00721">mlir::DenseElementsAttr::get()</a>, <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l00237">getAtomicOpScope()</a>, <a class="el" href="StandardTypes_8h_source.html#l00430">mlir::BaseMemRefType::isValidElementType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00405">parseElementAttrHexValues()</a>, and <a class="el" href="SPIRVDialect_8cpp_source.html#l01058">verifyRegionAttribute()</a>.</p>

</div>
</div>
<a id="acad42bce36d1e840c0062f47b6217697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad42bce36d1e840c0062f47b6217697">&#9670;&nbsp;</a></span>isSignedInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isSignedInteger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is a signed integer type (with the specified width). </p>

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00051">51</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeParser_8cpp_source.html#l00304">buildAttributeAPInt()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00167">mlir::Builder::getIntegerAttr()</a>, and <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00035">isSignedIntegerOrVector()</a>.</p>

</div>
</div>
<a id="aa65d5882f70083eb6c559cb89e773fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa65d5882f70083eb6c559cb89e773fcd">&#9670;&nbsp;</a></span>isSignedInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isSignedInteger </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00057">57</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

</div>
</div>
<a id="ae898f9e92614ee853dae9550f0c0cb42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae898f9e92614ee853dae9550f0c0cb42">&#9670;&nbsp;</a></span>isSignlessInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isSignlessInteger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is a signless integer type (with the specified width). </p>

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00039">39</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Ops_8cpp_source.html#l01227">mlir::ConstantIntOp::build()</a>, <a class="el" href="Ops_8cpp_source.html#l01214">mlir::ConstantIntOp::classof()</a>, <a class="el" href="Attributes_8cpp_source.html#l00306">mlir::IntegerAttr::get()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00265">getTransferOpAdapter()</a>, and <a class="el" href="Ops_8cpp_source.html#l01706">verify()</a>.</p>

</div>
</div>
<a id="a2c7f725d5ba2ed45e6cf96e55340df92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7f725d5ba2ed45e6cf96e55340df92">&#9670;&nbsp;</a></span>isSignlessInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isSignlessInteger </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00045">45</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

</div>
</div>
<a id="a54918532e69215a77134665764abfe03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54918532e69215a77134665764abfe03">&#9670;&nbsp;</a></span>isSignlessIntOrFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isSignlessIntOrFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true of this is a signless integer or a float type. </p>

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00083">83</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00032">mlir::linalg::RegionMatcher::matchAsScalarBinaryOp()</a>, and <a class="el" href="LLVMDialect_8cpp_source.html#l00984">verify()</a>.</p>

</div>
</div>
<a id="ac05ab14ebc486cbf6f9dcb927798b50c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05ab14ebc486cbf6f9dcb927798b50c">&#9670;&nbsp;</a></span>isSignlessIntOrIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isSignlessIntOrIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is a signless integer or index type. </p>

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00075">75</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Operation_8cpp_source.html#l00972">mlir::OpTrait::impl::verifyResultsAreSignlessIntegerLike()</a>.</p>

</div>
</div>
<a id="a53fbea201d963746a7087848dd458e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53fbea201d963746a7087848dd458e58">&#9670;&nbsp;</a></span>isSignlessIntOrIndexOrFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isSignlessIntOrIndexOrFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is a signless integer, index, or float type. </p>

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00079">79</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l01118">appendMangledType()</a>.</p>

</div>
</div>
<a id="a2f201aa3fa231a5ffc7d69398d037943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f201aa3fa231a5ffc7d69398d037943">&#9670;&nbsp;</a></span>isUnsignedInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isUnsignedInteger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an unsigned integer type (with the specified width). </p>

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00063">63</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertSPIRVToLLVM_8cpp_source.html#l00044">isUnsignedIntegerOrVector()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00344">mlir::detail::Parser::parseDecOrHexAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00405">parseElementAttrHexValues()</a>, and <a class="el" href="AsmPrinter_8cpp_source.html#l01441">printDenseElementsAttrImpl()</a>.</p>

</div>
</div>
<a id="aac7c507dfd35359a3f18ae5af691cca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7c507dfd35359a3f18ae5af691cca2">&#9670;&nbsp;</a></span>isUnsignedInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isUnsignedInteger </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00069">69</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

</div>
</div>
<a id="afeb8b20e59002a0fedfcb93e314b416f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb8b20e59002a0fedfcb93e314b416f">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::Type::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00121">121</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="ac516f7c8eb957068555b5781d78f23af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac516f7c8eb957068555b5781d78f23af">&#9670;&nbsp;</a></span>operator!()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::Type::operator! </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00123">123</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="ad1be45203a0010965388d41e712dc268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1be45203a0010965388d41e712dc268">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlir_1_1Type.html#ac516f7c8eb957068555b5781d78f23af">mlir::Type::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00120">120</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="a860e9e7612215565aadad622ccf4cbb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860e9e7612215565aadad622ccf4cbb0">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a>&amp; mlir::Type::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac53df1249058e8c2ec0fa70f172f0b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53df1249058e8c2ec0fa70f172f0b59">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::Type::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00119">119</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00206">impl</a>.</p>

</div>
</div>
<a id="a94f326ccb845e5e7f384a8069153f305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f326ccb845e5e7f384a8069153f305">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Type::print </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the current type. </p>

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l02349">2349</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Types_8h_source.html#l00209">mlir::operator&lt;&lt;()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a54ee333db7234f6ada1036072a24b877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ee333db7234f6ada1036072a24b877">&#9670;&nbsp;</a></span>hash_value</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::llvm::hash_code hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00308">308</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a54af6c081e012a32bba9b650480c6c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54af6c081e012a32bba9b650480c6c06">&#9670;&nbsp;</a></span>impl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">ImplType</a>* mlir::Type::impl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00206">206</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMTypes_8cpp_source.html#l00334">mlir::LLVM::LLVMVectorType::getElementType()</a>, <a class="el" href="Types_8h_source.html#l00308">mlir::hash_value()</a>, and <a class="el" href="Types_8h_source.html#l00119">operator==()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/IR/<a class="el" href="Types_8h_source.html">Types.h</a></li>
<li>lib/IR/<a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a></li>
<li>lib/IR/<a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a></li>
<li>lib/IR/<a class="el" href="Types_8cpp_source.html">Types.cpp</a></li>
<li>lib/TableGen/<a class="el" href="Type_8cpp_source.html">Type.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Aug 8 2020 16:27:20 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
