<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::StorageUniquer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">12.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1StorageUniquer.html">StorageUniquer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmlir_1_1StorageUniquer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::StorageUniquer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A utility class to get, or create instances of storage classes.  
 <a href="classmlir_1_1StorageUniquer.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="StorageUniquer_8h_source.html">mlir/Support/StorageUniquer.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer_1_1BaseStorage.html">BaseStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class acts as the base storage that all storage classes must derived from.  <a href="classmlir_1_1StorageUniquer_1_1BaseStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a utility allocator used to allocate memory for instances of derived types.  <a href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1f5e53b96192c7a25b6ab0523483c5b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html#a1f5e53b96192c7a25b6ab0523483c5b3">StorageUniquer</a> ()</td></tr>
<tr class="separator:a1f5e53b96192c7a25b6ab0523483c5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4766e45fc3cd0a11f578e2adaa5f01f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html#ac4766e45fc3cd0a11f578e2adaa5f01f">~StorageUniquer</a> ()</td></tr>
<tr class="separator:ac4766e45fc3cd0a11f578e2adaa5f01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3929c9fc0d5c77c3978f49ba88465f9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html#a3929c9fc0d5c77c3978f49ba88465f9a">disableMultithreading</a> (bool disable=true)</td></tr>
<tr class="memdesc:a3929c9fc0d5c77c3978f49ba88465f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the flag specifying if multi-threading is disabled within the uniquer.  <a href="#a3929c9fc0d5c77c3978f49ba88465f9a">More...</a><br /></td></tr>
<tr class="separator:a3929c9fc0d5c77c3978f49ba88465f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950469215991f3d1a5c273a1db1f0946"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html#a950469215991f3d1a5c273a1db1f0946">registerStorageType</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> id)</td></tr>
<tr class="memdesc:a950469215991f3d1a5c273a1db1f0946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a new storage object with this uniquer using the given unique type id.  <a href="#a950469215991f3d1a5c273a1db1f0946">More...</a><br /></td></tr>
<tr class="separator:a950469215991f3d1a5c273a1db1f0946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb80f86942ca010fc3008deaacae3a8c"><td class="memTemplParams" colspan="2">template&lt;typename Storage , typename Arg , typename... Args&gt; </td></tr>
<tr class="memitem:aeb80f86942ca010fc3008deaacae3a8c"><td class="memTemplItemLeft" align="right" valign="top">Storage *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html#aeb80f86942ca010fc3008deaacae3a8c">get</a> (const <a class="el" href="classmlir_1_1TypeID.html">TypeID</a> &amp;id, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(Storage *)&gt; initFn, unsigned kind, Arg &amp;&amp;arg, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:aeb80f86942ca010fc3008deaacae3a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a uniqued instance of 'Storage'.  <a href="#aeb80f86942ca010fc3008deaacae3a8c">More...</a><br /></td></tr>
<tr class="separator:aeb80f86942ca010fc3008deaacae3a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5719acf4ec237022d5c012cc4200a738"><td class="memTemplParams" colspan="2">template&lt;typename Storage &gt; </td></tr>
<tr class="memitem:a5719acf4ec237022d5c012cc4200a738"><td class="memTemplItemLeft" align="right" valign="top">Storage *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html#a5719acf4ec237022d5c012cc4200a738">get</a> (const <a class="el" href="classmlir_1_1TypeID.html">TypeID</a> &amp;id, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(Storage *)&gt; initFn, unsigned kind)</td></tr>
<tr class="memdesc:a5719acf4ec237022d5c012cc4200a738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a uniqued instance of 'Storage'.  <a href="#a5719acf4ec237022d5c012cc4200a738">More...</a><br /></td></tr>
<tr class="separator:a5719acf4ec237022d5c012cc4200a738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3fbc5d70344d6f488e959cf8f5e561a"><td class="memTemplParams" colspan="2">template&lt;typename Storage , typename... Args&gt; </td></tr>
<tr class="memitem:ab3fbc5d70344d6f488e959cf8f5e561a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html#ab3fbc5d70344d6f488e959cf8f5e561a">mutate</a> (const <a class="el" href="classmlir_1_1TypeID.html">TypeID</a> &amp;id, Storage *storage, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ab3fbc5d70344d6f488e959cf8f5e561a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the mutable component of 'storage' by forwarding the trailing arguments to the 'mutate' function of the derived class.  <a href="#ab3fbc5d70344d6f488e959cf8f5e561a">More...</a><br /></td></tr>
<tr class="separator:ab3fbc5d70344d6f488e959cf8f5e561a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0dce0d83fc4277f6c03834e8b9769a"><td class="memTemplParams" colspan="2">template&lt;typename Storage , typename Arg , typename... Args&gt; </td></tr>
<tr class="memitem:a2e0dce0d83fc4277f6c03834e8b9769a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html#a2e0dce0d83fc4277f6c03834e8b9769a">erase</a> (const <a class="el" href="classmlir_1_1TypeID.html">TypeID</a> &amp;id, unsigned kind, Arg &amp;&amp;arg, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a2e0dce0d83fc4277f6c03834e8b9769a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases a uniqued instance of 'Storage'.  <a href="#a2e0dce0d83fc4277f6c03834e8b9769a">More...</a><br /></td></tr>
<tr class="separator:a2e0dce0d83fc4277f6c03834e8b9769a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A utility class to get, or create instances of storage classes. </p>
<p>These storage classes must respect the following constraints:</p><ul>
<li>Derive from <a class="el" href="classmlir_1_1StorageUniquer_1_1BaseStorage.html" title="This class acts as the base storage that all storage classes must derived from. ">StorageUniquer::BaseStorage</a>.</li>
<li>Provide an unsigned 'kind' value to be used as part of the unique'ing process.</li>
</ul>
<p>For non-parametric storage classes, i.e. those that are solely uniqued by their kind, nothing else is needed. Instances of these classes can be created by calling <code>get</code> without trailing arguments.</p>
<p>Otherwise, the parametric storage classes may be created with <code>get</code>, and must respect the following:</p><ul>
<li>Define a type alias, KeyTy, to a type that uniquely identifies the instance of the storage class within its kind.<ul>
<li>The key type must be constructible from the values passed into the getComplex call after the kind.</li>
<li>If the KeyTy does not have an <a class="el" href="structllvm_1_1DenseMapInfo.html">llvm::DenseMapInfo</a> specialization, the storage class must define a hashing method: 'static unsigned hashKey(const KeyTy &amp;)'</li>
</ul>
</li>
<li>Provide a method, 'bool operator==(const KeyTy &amp;) const', to compare the storage instance against an instance of the key type.</li>
<li>Provide a static construction method: 'DerivedStorage *construct(<a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html" title="This is a utility allocator used to allocate memory for instances of derived types. ">StorageAllocator</a> &amp;, const KeyTy &amp;key)' that builds a unique instance of the derived storage. The arguments to this function are an allocator to store any uniqued data and the key type for this storage.</li>
<li>Provide a cleanup method: 'void cleanup()' that is called when erasing a storage instance. This should cleanup any fields of the storage as necessary and not attempt to free the memory of the storage itself.</li>
</ul>
<p>Storage classes may have an optional mutable component, which must not take part in the unique immutable key. In this case, storage classes may be mutated with <code>mutate</code> and must additionally respect the following:</p><ul>
<li>Provide a mutation method: '<a class="el" href="structmlir_1_1LogicalResult.html" title="Values that can be used to signal success/failure. ">LogicalResult</a> mutate(<a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html" title="This is a utility allocator used to allocate memory for instances of derived types. ">StorageAllocator</a> &amp;, &lt;...&gt;)' that is called when mutating a storage instance. The first argument is an allocator to store any mutable data, and the remaining arguments are forwarded from the call site. The storage can be mutated at any time after creation. Care must be taken to avoid excessive mutation since the allocated storage can keep containing previous states. The return value of the function is used to indicate whether the mutation was successful, e.g., to limit the number of mutations or enable deferred one-time assignment of the mutable component.</li>
</ul>
<p>All storage classes must be registered with the uniquer via <code>registerStorageType</code> using an appropriate unique <code><a class="el" href="classmlir_1_1TypeID.html" title="This class provides an efficient unique identifier for a specific C++ type. ">TypeID</a></code> for the storage class. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00084">84</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1f5e53b96192c7a25b6ab0523483c5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f5e53b96192c7a25b6ab0523483c5b3">&#9670;&nbsp;</a></span>StorageUniquer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StorageUniquer::StorageUniquer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8cpp_source.html#l00224">224</a> of file <a class="el" href="StorageUniquer_8cpp_source.html">StorageUniquer.cpp</a>.</p>

</div>
</div>
<a id="ac4766e45fc3cd0a11f578e2adaa5f01f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4766e45fc3cd0a11f578e2adaa5f01f">&#9670;&nbsp;</a></span>~StorageUniquer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StorageUniquer::~StorageUniquer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8cpp_source.html#l00225">225</a> of file <a class="el" href="StorageUniquer_8cpp_source.html">StorageUniquer.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3929c9fc0d5c77c3978f49ba88465f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3929c9fc0d5c77c3978f49ba88465f9a">&#9670;&nbsp;</a></span>disableMultithreading()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StorageUniquer::disableMultithreading </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>disable</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the flag specifying if multi-threading is disabled within the uniquer. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8cpp_source.html#l00228">228</a> of file <a class="el" href="StorageUniquer_8cpp_source.html">StorageUniquer.cpp</a>.</p>

</div>
</div>
<a id="a2e0dce0d83fc4277f6c03834e8b9769a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e0dce0d83fc4277f6c03834e8b9769a">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename Arg , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::StorageUniquer::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeID.html">TypeID</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erases a uniqued instance of 'Storage'. </p>
<p>This function is used for derived types that have complex storage or uniquing constraints. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00210">210</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

</div>
</div>
<a id="aeb80f86942ca010fc3008deaacae3a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb80f86942ca010fc3008deaacae3a8c">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename Arg , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Storage* mlir::StorageUniquer::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeID.html">TypeID</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(Storage *)&gt;&#160;</td>
          <td class="paramname"><em>initFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a uniqued instance of 'Storage'. </p>
<p>'initFn' is an optional parameter that can be used to initialize a newly inserted storage instance. This function is used for derived types that have complex storage or uniquing constraints. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00153">153</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineExpr_8cpp_source.html#l00763">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00719">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="SDBMExpr_8cpp_source.html#l00639">mlir::SDBMConstantExpr::get()</a>, <a class="el" href="SDBMExpr_8cpp_source.html#l00236">mlir::SDBMSumExpr::get()</a>, <a class="el" href="SDBMExpr_8cpp_source.html#l00531">mlir::SDBMDiffExpr::get()</a>, <a class="el" href="SDBMExpr_8cpp_source.html#l00569">mlir::SDBMStripeExpr::get()</a>, <a class="el" href="SDBMExpr_8cpp_source.html#l00605">mlir::SDBMDimExpr::get()</a>, <a class="el" href="SDBMExpr_8cpp_source.html#l00622">mlir::SDBMSymbolExpr::get()</a>, <a class="el" href="SDBMExpr_8cpp_source.html#l00660">mlir::SDBMNegExpr::get()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00481">mlir::getAffineConstantExpr()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00444">getAffineDimOrSymbol()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00811">mlir::AffineExpr::operator%()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00652">mlir::AffineExpr::operator*()</a>, and <a class="el" href="AffineExpr_8cpp_source.html#l00591">mlir::AffineExpr::operator+()</a>.</p>

</div>
</div>
<a id="a5719acf4ec237022d5c012cc4200a738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5719acf4ec237022d5c012cc4200a738">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Storage* mlir::StorageUniquer::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeID.html">TypeID</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(Storage *)&gt;&#160;</td>
          <td class="paramname"><em>initFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a uniqued instance of 'Storage'. </p>
<p>'initFn' is an optional parameter that can be used to initialize a newly inserted storage instance. This function is used for derived types that use no additional storage or uniquing outside of the kind. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00185">185</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

</div>
</div>
<a id="ab3fbc5d70344d6f488e959cf8f5e561a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3fbc5d70344d6f488e959cf8f5e561a">&#9670;&nbsp;</a></span>mutate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Storage , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::StorageUniquer::mutate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1TypeID.html">TypeID</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Storage *&#160;</td>
          <td class="paramname"><em>storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the mutable component of 'storage' by forwarding the trailing arguments to the 'mutate' function of the derived class. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8h_source.html#l00199">199</a> of file <a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeSupport_8h_source.html#l00138">mlir::detail::TypeUniquer::mutate()</a>, and <a class="el" href="AttributeSupport_8h_source.html#l00152">mlir::detail::AttributeUniquer::mutate()</a>.</p>

</div>
</div>
<a id="a950469215991f3d1a5c273a1db1f0946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950469215991f3d1a5c273a1db1f0946">&#9670;&nbsp;</a></span>registerStorageType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StorageUniquer::registerStorageType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a new storage object with this uniquer using the given unique type id. </p>

<p class="definition">Definition at line <a class="el" href="StorageUniquer_8cpp_source.html#l00234">234</a> of file <a class="el" href="StorageUniquer_8cpp_source.html">StorageUniquer.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SDBMDialect_8cpp_source.html#l00014">mlir::SDBMDialect::SDBMDialect()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Support/<a class="el" href="StorageUniquer_8h_source.html">StorageUniquer.h</a></li>
<li>lib/Support/<a class="el" href="StorageUniquer_8cpp_source.html">StorageUniquer.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Aug 8 2020 16:27:20 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
