<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::LLVM::LLVMStructType Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">12.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a></li><li class="navelem"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVMStructType</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmlir_1_1LLVM_1_1LLVMStructType-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::LLVM::LLVMStructType Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect structure type representing a collection of different-typed elements manipulated together.  
 <a href="classmlir_1_1LLVM_1_1LLVMStructType.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="LLVMTypes_8h_source.html">mlir/Dialect/LLVMIR/LLVMTypes.h</a>&quot;</code></p>
<div class="dynheader">
Inheritance diagram for mlir::LLVM::LLVMStructType:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1LLVM_1_1LLVMStructType__inherit__graph.png" border="0" usemap="#mlir_1_1LLVM_1_1LLVMStructType_inherit__map" alt="Inheritance graph"/></div>
<map name="mlir_1_1LLVM_1_1LLVMStructType_inherit__map" id="mlir_1_1LLVM_1_1LLVMStructType_inherit__map">
<area shape="rect" id="node2" href="classmlir_1_1detail_1_1StorageUserBase.html" title="Utility class for implementing users of storage classes uniqued by a StorageUniquer. " alt="" coords="5,80,204,136"/>
<area shape="rect" id="node3" href="classBaseT.html" title="BaseT" alt="" coords="13,5,73,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mlir::LLVM::LLVMStructType:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1LLVM_1_1LLVMStructType__coll__graph.png" border="0" usemap="#mlir_1_1LLVM_1_1LLVMStructType_coll__map" alt="Collaboration graph"/></div>
<map name="mlir_1_1LLVM_1_1LLVMStructType_coll__map" id="mlir_1_1LLVM_1_1LLVMStructType_coll__map">
<area shape="rect" id="node2" href="classmlir_1_1detail_1_1StorageUserBase.html" title="Utility class for implementing users of storage classes uniqued by a StorageUniquer. " alt="" coords="5,80,204,136"/>
<area shape="rect" id="node3" href="classBaseT.html" title="BaseT" alt="" coords="13,5,73,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6cb80965db7e0a6cdc758cbfaa9f8053"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a6cb80965db7e0a6cdc758cbfaa9f8053">setBody</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1LLVM_1_1LLVMType.html">LLVMType</a> &gt; types, bool <a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a977513e9aaf4dd672ffb9ce793338176">isPacked</a>)</td></tr>
<tr class="memdesc:a6cb80965db7e0a6cdc758cbfaa9f8053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the body of an identified struct.  <a href="#a6cb80965db7e0a6cdc758cbfaa9f8053">More...</a><br /></td></tr>
<tr class="separator:a6cb80965db7e0a6cdc758cbfaa9f8053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977513e9aaf4dd672ffb9ce793338176"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a977513e9aaf4dd672ffb9ce793338176">isPacked</a> ()</td></tr>
<tr class="memdesc:a977513e9aaf4dd672ffb9ce793338176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a struct is packed.  <a href="#a977513e9aaf4dd672ffb9ce793338176">More...</a><br /></td></tr>
<tr class="separator:a977513e9aaf4dd672ffb9ce793338176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea8331c39f952bfe5f870c1d5aad63b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a1ea8331c39f952bfe5f870c1d5aad63b">isIdentified</a> ()</td></tr>
<tr class="memdesc:a1ea8331c39f952bfe5f870c1d5aad63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a struct is identified.  <a href="#a1ea8331c39f952bfe5f870c1d5aad63b">More...</a><br /></td></tr>
<tr class="separator:a1ea8331c39f952bfe5f870c1d5aad63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a0b1510ce9eed7c21b9a83652ce55e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a96a0b1510ce9eed7c21b9a83652ce55e">isOpaque</a> ()</td></tr>
<tr class="memdesc:a96a0b1510ce9eed7c21b9a83652ce55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a struct is opaque.  <a href="#a96a0b1510ce9eed7c21b9a83652ce55e">More...</a><br /></td></tr>
<tr class="separator:a96a0b1510ce9eed7c21b9a83652ce55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b583beb28f839f61169e419d3cd32b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a78b583beb28f839f61169e419d3cd32b">isInitialized</a> ()</td></tr>
<tr class="memdesc:a78b583beb28f839f61169e419d3cd32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a struct is initialized.  <a href="#a78b583beb28f839f61169e419d3cd32b">More...</a><br /></td></tr>
<tr class="separator:a78b583beb28f839f61169e419d3cd32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28307288eaac35d84bab71207c9f9afa"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a28307288eaac35d84bab71207c9f9afa">getName</a> ()</td></tr>
<tr class="memdesc:a28307288eaac35d84bab71207c9f9afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of an identified struct.  <a href="#a28307288eaac35d84bab71207c9f9afa">More...</a><br /></td></tr>
<tr class="separator:a28307288eaac35d84bab71207c9f9afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf392447ab43fa4f194b2c1d7ea210a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1LLVM_1_1LLVMType.html">LLVMType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a4bf392447ab43fa4f194b2c1d7ea210a">getBody</a> ()</td></tr>
<tr class="memdesc:a4bf392447ab43fa4f194b2c1d7ea210a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of element types contained in a non-opaque struct.  <a href="#a4bf392447ab43fa4f194b2c1d7ea210a">More...</a><br /></td></tr>
<tr class="separator:a4bf392447ab43fa4f194b2c1d7ea210a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ade376989c030c140645e36f57d903e87"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVMStructType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#ade376989c030c140645e36f57d903e87">getIdentified</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, StringRef name)</td></tr>
<tr class="memdesc:ade376989c030c140645e36f57d903e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or creates an identified struct with the given name in the provided context.  <a href="#ade376989c030c140645e36f57d903e87">More...</a><br /></td></tr>
<tr class="separator:ade376989c030c140645e36f57d903e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7b433617e8087a841b26cb90e4caff"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVMStructType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#adb7b433617e8087a841b26cb90e4caff">getLiteral</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1LLVM_1_1LLVMType.html">LLVMType</a> &gt; types, bool <a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#a977513e9aaf4dd672ffb9ce793338176">isPacked</a>=false)</td></tr>
<tr class="memdesc:adb7b433617e8087a841b26cb90e4caff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or creates a literal struct with the given body in the provided context.  <a href="#adb7b433617e8087a841b26cb90e4caff">More...</a><br /></td></tr>
<tr class="separator:adb7b433617e8087a841b26cb90e4caff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f1303d669c80754602d0ac1b9f3eac"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVMStructType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html#ae3f1303d669c80754602d0ac1b9f3eac">getOpaque</a> (StringRef name, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ae3f1303d669c80754602d0ac1b9f3eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets or creates an intentionally-opaque identified struct.  <a href="#ae3f1303d669c80754602d0ac1b9f3eac">More...</a><br /></td></tr>
<tr class="separator:ae3f1303d669c80754602d0ac1b9f3eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmlir_1_1detail_1_1StorageUserBase')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;</a></td></tr>
<tr class="memitem:a1d588973ede0325016eb3f0230bff575 inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1TypeID.html">TypeID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a1d588973ede0325016eb3f0230bff575">getTypeID</a> ()</td></tr>
<tr class="memdesc:a1d588973ede0325016eb3f0230bff575 inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a unique identifier for the concrete type.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#a1d588973ede0325016eb3f0230bff575">More...</a><br /></td></tr>
<tr class="separator:a1d588973ede0325016eb3f0230bff575 inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bd0dcee2aea120f3cb2dae707e4d1f inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a15bd0dcee2aea120f3cb2dae707e4d1f inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a15bd0dcee2aea120f3cb2dae707e4d1f">classof</a> (T val)</td></tr>
<tr class="memdesc:a15bd0dcee2aea120f3cb2dae707e4d1f inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide an implementation of 'classof' that compares the type id of the provided value with that of the concerete type.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#a15bd0dcee2aea120f3cb2dae707e4d1f">More...</a><br /></td></tr>
<tr class="separator:a15bd0dcee2aea120f3cb2dae707e4d1f inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9aae36667a28d6ca83a01ea10e9ea4c inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1detail_1_1InterfaceMap.html">detail::InterfaceMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#ac9aae36667a28d6ca83a01ea10e9ea4c">getInterfaceMap</a> ()</td></tr>
<tr class="memdesc:ac9aae36667a28d6ca83a01ea10e9ea4c inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an interface map for the interfaces registered to this storage user.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#ac9aae36667a28d6ca83a01ea10e9ea4c">More...</a><br /></td></tr>
<tr class="separator:ac9aae36667a28d6ca83a01ea10e9ea4c inherit pub_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classmlir_1_1detail_1_1StorageUserBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmlir_1_1detail_1_1StorageUserBase')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;</a></td></tr>
<tr class="memitem:a2c65c0623b8acc13869cfed3cd0193d8 inherit pub_types_classmlir_1_1detail_1_1StorageUserBase"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a2c65c0623b8acc13869cfed3cd0193d8">Base</a> = <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">StorageUserBase</a>&lt; ConcreteT, <a class="el" href="classBaseT.html">BaseT</a>, StorageT, UniquerT, Traits... &gt;</td></tr>
<tr class="memdesc:a2c65c0623b8acc13869cfed3cd0193d8 inherit pub_types_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility declarations for the concrete attribute class.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#a2c65c0623b8acc13869cfed3cd0193d8">More...</a><br /></td></tr>
<tr class="separator:a2c65c0623b8acc13869cfed3cd0193d8 inherit pub_types_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9172110ae9298fcf582ab2deccdc4039 inherit pub_types_classmlir_1_1detail_1_1StorageUserBase"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a9172110ae9298fcf582ab2deccdc4039">ImplType</a> = StorageT</td></tr>
<tr class="separator:a9172110ae9298fcf582ab2deccdc4039 inherit pub_types_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmlir_1_1detail_1_1StorageUserBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmlir_1_1detail_1_1StorageUserBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;</a></td></tr>
<tr class="memitem:a196e59db0f0b3e43082946fed226f13f inherit pro_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a196e59db0f0b3e43082946fed226f13f inherit pro_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a196e59db0f0b3e43082946fed226f13f">mutate</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a196e59db0f0b3e43082946fed226f13f inherit pro_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutate the current storage instance.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#a196e59db0f0b3e43082946fed226f13f">More...</a><br /></td></tr>
<tr class="separator:a196e59db0f0b3e43082946fed226f13f inherit pro_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a88fd7c4a76677a3129e3a1be97a0cd inherit pro_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a9172110ae9298fcf582ab2deccdc4039">ImplType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a8a88fd7c4a76677a3129e3a1be97a0cd">getImpl</a> () const</td></tr>
<tr class="memdesc:a8a88fd7c4a76677a3129e3a1be97a0cd inherit pro_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for easy access to the storage instance.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#a8a88fd7c4a76677a3129e3a1be97a0cd">More...</a><br /></td></tr>
<tr class="separator:a8a88fd7c4a76677a3129e3a1be97a0cd inherit pro_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classmlir_1_1detail_1_1StorageUserBase')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT, Traits &gt;</a></td></tr>
<tr class="memitem:a858ef61c81f98e989e04ca730496269c inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a858ef61c81f98e989e04ca730496269c inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplItemLeft" align="right" valign="top">static ConcreteT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a858ef61c81f98e989e04ca730496269c">get</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, unsigned kind, Args... args)</td></tr>
<tr class="memdesc:a858ef61c81f98e989e04ca730496269c inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or create a new ConcreteT instance within the ctx.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#a858ef61c81f98e989e04ca730496269c">More...</a><br /></td></tr>
<tr class="separator:a858ef61c81f98e989e04ca730496269c inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8f8fa1eed1c4ff269b1c49afbc79cb inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplParams" colspan="2">template&lt;typename LocationT , typename... Args&gt; </td></tr>
<tr class="memitem:abf8f8fa1eed1c4ff269b1c49afbc79cb inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplItemLeft" align="right" valign="top">static ConcreteT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#abf8f8fa1eed1c4ff269b1c49afbc79cb">getChecked</a> (LocationT loc, unsigned kind, Args... args)</td></tr>
<tr class="memdesc:abf8f8fa1eed1c4ff269b1c49afbc79cb inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get or create a new ConcreteT instance within the ctx, defined at the given, potentially unknown, location.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#abf8f8fa1eed1c4ff269b1c49afbc79cb">More...</a><br /></td></tr>
<tr class="separator:abf8f8fa1eed1c4ff269b1c49afbc79cb inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6ca5fc2b8d6e084d241ad8bfa5bc99 inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7a6ca5fc2b8d6e084d241ad8bfa5bc99 inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a7a6ca5fc2b8d6e084d241ad8bfa5bc99">verifyConstructionInvariants</a> (Args... args)</td></tr>
<tr class="memdesc:a7a6ca5fc2b8d6e084d241ad8bfa5bc99 inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default implementation that just returns success.  <a href="classmlir_1_1detail_1_1StorageUserBase.html#a7a6ca5fc2b8d6e084d241ad8bfa5bc99">More...</a><br /></td></tr>
<tr class="separator:a7a6ca5fc2b8d6e084d241ad8bfa5bc99 inherit pro_static_methods_classmlir_1_1detail_1_1StorageUserBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect structure type representing a collection of different-typed elements manipulated together. </p>
<p>Structured can optionally be packed, meaning that their elements immediately follow each other in memory without accounting for potential alignment.</p>
<p>Structure types can be identified (named) or literal. Literal structures are uniquely represented by the list of types they contain and packedness. Literal structure types are immutable after construction.</p>
<p>Identified structures are uniquely represented by their name, a string. They have a mutable component, consisting of the list of types they contain, the packedness and the opacity bits. Identified structs can be created without providing the lists of element types, making them suitable to represent recursive, i.e. self-referring, structures. Identified structs without body are considered opaque. For such structs, one can set the body. Identified structs can be created as intentionally-opaque, implying that the caller does not intend to ever set the body (e.g. forward-declarations of structs from another module) and wants to disallow further modification of the body. For intentionally-opaque structs or non-opaque structs with the body, one is not allowed to set another body (however, one can set exactly the same body).</p>
<p>Note that the packedness of the struct takes place in uniquing of literal structs, but does not in uniquing of identified structs. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8h_source.html#l00409">409</a> of file <a class="el" href="LLVMTypes_8h_source.html">LLVMTypes.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a4bf392447ab43fa4f194b2c1d7ea210a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf392447ab43fa4f194b2c1d7ea210a">&#9670;&nbsp;</a></span>getBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1LLVM_1_1LLVMType.html">LLVMType</a> &gt; LLVMStructType::getBody </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the list of element types contained in a non-opaque struct. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00321">321</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMTypeSyntax_8cpp_source.html#l00070">printStructTypeBody()</a>, and <a class="el" href="TypeTranslation_8cpp_source.html#l00030">mlir::LLVM::detail::TypeToLLVMIRTranslatorImpl::translateType()</a>.</p>

</div>
</div>
<a id="ade376989c030c140645e36f57d903e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade376989c030c140645e36f57d903e87">&#9670;&nbsp;</a></span>getIdentified()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVMStructType</a> LLVMStructType::getIdentified </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or creates an identified struct with the given name in the provided context. </p>
<p>Note that unlike llvm::StructType::create, this function will <em>NOT</em> rename a struct in case a struct with the same name already exists in the context. Instead, it will just return the existing struct, similarly to the rest of MLIR type ::get methods. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00294">294</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="LLVMTypes_8h_source.html#l00087">mlir::LLVM::LLVMType::StructType</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMTypes_8cpp_source.html#l00198">mlir::LLVM::LLVMType::createStructTy()</a>, and <a class="el" href="TypeTranslation_8cpp_source.html#l00194">mlir::LLVM::detail::TypeFromLLVMIRTranslatorImpl::translateType()</a>.</p>

</div>
</div>
<a id="adb7b433617e8087a841b26cb90e4caff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7b433617e8087a841b26cb90e4caff">&#9670;&nbsp;</a></span>getLiteral()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVMStructType</a> LLVMStructType::getLiteral </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1LLVM_1_1LLVMType.html">LLVMType</a> &gt;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isPacked</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or creates a literal struct with the given body in the provided context. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00299">299</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="LLVMTypes_8h_source.html#l00087">mlir::LLVM::LLVMType::StructType</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMTypes_8cpp_source.html#l00177">mlir::LLVM::LLVMType::getStructTy()</a>, and <a class="el" href="TypeTranslation_8cpp_source.html#l00194">mlir::LLVM::detail::TypeFromLLVMIRTranslatorImpl::translateType()</a>.</p>

</div>
</div>
<a id="a28307288eaac35d84bab71207c9f9afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28307288eaac35d84bab71207c9f9afa">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StringRef LLVMStructType::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name of an identified struct. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00320">320</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMTypeSyntax_8cpp_source.html#l00096">printStructType()</a>, <a class="el" href="LLVMTypeSyntax_8cpp_source.html#l00070">printStructTypeBody()</a>, and <a class="el" href="TypeTranslation_8cpp_source.html#l00030">mlir::LLVM::detail::TypeToLLVMIRTranslatorImpl::translateType()</a>.</p>

</div>
</div>
<a id="ae3f1303d669c80754602d0ac1b9f3eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f1303d669c80754602d0ac1b9f3eac">&#9670;&nbsp;</a></span>getOpaque()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1LLVM_1_1LLVMStructType.html">LLVMStructType</a> LLVMStructType::getOpaque </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets or creates an intentionally-opaque identified struct. </p>
<p>Such a struct cannot have its body set. To create an opaque struct with a mutable body, use <code>getIdentified</code>. Note that unlike llvm::StructType::create, this function will <em>NOT</em> rename a struct in case a struct with the same name already exists in the context. Instead, it will just return the existing struct, similarly to the rest of MLIR type ::get methods. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00305">305</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="LLVMTypes_8h_source.html#l00087">mlir::LLVM::LLVMType::StructType</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeTranslation_8cpp_source.html#l00194">mlir::LLVM::detail::TypeFromLLVMIRTranslatorImpl::translateType()</a>.</p>

</div>
</div>
<a id="a1ea8331c39f952bfe5f870c1d5aad63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea8331c39f952bfe5f870c1d5aad63b">&#9670;&nbsp;</a></span>isIdentified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LLVMStructType::isIdentified </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a struct is identified. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00315">315</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMTypeSyntax_8cpp_source.html#l00096">printStructType()</a>, <a class="el" href="LLVMTypeSyntax_8cpp_source.html#l00070">printStructTypeBody()</a>, and <a class="el" href="TypeTranslation_8cpp_source.html#l00030">mlir::LLVM::detail::TypeToLLVMIRTranslatorImpl::translateType()</a>.</p>

</div>
</div>
<a id="a78b583beb28f839f61169e419d3cd32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b583beb28f839f61169e419d3cd32b">&#9670;&nbsp;</a></span>isInitialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LLVMStructType::isInitialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a struct is initialized. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00319">319</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

</div>
</div>
<a id="a96a0b1510ce9eed7c21b9a83652ce55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a0b1510ce9eed7c21b9a83652ce55e">&#9670;&nbsp;</a></span>isOpaque()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LLVMStructType::isOpaque </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a struct is opaque. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00316">316</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMTypeSyntax_8cpp_source.html#l00070">printStructTypeBody()</a>, and <a class="el" href="TypeTranslation_8cpp_source.html#l00030">mlir::LLVM::detail::TypeToLLVMIRTranslatorImpl::translateType()</a>.</p>

</div>
</div>
<a id="a977513e9aaf4dd672ffb9ce793338176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977513e9aaf4dd672ffb9ce793338176">&#9670;&nbsp;</a></span>isPacked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LLVMStructType::isPacked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a struct is packed. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00314">314</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMTypeSyntax_8cpp_source.html#l00070">printStructTypeBody()</a>, and <a class="el" href="TypeTranslation_8cpp_source.html#l00030">mlir::LLVM::detail::TypeToLLVMIRTranslatorImpl::translateType()</a>.</p>

</div>
</div>
<a id="a6cb80965db7e0a6cdc758cbfaa9f8053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb80965db7e0a6cdc758cbfaa9f8053">&#9670;&nbsp;</a></span>setBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> LLVMStructType::setBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1LLVM_1_1LLVMType.html">LLVMType</a> &gt;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isPacked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the body of an identified struct. </p>
<p>Returns failure if the body could not be set, e.g. if the struct already has a body or if it was marked as intentionally opaque. This might happen in a multi-threaded context when a different thread modified the struct after it was created. Most callers are likely to assert this always succeeds, but it is possible to implement a local renaming scheme based on the result of this call. </p>

<p class="definition">Definition at line <a class="el" href="LLVMTypes_8cpp_source.html#l00309">309</a> of file <a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeTranslation_8cpp_source.html#l00194">mlir::LLVM::detail::TypeFromLLVMIRTranslatorImpl::translateType()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Dialect/LLVMIR/<a class="el" href="LLVMTypes_8h_source.html">LLVMTypes.h</a></li>
<li>lib/Dialect/LLVMIR/IR/<a class="el" href="LLVMTypes_8cpp_source.html">LLVMTypes.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Aug 8 2020 16:27:20 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
