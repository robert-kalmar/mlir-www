<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::VectorTransferRewriter&lt; TransferOpTy &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">12.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="structmlir_1_1VectorTransferRewriter.html">VectorTransferRewriter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structmlir_1_1VectorTransferRewriter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::VectorTransferRewriter&lt; TransferOpTy &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implements lowering of TransferReadOp and TransferWriteOp to a proper abstraction for the hardware.  
 <a href="structmlir_1_1VectorTransferRewriter.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="VectorToSCF_8h_source.html">mlir/Conversion/VectorToSCF/VectorToSCF.h</a>&quot;</code></p>
<div class="dynheader">
Inheritance diagram for mlir::VectorTransferRewriter&lt; TransferOpTy &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structmlir_1_1VectorTransferRewriter__inherit__graph.png" border="0" usemap="#mlir_1_1VectorTransferRewriter_3_01TransferOpTy_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="mlir_1_1VectorTransferRewriter_3_01TransferOpTy_01_4_inherit__map" id="mlir_1_1VectorTransferRewriter_3_01TransferOpTy_01_4_inherit__map">
<area shape="rect" id="node2" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements. " alt="" coords="29,80,168,107"/>
<area shape="rect" id="node3" href="classmlir_1_1Pattern.html" title="Instances of Pattern can be matched against SSA IR. " alt="" coords="52,5,145,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mlir::VectorTransferRewriter&lt; TransferOpTy &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structmlir_1_1VectorTransferRewriter__coll__graph.png" border="0" usemap="#mlir_1_1VectorTransferRewriter_3_01TransferOpTy_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="mlir_1_1VectorTransferRewriter_3_01TransferOpTy_01_4_coll__map" id="mlir_1_1VectorTransferRewriter_3_01TransferOpTy_01_4_coll__map">
<area shape="rect" id="node2" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements. " alt="" coords="87,213,225,240"/>
<area shape="rect" id="node3" href="classmlir_1_1Pattern.html" title="Instances of Pattern can be matched against SSA IR. " alt="" coords="5,117,99,143"/>
<area shape="rect" id="node4" href="classllvm_1_1SmallVector.html" title="llvm::SmallVector\&lt;\l mlir::OperationName, 2 \&gt;" alt="" coords="123,109,296,151"/>
<area shape="rect" id="node5" href="classllvm_1_1SmallVector.html" title="llvm::SmallVector\&lt;\l T, N \&gt;" alt="" coords="143,5,276,47"/>
<area shape="rect" id="node6" href="structmlir_1_1VectorTransferToSCFOptions.html" title="Control whether unrolling is used when lowering vector transfer ops to SCF. " alt="" coords="249,213,473,240"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a774b1eabe2e550c9411c2af44020a6c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1VectorTransferRewriter.html#a774b1eabe2e550c9411c2af44020a6c5">VectorTransferRewriter</a> (<a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a> <a class="el" href="structmlir_1_1VectorTransferRewriter.html#a0d115291cc32cad6182bef77b3d45575">options</a>, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="separator:a774b1eabe2e550c9411c2af44020a6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20cdf571be94b0e24efaa5434d3271d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1VectorTransferRewriter.html#a20cdf571be94b0e24efaa5434d3271d7">tmpMemRefType</a> (TransferOpTy transfer) const</td></tr>
<tr class="memdesc:a20cdf571be94b0e24efaa5434d3271d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for staging the transfer in a local buffer.  <a href="#a20cdf571be94b0e24efaa5434d3271d7">More...</a><br /></td></tr>
<tr class="separator:a20cdf571be94b0e24efaa5434d3271d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f47b1204bcacebdd334a018a5f2499"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1VectorTransferRewriter.html#ac1f47b1204bcacebdd334a018a5f2499">matchAndRewrite</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter) const override</td></tr>
<tr class="memdesc:ac1f47b1204bcacebdd334a018a5f2499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the rewrite.  <a href="#ac1f47b1204bcacebdd334a018a5f2499">More...</a><br /></td></tr>
<tr class="separator:ac1f47b1204bcacebdd334a018a5f2499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad43314c5c15124e6d03d9cd2a57c15b"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aad43314c5c15124e6d03d9cd2a57c15b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmlir_1_1VectorTransferRewriter.html#aad43314c5c15124e6d03d9cd2a57c15b">matchAndRewrite</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter) const</td></tr>
<tr class="memdesc:aad43314c5c15124e6d03d9cd2a57c15b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowers TransferReadOp into a combination of:  <a href="#aad43314c5c15124e6d03d9cd2a57c15b">More...</a><br /></td></tr>
<tr class="separator:aad43314c5c15124e6d03d9cd2a57c15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c31e4661ffe1163f4c934191089dc50"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a1c31e4661ffe1163f4c934191089dc50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmlir_1_1VectorTransferRewriter.html#a1c31e4661ffe1163f4c934191089dc50">matchAndRewrite</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter) const</td></tr>
<tr class="memdesc:a1c31e4661ffe1163f4c934191089dc50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowers TransferWriteOp into a combination of:  <a href="#a1c31e4661ffe1163f4c934191089dc50">More...</a><br /></td></tr>
<tr class="separator:a1c31e4661ffe1163f4c934191089dc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1RewritePattern"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1RewritePattern')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1RewritePattern.html">mlir::RewritePattern</a></td></tr>
<tr class="memitem:adad5c6486c097ed7fabaf06479de25b4 inherit pub_methods_classmlir_1_1RewritePattern"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewritePattern.html#adad5c6486c097ed7fabaf06479de25b4">rewrite</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter) const</td></tr>
<tr class="memdesc:adad5c6486c097ed7fabaf06479de25b4 inherit pub_methods_classmlir_1_1RewritePattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the IR rooted at the specified operation with the result of this pattern, generating any new operations with the specified builder.  <a href="classmlir_1_1RewritePattern.html#adad5c6486c097ed7fabaf06479de25b4">More...</a><br /></td></tr>
<tr class="separator:adad5c6486c097ed7fabaf06479de25b4 inherit pub_methods_classmlir_1_1RewritePattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ece03194c6f9f9a5ada1430e839b3be inherit pub_methods_classmlir_1_1RewritePattern"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewritePattern.html#a6ece03194c6f9f9a5ada1430e839b3be">match</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op) const override</td></tr>
<tr class="memdesc:a6ece03194c6f9f9a5ada1430e839b3be inherit pub_methods_classmlir_1_1RewritePattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to match against code rooted at the specified operation, which is the same operation code as <a class="el" href="classmlir_1_1Pattern.html#ae0ac6bb1e06230bbc3865149d0365384" title="Return the root node that this pattern matches. ">getRootKind()</a>.  <a href="classmlir_1_1RewritePattern.html#a6ece03194c6f9f9a5ada1430e839b3be">More...</a><br /></td></tr>
<tr class="separator:a6ece03194c6f9f9a5ada1430e839b3be inherit pub_methods_classmlir_1_1RewritePattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a1f04fba5ece5962c98a3899e0db1f inherit pub_methods_classmlir_1_1RewritePattern"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewritePattern.html#a00a1f04fba5ece5962c98a3899e0db1f">hasBoundedRewriteRecursion</a> () const</td></tr>
<tr class="memdesc:a00a1f04fba5ece5962c98a3899e0db1f inherit pub_methods_classmlir_1_1RewritePattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this pattern is known to result in recursive application, i.e.  <a href="classmlir_1_1RewritePattern.html#a00a1f04fba5ece5962c98a3899e0db1f">More...</a><br /></td></tr>
<tr class="separator:a00a1f04fba5ece5962c98a3899e0db1f inherit pub_methods_classmlir_1_1RewritePattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf17f1c16c0daaf6beca322e6ea2eb02 inherit pub_methods_classmlir_1_1RewritePattern"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OperationName.html">OperationName</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewritePattern.html#abf17f1c16c0daaf6beca322e6ea2eb02">getGeneratedOps</a> () const</td></tr>
<tr class="memdesc:abf17f1c16c0daaf6beca322e6ea2eb02 inherit pub_methods_classmlir_1_1RewritePattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of operations that may be generated when rewriting an operation instance with this pattern.  <a href="classmlir_1_1RewritePattern.html#abf17f1c16c0daaf6beca322e6ea2eb02">More...</a><br /></td></tr>
<tr class="separator:abf17f1c16c0daaf6beca322e6ea2eb02 inherit pub_methods_classmlir_1_1RewritePattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1Pattern"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1Pattern')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1Pattern.html">mlir::Pattern</a></td></tr>
<tr class="memitem:a6769bdcbb4d0b6f8c46819bf0ce88a6a inherit pub_methods_classmlir_1_1Pattern"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Pattern.html#a6769bdcbb4d0b6f8c46819bf0ce88a6a">getBenefit</a> () const</td></tr>
<tr class="memdesc:a6769bdcbb4d0b6f8c46819bf0ce88a6a inherit pub_methods_classmlir_1_1Pattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the benefit (the inverse of "cost") of matching this pattern.  <a href="classmlir_1_1Pattern.html#a6769bdcbb4d0b6f8c46819bf0ce88a6a">More...</a><br /></td></tr>
<tr class="separator:a6769bdcbb4d0b6f8c46819bf0ce88a6a inherit pub_methods_classmlir_1_1Pattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ac6bb1e06230bbc3865149d0365384 inherit pub_methods_classmlir_1_1Pattern"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1OperationName.html">OperationName</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Pattern.html#ae0ac6bb1e06230bbc3865149d0365384">getRootKind</a> () const</td></tr>
<tr class="memdesc:ae0ac6bb1e06230bbc3865149d0365384 inherit pub_methods_classmlir_1_1Pattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the root node that this pattern matches.  <a href="classmlir_1_1Pattern.html#ae0ac6bb1e06230bbc3865149d0365384">More...</a><br /></td></tr>
<tr class="separator:ae0ac6bb1e06230bbc3865149d0365384 inherit pub_methods_classmlir_1_1Pattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb25930396420ddadc1dfe1726fb49d4 inherit pub_methods_classmlir_1_1Pattern"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Pattern.html#acb25930396420ddadc1dfe1726fb49d4">~Pattern</a> ()</td></tr>
<tr class="separator:acb25930396420ddadc1dfe1726fb49d4 inherit pub_methods_classmlir_1_1Pattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a0d115291cc32cad6182bef77b3d45575"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1VectorTransferRewriter.html#a0d115291cc32cad6182bef77b3d45575">options</a></td></tr>
<tr class="memdesc:a0d115291cc32cad6182bef77b3d45575"><td class="mdescLeft">&#160;</td><td class="mdescRight">See description of <code><a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html" title="Control whether unrolling is used when lowering vector transfer ops to SCF. ">VectorTransferToSCFOptions</a></code>.  <a href="#a0d115291cc32cad6182bef77b3d45575">More...</a><br /></td></tr>
<tr class="separator:a0d115291cc32cad6182bef77b3d45575"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classmlir_1_1RewritePattern"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmlir_1_1RewritePattern')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmlir_1_1RewritePattern.html">mlir::RewritePattern</a></td></tr>
<tr class="memitem:a7191bf013409d8080aa498798ea27186 inherit pro_methods_classmlir_1_1RewritePattern"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewritePattern.html#a7191bf013409d8080aa498798ea27186">RewritePattern</a> (StringRef rootName, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a7191bf013409d8080aa498798ea27186 inherit pro_methods_classmlir_1_1RewritePattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a rewrite pattern with a certain benefit that matches the operation with the given root name.  <a href="classmlir_1_1RewritePattern.html#a7191bf013409d8080aa498798ea27186">More...</a><br /></td></tr>
<tr class="separator:a7191bf013409d8080aa498798ea27186 inherit pro_methods_classmlir_1_1RewritePattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6653d1507069d529d08b2402028a74bd inherit pro_methods_classmlir_1_1RewritePattern"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewritePattern.html#a6653d1507069d529d08b2402028a74bd">RewritePattern</a> (<a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit, <a class="el" href="structmlir_1_1Pattern_1_1MatchAnyOpTypeTag.html">MatchAnyOpTypeTag</a> tag)</td></tr>
<tr class="memdesc:a6653d1507069d529d08b2402028a74bd inherit pro_methods_classmlir_1_1RewritePattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a rewrite pattern with a certain benefit that matches any operation type.  <a href="classmlir_1_1RewritePattern.html#a6653d1507069d529d08b2402028a74bd">More...</a><br /></td></tr>
<tr class="separator:a6653d1507069d529d08b2402028a74bd inherit pro_methods_classmlir_1_1RewritePattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577c1c7244c252969f8ec3303bba857b inherit pro_methods_classmlir_1_1RewritePattern"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewritePattern.html#a577c1c7244c252969f8ec3303bba857b">RewritePattern</a> (StringRef rootName, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt; generatedNames, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a577c1c7244c252969f8ec3303bba857b inherit pro_methods_classmlir_1_1RewritePattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a rewrite pattern with a certain benefit that matches the operation with the given root name.  <a href="classmlir_1_1RewritePattern.html#a577c1c7244c252969f8ec3303bba857b">More...</a><br /></td></tr>
<tr class="separator:a577c1c7244c252969f8ec3303bba857b inherit pro_methods_classmlir_1_1RewritePattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84729d4cc5e52bb5381a86901261fb7d inherit pro_methods_classmlir_1_1RewritePattern"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewritePattern.html#a84729d4cc5e52bb5381a86901261fb7d">RewritePattern</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt; generatedNames, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="structmlir_1_1Pattern_1_1MatchAnyOpTypeTag.html">MatchAnyOpTypeTag</a> tag)</td></tr>
<tr class="memdesc:a84729d4cc5e52bb5381a86901261fb7d inherit pro_methods_classmlir_1_1RewritePattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a rewrite pattern that may match any operation type.  <a href="classmlir_1_1RewritePattern.html#a84729d4cc5e52bb5381a86901261fb7d">More...</a><br /></td></tr>
<tr class="separator:a84729d4cc5e52bb5381a86901261fb7d inherit pro_methods_classmlir_1_1RewritePattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmlir_1_1Pattern"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmlir_1_1Pattern')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmlir_1_1Pattern.html">mlir::Pattern</a></td></tr>
<tr class="memitem:a3fbbbe0fe8c9f72cebc81dc4c7706560 inherit pro_methods_classmlir_1_1Pattern"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Pattern.html#a3fbbbe0fe8c9f72cebc81dc4c7706560">Pattern</a> (StringRef rootName, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a3fbbbe0fe8c9f72cebc81dc4c7706560 inherit pro_methods_classmlir_1_1Pattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor is used for patterns that match against a specific operation type.  <a href="classmlir_1_1Pattern.html#a3fbbbe0fe8c9f72cebc81dc4c7706560">More...</a><br /></td></tr>
<tr class="separator:a3fbbbe0fe8c9f72cebc81dc4c7706560 inherit pro_methods_classmlir_1_1Pattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978376e179a219963c0665e2dfd369f7 inherit pro_methods_classmlir_1_1Pattern"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Pattern.html#a978376e179a219963c0665e2dfd369f7">Pattern</a> (<a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit, <a class="el" href="structmlir_1_1Pattern_1_1MatchAnyOpTypeTag.html">MatchAnyOpTypeTag</a>)</td></tr>
<tr class="memdesc:a978376e179a219963c0665e2dfd369f7 inherit pro_methods_classmlir_1_1Pattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor is used when a pattern may match against multiple different types of operations.  <a href="classmlir_1_1Pattern.html#a978376e179a219963c0665e2dfd369f7">More...</a><br /></td></tr>
<tr class="separator:a978376e179a219963c0665e2dfd369f7 inherit pro_methods_classmlir_1_1Pattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classmlir_1_1RewritePattern"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classmlir_1_1RewritePattern')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmlir_1_1RewritePattern.html">mlir::RewritePattern</a></td></tr>
<tr class="memitem:a5ab3a6d492161c1fda35180f994710ce inherit pro_attribs_classmlir_1_1RewritePattern"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OperationName.html">OperationName</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewritePattern.html#a5ab3a6d492161c1fda35180f994710ce">generatedOps</a></td></tr>
<tr class="memdesc:a5ab3a6d492161c1fda35180f994710ce inherit pro_attribs_classmlir_1_1RewritePattern"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of the potential operations that may be generated when rewriting an op with this pattern.  <a href="classmlir_1_1RewritePattern.html#a5ab3a6d492161c1fda35180f994710ce">More...</a><br /></td></tr>
<tr class="separator:a5ab3a6d492161c1fda35180f994710ce inherit pro_attribs_classmlir_1_1RewritePattern"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename TransferOpTy&gt;<br />
struct mlir::VectorTransferRewriter&lt; TransferOpTy &gt;</h3>

<p>Implements lowering of TransferReadOp and TransferWriteOp to a proper abstraction for the hardware. </p>
<p>There are multiple cases.</p>
<h1>Case A: Permutation Map does not permute or broadcast. </h1>
<p>Progressive lowering occurs to 1-D vector transfer ops according to the description in <code><a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html" title="Control whether unrolling is used when lowering vector transfer ops to SCF. ">VectorTransferToSCFOptions</a></code>.</p>
<h1>Case B: Permutation Map permutes and/or broadcasts. </h1>
<p>This path will be progressively deprecated and folded into the case above by using vector broadcast and transpose operations.</p>
<p>This path only emits a simple loop nest that performs clipped pointwise copies from a remote to a locally allocated memory.</p>
<p>Consider the case:</p>
<div class="fragment"><div class="line">// Read the slice `%A[%i0, %i1:%i1+256, %i2:%i2+32]` into</div><div class="line">// vector&lt;32x256xf32&gt; and pad with %f0 to handle the boundary case:</div><div class="line">%f0 = constant 0.0f : f32</div><div class="line">scf.for %i0 = 0 to %0 {</div><div class="line">  scf.for %i1 = 0 to %1 step %c256 {</div><div class="line">    scf.for %i2 = 0 to %2 step %c32 {</div><div class="line">      %v = vector.transfer_read %A[%i0, %i1, %i2], %f0</div><div class="line">           {permutation_map: (d0, d1, d2) -&gt; (d2, d1)} :</div><div class="line">           memref&lt;?x?x?xf32&gt;, vector&lt;32x256xf32&gt;</div><div class="line">}}}</div></div><!-- fragment --><p>The rewriters construct loop and indices that access MemRef A in a pattern resembling the following (while guaranteeing an always full-tile abstraction):</p>
<div class="fragment"><div class="line">scf.for %d2 = 0 to %c256 {</div><div class="line">  scf.for %d1 = 0 to %c32 {</div><div class="line">    %s = %A[%i0, %i1 + %d1, %i2 + %d2] : f32</div><div class="line">    %tmp[%d2, %d1] = %s</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>In the current state, only a clipping transfer is implemented by <code>clip</code>, which creates individual indexing expressions of the form:</p>
<div class="fragment"><div class="line">auto condMax = i + ii &lt; N;</div><div class="line">auto max = std_select(condMax, i + ii, N - one)</div><div class="line">auto cond = i + ii &lt; zero;</div><div class="line">std_select(cond, zero, max);</div></div><!-- fragment --><p>In the future, clipping should not be the only way and instead we should load vectors + mask them. Similarly on the write side, load/mask/store for implementing RMW behavior.</p>
<p>Lowers TransferOp into a combination of:</p><ol type="1">
<li>local memory allocation;</li>
<li>perfect loop nest over: a. scalar load/stores from local buffers (viewed as a scalar memref); a. scalar store/load to original memref (with clipping).</li>
<li>vector_load/store</li>
<li>local memory deallocation. Minor variations occur depending on whether a TransferReadOp or a TransferWriteOp is rewritten. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="VectorToSCF_8h_source.html#l00148">148</a> of file <a class="el" href="VectorToSCF_8h_source.html">VectorToSCF.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a774b1eabe2e550c9411c2af44020a6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a774b1eabe2e550c9411c2af44020a6c5">&#9670;&nbsp;</a></span>VectorTransferRewriter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TransferOpTy &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1VectorTransferRewriter.html">mlir::VectorTransferRewriter</a>&lt; TransferOpTy &gt;::<a class="el" href="structmlir_1_1VectorTransferRewriter.html">VectorTransferRewriter</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorToSCF_8cpp_source.html#l00478">478</a> of file <a class="el" href="VectorToSCF_8cpp_source.html">VectorToSCF.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac1f47b1204bcacebdd334a018a5f2499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f47b1204bcacebdd334a018a5f2499">&#9670;&nbsp;</a></span>matchAndRewrite() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TransferOpTy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> <a class="el" href="structmlir_1_1VectorTransferRewriter.html">mlir::VectorTransferRewriter</a>&lt; TransferOpTy &gt;::matchAndRewrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs the rewrite. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1RewritePattern.html#a94535cc2da56fd0fdc067a36817b4d55">mlir::RewritePattern</a>.</p>

</div>
</div>
<a id="aad43314c5c15124e6d03d9cd2a57c15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad43314c5c15124e6d03d9cd2a57c15b">&#9670;&nbsp;</a></span>matchAndRewrite() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> <a class="el" href="structmlir_1_1VectorTransferRewriter.html">mlir::VectorTransferRewriter</a>&lt; TransferReadOp &gt;::matchAndRewrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lowers TransferReadOp into a combination of: </p>
<ol type="1">
<li>local memory allocation;</li>
<li>perfect loop nest over: a. scalar load from local buffers (viewed as a scalar memref); a. scalar store to original memref (with clipping).</li>
<li>vector_load from local buffer (viewed as a memref&lt;1 x vector&gt;);</li>
<li>local memory deallocation.</li>
</ol>
<p>Lowers the data transfer part of a TransferReadOp while ensuring no out-of-bounds accesses are possible. Out-of-bounds behavior is handled by clipping. This means that a given value in memory can be read multiple times and concurrently.</p>
<h1>Important notes about clipping and "full-tiles only" abstraction: </h1>
<p>When using clipping for dealing with boundary conditions, the same edge value will appear multiple times (a.k.a edge padding). This is fine if the subsequent vector operations are all data-parallel but <b>is generally incorrect</b> in the presence of reductions or extract operations.</p>
<p>More generally, clipping is a scalar abstraction that is expected to work fine as a baseline for CPUs and GPUs but not for vector_load and DMAs. To deal with real vector_load and DMAs, a "padded allocation + view" abstraction with the ability to read out-of-memref-bounds (but still within the allocated region) is necessary.</p>
<p>Whether using scalar loops or vector_load/DMAs to perform the transfer, junk values will be materialized in the vectors and generally need to be filtered out and replaced by the "neutral element". This neutral element is op-dependent so, in the future, we expect to create a vector filter and apply it to a splatted constant vector with the proper neutral element at each ssa-use. This filtering is not necessary for pure data-parallel operations.</p>
<p>In the case of vector_store/DMAs, Read-Modify-Write will be required, which also have concurrency implications. Note that by using clipped scalar stores in the presence of data-parallel only operations, we generate code that writes the same value multiple time on the edge locations.</p>
<p>TODO: implement alternatives to clipping. TODO: support non-data-parallel operations. Performs the rewrite. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1RewritePattern.html#a94535cc2da56fd0fdc067a36817b4d55">mlir::RewritePattern</a>.</p>

<p class="definition">Definition at line <a class="el" href="VectorToSCF_8cpp_source.html#l00536">536</a> of file <a class="el" href="VectorToSCF_8cpp_source.html">VectorToSCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorToSCF_8cpp_source.html#l00425">clip()</a>, <a class="el" href="VectorToSCF_8cpp_source.html#l00396">computeCoalescedIndex()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html#l00018">mlir::edsc::loopNestBuilder()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00080">mlir::PatternRewriter::replaceOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>, and <a class="el" href="VectorToSCF_8cpp_source.html#l00485">mlir::VectorTransferRewriter&lt; TransferOpTy &gt;::tmpMemRefType()</a>.</p>

</div>
</div>
<a id="a1c31e4661ffe1163f4c934191089dc50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c31e4661ffe1163f4c934191089dc50">&#9670;&nbsp;</a></span>matchAndRewrite() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> <a class="el" href="structmlir_1_1VectorTransferRewriter.html">mlir::VectorTransferRewriter</a>&lt; TransferWriteOp &gt;::matchAndRewrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lowers TransferWriteOp into a combination of: </p>
<ol type="1">
<li>local memory allocation;</li>
<li>vector_store to local buffer (viewed as a memref&lt;1 x vector&gt;);</li>
<li>perfect loop nest over: a. scalar load from local buffers (viewed as a scalar memref); a. scalar store to original memref (with clipping).</li>
<li>local memory deallocation.</li>
</ol>
<p>More specifically, lowers the data transfer part while ensuring no out-of-bounds accesses are possible. Out-of-bounds behavior is handled by clipping. This means that a given value in memory can be written to multiple times and concurrently.</p>
<p>See <code>Important notes about clipping and full-tiles only abstraction</code> in the description of <code>readClipped</code> above.</p>
<p>TODO: implement alternatives to clipping. TODO: support non-data-parallel operations. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1RewritePattern.html#a94535cc2da56fd0fdc067a36817b4d55">mlir::RewritePattern</a>.</p>

<p class="definition">Definition at line <a class="el" href="VectorToSCF_8cpp_source.html#l00609">609</a> of file <a class="el" href="VectorToSCF_8cpp_source.html">VectorToSCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="VectorToSCF_8cpp_source.html#l00425">clip()</a>, <a class="el" href="VectorToSCF_8cpp_source.html#l00396">computeCoalescedIndex()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00094">mlir::PatternRewriter::eraseOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html#l00018">mlir::edsc::loopNestBuilder()</a>, <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>, and <a class="el" href="VectorToSCF_8cpp_source.html#l00485">mlir::VectorTransferRewriter&lt; TransferOpTy &gt;::tmpMemRefType()</a>.</p>

</div>
</div>
<a id="a20cdf571be94b0e24efaa5434d3271d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20cdf571be94b0e24efaa5434d3271d7">&#9670;&nbsp;</a></span>tmpMemRefType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TransferOpTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a> <a class="el" href="structmlir_1_1VectorTransferRewriter.html">mlir::VectorTransferRewriter</a>&lt; TransferOpTy &gt;::tmpMemRefType </td>
          <td>(</td>
          <td class="paramtype">TransferOpTy&#160;</td>
          <td class="paramname"><em>transfer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used for staging the transfer in a local buffer. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSCF_8cpp_source.html#l00485">485</a> of file <a class="el" href="VectorToSCF_8cpp_source.html">VectorToSCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardTypes_8cpp_source.html#l00379">mlir::MemRefType::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorToSCF_8cpp_source.html#l00536">mlir::VectorTransferRewriter&lt; TransferOpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0d115291cc32cad6182bef77b3d45575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d115291cc32cad6182bef77b3d45575">&#9670;&nbsp;</a></span>options</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TransferOpTy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html">VectorTransferToSCFOptions</a> <a class="el" href="structmlir_1_1VectorTransferRewriter.html">mlir::VectorTransferRewriter</a>&lt; TransferOpTy &gt;::options</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See description of <code><a class="el" href="structmlir_1_1VectorTransferToSCFOptions.html" title="Control whether unrolling is used when lowering vector transfer ops to SCF. ">VectorTransferToSCFOptions</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="VectorToSCF_8h_source.html#l00160">160</a> of file <a class="el" href="VectorToSCF_8h_source.html">VectorToSCF.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorToSCF_8cpp_source.html#l00693">mlir::createConvertVectorToSCFPass()</a>, and <a class="el" href="VectorToSCF_8cpp_source.html#l00662">mlir::populateVectorToSCFConversionPatterns()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>include/mlir/Conversion/VectorToSCF/<a class="el" href="VectorToSCF_8h_source.html">VectorToSCF.h</a></li>
<li>lib/Conversion/VectorToSCF/<a class="el" href="VectorToSCF_8cpp_source.html">VectorToSCF.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Aug 8 2020 16:27:20 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
