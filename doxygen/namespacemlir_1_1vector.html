<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::vector Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">12.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1vector.html">vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::vector Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1vector_1_1impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector_1_1impl.html">impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1vector_1_1UnrollVectorPattern.html">UnrollVectorPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="Instances of Pattern can be matched against SSA IR. ">Pattern</a> to apply <code>unrollSingleResultVectorOp</code> to a <code>targetShape</code> declaratively.  <a href="structmlir_1_1vector_1_1UnrollVectorPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1vector_1_1VectorTransferFullPartialRewriter.html">VectorTransferFullPartialRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply <code>splitFullAndPartialTransfer</code> selectively via a pattern.  <a href="structmlir_1_1vector_1_1VectorTransferFullPartialRewriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to control the behavior of vector transform patterns.  <a href="structmlir_1_1vector_1_1VectorTransformsOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aed8b08da9ea97e3670a2c8636b6773ea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#aed8b08da9ea97e3670a2c8636b6773ea">VectorContractLowering</a> { <a class="el" href="namespacemlir_1_1vector.html#aed8b08da9ea97e3670a2c8636b6773eaaaf6c6cf7a454b4ef4a850ac4d960a2cc">VectorContractLowering::Dot</a> = 0, 
<a class="el" href="namespacemlir_1_1vector.html#aed8b08da9ea97e3670a2c8636b6773eaa3543268dcb012cef3d015e2f64983872">VectorContractLowering::Matmul</a> = 1, 
<a class="el" href="namespacemlir_1_1vector.html#aed8b08da9ea97e3670a2c8636b6773eaa3080c8fd84516db2cf1d8dc557827994">VectorContractLowering::OuterProduct</a> = 2
 }<tr class="memdesc:aed8b08da9ea97e3670a2c8636b6773ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to control the lowering of <code>vector.contract</code> operations.  <a href="namespacemlir_1_1vector.html#aed8b08da9ea97e3670a2c8636b6773ea">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aed8b08da9ea97e3670a2c8636b6773ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3064c409437beb2a4fcd6d5425a6ac23"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a3064c409437beb2a4fcd6d5425a6ac23">VectorTransposeLowering</a> { <a class="el" href="namespacemlir_1_1vector.html#a3064c409437beb2a4fcd6d5425a6ac23ac03c36af4417d41de5ccdc8abdad69ec">VectorTransposeLowering::EltWise</a> = 0, 
<a class="el" href="namespacemlir_1_1vector.html#a3064c409437beb2a4fcd6d5425a6ac23a745e3db6a7ffd50e1a72b39482f0882d">VectorTransposeLowering::Flat</a> = 1
 }<tr class="memdesc:a3064c409437beb2a4fcd6d5425a6ac23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to control the lowering of <code>vector.transpose</code> operations.  <a href="namespacemlir_1_1vector.html#a3064c409437beb2a4fcd6d5425a6ac23">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3064c409437beb2a4fcd6d5425a6ac23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a6eb2276dcb5d10a00ae50149d53f9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a23a6eb2276dcb5d10a00ae50149d53f9">VectorTransferSplit</a> { <a class="el" href="namespacemlir_1_1vector.html#a23a6eb2276dcb5d10a00ae50149d53f9a6adf97f83acf6453d4a6a4b1070f3754">VectorTransferSplit::None</a> = 0, 
<a class="el" href="namespacemlir_1_1vector.html#a23a6eb2276dcb5d10a00ae50149d53f9a1ccd2cd55420e0abcdb19f15d086504f">VectorTransferSplit::VectorTransfer</a> = 1, 
<a class="el" href="namespacemlir_1_1vector.html#a23a6eb2276dcb5d10a00ae50149d53f9aa2cb215f91a0fc3791c22a870940f877">VectorTransferSplit::LinalgCopy</a> = 2, 
<a class="el" href="namespacemlir_1_1vector.html#a23a6eb2276dcb5d10a00ae50149d53f9a4470364df8166378167aecb08a0e9032">VectorTransferSplit::ForceUnmasked</a> = 3
 }<tr class="memdesc:a23a6eb2276dcb5d10a00ae50149d53f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to control the splitting of <code>vector.transfer</code> operations into masked and unmasked variants.  <a href="namespacemlir_1_1vector.html#a23a6eb2276dcb5d10a00ae50149d53f9">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a23a6eb2276dcb5d10a00ae50149d53f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae655dbb6a41b5f172d8109454dbef224"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#ae655dbb6a41b5f172d8109454dbef224">populateVectorToVectorCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ae655dbb6a41b5f172d8109454dbef224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of vector-to-vector canonicalization patterns.  <a href="#ae655dbb6a41b5f172d8109454dbef224">More...</a><br /></td></tr>
<tr class="separator:ae655dbb6a41b5f172d8109454dbef224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7605f60776cd8da648480ef5783fe18e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a7605f60776cd8da648480ef5783fe18e">populateVectorToVectorTransformationPatterns</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a7605f60776cd8da648480ef5783fe18e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of vector-to-vector transformation patterns.  <a href="#a7605f60776cd8da648480ef5783fe18e">More...</a><br /></td></tr>
<tr class="separator:a7605f60776cd8da648480ef5783fe18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa5e7d50b06ca604760ae921a24f6af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#abaa5e7d50b06ca604760ae921a24f6af">populateVectorSlicesLoweringPatterns</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:abaa5e7d50b06ca604760ae921a24f6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of vector slices transformation patterns: ExtractSlicesOpLowering, InsertSlicesOpLowering Useful for clients that want to express all vector "slices" ops in terms of more elementary vector "slice" ops.  <a href="#abaa5e7d50b06ca604760ae921a24f6af">More...</a><br /></td></tr>
<tr class="separator:abaa5e7d50b06ca604760ae921a24f6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad158cb1823f69b9024c57ebaf8f70d10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#ad158cb1823f69b9024c57ebaf8f70d10">populateVectorContractLoweringPatterns</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a> vectorTransformOptions=<a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a>())</td></tr>
<tr class="memdesc:ad158cb1823f69b9024c57ebaf8f70d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of transformation patterns that are related to contracting or expanding vector operations: <a class="el" href="classmlir_1_1ContractionOpLowering.html" title="Progressive lowering of ContractionOp. ">ContractionOpLowering</a>, ShapeCastOp2DDownCastRewritePattern, ShapeCastOp2DUpCastRewritePattern BroadcastOpLowering, TransposeOpLowering OuterproductOpLowering These transformation express higher level vector ops in terms of more elementary extraction, insertion, reduction, product, and broadcast ops.  <a href="#ad158cb1823f69b9024c57ebaf8f70d10">More...</a><br /></td></tr>
<tr class="separator:ad158cb1823f69b9024c57ebaf8f70d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cb3b0a7edef27b564ca0603fedec4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1IntegerType.html">IntegerType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#ae3cb3b0a7edef27b564ca0603fedec4a">getVectorSubscriptType</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;builder)</td></tr>
<tr class="memdesc:ae3cb3b0a7edef27b564ca0603fedec4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the integer type required for subscripts in the vector dialect.  <a href="#ae3cb3b0a7edef27b564ca0603fedec4a">More...</a><br /></td></tr>
<tr class="separator:ae3cb3b0a7edef27b564ca0603fedec4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0499bcd00b867b4665ddf0c939543cfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a0499bcd00b867b4665ddf0c939543cfb">getVectorSubscriptAttr</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;b, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values)</td></tr>
<tr class="memdesc:a0499bcd00b867b4665ddf0c939543cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an integer array attribute containing the given values using the integer type required for subscripts in the vector dialect.  <a href="#a0499bcd00b867b4665ddf0c939543cfb">More...</a><br /></td></tr>
<tr class="separator:a0499bcd00b867b4665ddf0c939543cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933ea17a5014ac296886e5262506d389"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a933ea17a5014ac296886e5262506d389">unrollSingleResultVectorOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; targetShape)</td></tr>
<tr class="memdesc:a933ea17a5014ac296886e5262506d389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for unrolling declarative pattern rewrites.  <a href="#a933ea17a5014ac296886e5262506d389">More...</a><br /></td></tr>
<tr class="separator:a933ea17a5014ac296886e5262506d389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1dd46b0167a6584fc56b4ac45a1c1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#a2b1dd46b0167a6584fc56b4ac45a1c1a">splitFullAndPartialTransferPrecondition</a> (VectorTransferOpInterface xferOp)</td></tr>
<tr class="memdesc:a2b1dd46b0167a6584fc56b4ac45a1c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a vector.transfer operation into an unmasked fastpath and a slowpath.  <a href="#a2b1dd46b0167a6584fc56b4ac45a1c1a">More...</a><br /></td></tr>
<tr class="separator:a2b1dd46b0167a6584fc56b4ac45a1c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea008e69d7dd969b5e885803b759a338"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html#aea008e69d7dd969b5e885803b759a338">splitFullAndPartialTransfer</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, VectorTransferOpInterface xferOp, <a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>=<a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a>(), scf::IfOp *ifOp=nullptr)</td></tr>
<tr class="memdesc:aea008e69d7dd969b5e885803b759a338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a vector.transfer operation into an unmasked fastpath and a slowpath.  <a href="#aea008e69d7dd969b5e885803b759a338">More...</a><br /></td></tr>
<tr class="separator:aea008e69d7dd969b5e885803b759a338"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aed8b08da9ea97e3670a2c8636b6773ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8b08da9ea97e3670a2c8636b6773ea">&#9670;&nbsp;</a></span>VectorContractLowering</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1vector.html#aed8b08da9ea97e3670a2c8636b6773ea">mlir::vector::VectorContractLowering</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum to control the lowering of <code>vector.contract</code> operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aed8b08da9ea97e3670a2c8636b6773eaaaf6c6cf7a454b4ef4a850ac4d960a2cc"></a>Dot&#160;</td><td class="fielddoc"><p>Progressively lower to finer grained <code>vector.contract</code> and dot-products. </p>
</td></tr>
<tr><td class="fieldname"><a id="aed8b08da9ea97e3670a2c8636b6773eaa3543268dcb012cef3d015e2f64983872"></a>Matmul&#160;</td><td class="fielddoc"><p>Lower to <code>vector.matrix_multiply</code>, maps 1-1 to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> matrix intrinsics. </p>
</td></tr>
<tr><td class="fieldname"><a id="aed8b08da9ea97e3670a2c8636b6773eaa3080c8fd84516db2cf1d8dc557827994"></a>OuterProduct&#160;</td><td class="fielddoc"><p>Lower to <code>vector.outerproduct</code>. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="VectorOps_8h_source.html#l00049">49</a> of file <a class="el" href="VectorOps_8h_source.html">VectorOps.h</a>.</p>

</div>
</div>
<a id="a23a6eb2276dcb5d10a00ae50149d53f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a6eb2276dcb5d10a00ae50149d53f9">&#9670;&nbsp;</a></span>VectorTransferSplit</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1vector.html#a23a6eb2276dcb5d10a00ae50149d53f9">mlir::vector::VectorTransferSplit</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum to control the splitting of <code>vector.transfer</code> operations into masked and unmasked variants. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a23a6eb2276dcb5d10a00ae50149d53f9a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>Do not split vector transfer operations. </p>
</td></tr>
<tr><td class="fieldname"><a id="a23a6eb2276dcb5d10a00ae50149d53f9a1ccd2cd55420e0abcdb19f15d086504f"></a>VectorTransfer&#160;</td><td class="fielddoc"><p>Split using masked + unmasked vector.transfer operations. </p>
</td></tr>
<tr><td class="fieldname"><a id="a23a6eb2276dcb5d10a00ae50149d53f9aa2cb215f91a0fc3791c22a870940f877"></a>LinalgCopy&#160;</td><td class="fielddoc"><p>Split using a unmasked vector.transfer + linalg.fill + linalg.copy operations. </p>
</td></tr>
<tr><td class="fieldname"><a id="a23a6eb2276dcb5d10a00ae50149d53f9a4470364df8166378167aecb08a0e9032"></a>ForceUnmasked&#160;</td><td class="fielddoc"><p>Do not split vector transfer operation but instead mark it as "unmasked". </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="VectorOps_8h_source.html#l00067">67</a> of file <a class="el" href="VectorOps_8h_source.html">VectorOps.h</a>.</p>

</div>
</div>
<a id="a3064c409437beb2a4fcd6d5425a6ac23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3064c409437beb2a4fcd6d5425a6ac23">&#9670;&nbsp;</a></span>VectorTransposeLowering</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1vector.html#a3064c409437beb2a4fcd6d5425a6ac23">mlir::vector::VectorTransposeLowering</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum to control the lowering of <code>vector.transpose</code> operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3064c409437beb2a4fcd6d5425a6ac23ac03c36af4417d41de5ccdc8abdad69ec"></a>EltWise&#160;</td><td class="fielddoc"><p>Lower transpose into element-wise extract and inserts. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3064c409437beb2a4fcd6d5425a6ac23a745e3db6a7ffd50e1a72b39482f0882d"></a>Flat&#160;</td><td class="fielddoc"><p>Lower 2-D transpose to <code>vector.flat_transpose</code>, maps 1-1 to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> matrix intrinsics. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="VectorOps_8h_source.html#l00058">58</a> of file <a class="el" href="VectorOps_8h_source.html">VectorOps.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0499bcd00b867b4665ddf0c939543cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0499bcd00b867b4665ddf0c939543cfb">&#9670;&nbsp;</a></span>getVectorSubscriptAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a> mlir::vector::getVectorSubscriptAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an integer array attribute containing the given values using the integer type required for subscripts in the vector dialect. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00056">56</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8cpp_source.html#l00232">mlir::Builder::getI64ArrayAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l00662">foldExtractOpFromInsertChainAndTranspose()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00491">inferExtractOpResultType()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01322">inferStridedSliceOpResultType()</a>, <a class="el" href="VectorOps_8h_source.html#l00097">mlir::vector::VectorTransformsOptions::setVectorTransferSplit()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l00836">verify()</a>.</p>

</div>
</div>
<a id="ae3cb3b0a7edef27b564ca0603fedec4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3cb3b0a7edef27b564ca0603fedec4a">&#9670;&nbsp;</a></span>getVectorSubscriptType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1IntegerType.html">IntegerType</a> mlir::vector::getVectorSubscriptType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the integer type required for subscripts in the vector dialect. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l00052">52</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8cpp_source.html#l00061">mlir::Builder::getIntegerType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8h_source.html#l00097">mlir::vector::VectorTransformsOptions::setVectorTransferSplit()</a>.</p>

</div>
</div>
<a id="ad158cb1823f69b9024c57ebaf8f70d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad158cb1823f69b9024c57ebaf8f70d10">&#9670;&nbsp;</a></span>populateVectorContractLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorContractLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a>&#160;</td>
          <td class="paramname"><em>vectorTransformOptions</em> = <code><a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of transformation patterns that are related to contracting or expanding vector operations: <a class="el" href="classmlir_1_1ContractionOpLowering.html" title="Progressive lowering of ContractionOp. ">ContractionOpLowering</a>, ShapeCastOp2DDownCastRewritePattern, ShapeCastOp2DUpCastRewritePattern BroadcastOpLowering, TransposeOpLowering OuterproductOpLowering These transformation express higher level vector ops in terms of more elementary extraction, insertion, reduction, product, and broadcast ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02454">2454</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00454">mlir::OwningRewritePatternList::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l01443">mlir::populateVectorToLLVMMatrixConversionPatterns()</a>, and <a class="el" href="VectorOps_8h_source.html#l00097">mlir::vector::VectorTransformsOptions::setVectorTransferSplit()</a>.</p>

</div>
</div>
<a id="abaa5e7d50b06ca604760ae921a24f6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa5e7d50b06ca604760ae921a24f6af">&#9670;&nbsp;</a></span>populateVectorSlicesLoweringPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorSlicesLoweringPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of vector slices transformation patterns: ExtractSlicesOpLowering, InsertSlicesOpLowering Useful for clients that want to express all vector "slices" ops in terms of more elementary vector "slice" ops. </p>
<p>If all "produced" tuple values are "consumed" (the most common use for "slices" ops), this lowering removes all tuple related operations as well (through DCE and folding). If tuple values "leak" coming in, however, some tuple related ops will remain. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02449">2449</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00454">mlir::OwningRewritePatternList::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l01443">mlir::populateVectorToLLVMMatrixConversionPatterns()</a>.</p>

</div>
</div>
<a id="ae655dbb6a41b5f172d8109454dbef224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae655dbb6a41b5f172d8109454dbef224">&#9670;&nbsp;</a></span>populateVectorToVectorCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorToVectorCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of vector-to-vector canonicalization patterns. </p>

<p class="definition">Definition at line <a class="el" href="VectorOps_8cpp_source.html#l02395">2395</a> of file <a class="el" href="VectorOps_8cpp_source.html">VectorOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00454">mlir::OwningRewritePatternList::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l01443">mlir::populateVectorToLLVMMatrixConversionPatterns()</a>.</p>

</div>
</div>
<a id="a7605f60776cd8da648480ef5783fe18e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7605f60776cd8da648480ef5783fe18e">&#9670;&nbsp;</a></span>populateVectorToVectorTransformationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::vector::populateVectorToVectorTransformationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of vector-to-vector transformation patterns. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02438">2438</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00454">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="aea008e69d7dd969b5e885803b759a338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea008e69d7dd969b5e885803b759a338">&#9670;&nbsp;</a></span>splitFullAndPartialTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::vector::splitFullAndPartialTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorTransferOpInterface&#160;</td>
          <td class="paramname"><em>xferOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmlir_1_1vector_1_1VectorTransformsOptions.html">VectorTransformsOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scf::IfOp *&#160;</td>
          <td class="paramname"><em>ifOp</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a vector.transfer operation into an unmasked fastpath and a slowpath. </p>
<p>If <code>ifOp</code> is not null and the result is <code>success, the</code>ifOp` points to the newly created conditional upon function return. To accomodate for the fact that the original vector.transfer indexing may be arbitrary and the slow path indexes @[0...0] in the temporary buffer, the scf.if op returns a view and values of type index. At this time, only vector.transfer_read case is implemented.</p>
<p>Example (a 2-D vector.transfer_read): ``` %1 = vector.transfer_read %0[...], pad : memref&lt;A...&gt;, vector&lt;...&gt; ``` is transformed into: ``` %1:3 = scf.if (inBounds) { // fastpath, direct cast memref_cast A: memref&lt;A...&gt; to compatibleMemRefType scf.yield view : compatibleMemRefType, index, index } else { // slowpath, masked vector.transfer or linalg.copy. memref_cast alloc: memref&lt;B...&gt; to compatibleMemRefType scf.yield %4 : compatibleMemRefType, index, index */ // } /** %0 = vector.transfer_read %1#0[%1#1, %1#2] {masked = [false ... false]} ``<code> where</code>alloc` is a top of the function alloca'ed buffer of one vector.</p>
<p>Preconditions:</p><ol type="1">
<li><code>xferOp.permutation_map()</code> must be a minor identity map</li>
<li>the rank of the <code>xferOp.memref()</code> and the rank of the <code>xferOp.vector()</code> must be equal. This will be relaxed in the future but requires rank-reducing subviews. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02348">2348</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00328">mlir::Type::cast()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02225">createScopedFullPartialLinalgCopy()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02279">createScopedFullPartialVectorTransferRead()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02092">createScopedInBoundsCond()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00379">mlir::MemRefType::get()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00221">mlir::Builder::getBoolArrayAttr()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02145">getCastCompatibleMemRefType()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00102">mlir::Builder::getI64IntegerAttr()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00053">mlir::Builder::getIndexType()</a>, <a class="el" href="OpDefinition_8h_source.html#l00112">mlir::OpState::getParentOfType()</a>, <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>, <a class="el" href="StandardTypes_8h_source.html#l00063">mlir::StandardTypes::None</a>, <a class="el" href="IR_2Builders_8h_source.html#l00312">mlir::OpBuilder::setInsertionPoint()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00326">mlir::OpBuilder::setInsertionPointAfter()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00331">mlir::OpBuilder::setInsertionPointToStart()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02117">splitFullAndPartialTransferPrecondition()</a>, <a class="el" href="LogicalResult_8h_source.html#l00040">mlir::succeeded()</a>, <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>, and <a class="el" href="VectorOps_8h_source.html#l00096">mlir::vector::VectorTransformsOptions::vectorTransferSplit</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8h_source.html#l00083">mlir::vector::UnrollVectorPattern&lt; OpTy &gt;::matchAndRewrite()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02421">mlir::vector::VectorTransferFullPartialRewriter::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a2b1dd46b0167a6584fc56b4ac45a1c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1dd46b0167a6584fc56b4ac45a1c1a">&#9670;&nbsp;</a></span>splitFullAndPartialTransferPrecondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::vector::splitFullAndPartialTransferPrecondition </td>
          <td>(</td>
          <td class="paramtype">VectorTransferOpInterface&#160;</td>
          <td class="paramname"><em>xferOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a vector.transfer operation into an unmasked fastpath and a slowpath. </p>
<p>If <code>ifOp</code> is not null and the result is <code>success, the</code>ifOp` points to the newly created conditional upon function return. To accomodate for the fact that the original vector.transfer indexing may be arbitrary and the slow path indexes @[0...0] in the temporary buffer, the scf.if op returns a view and values of type index. At this time, only vector.transfer_read case is implemented.</p>
<p>Example (a 2-D vector.transfer_read): ``` %1 = vector.transfer_read %0[...], pad : memref&lt;A...&gt;, vector&lt;...&gt; ``` is transformed into: ``` %1:3 = scf.if (inBounds) { // fastpath, direct cast memref_cast A: memref&lt;A...&gt; to compatibleMemRefType scf.yield view : compatibleMemRefType, index, index } else { // slowpath, masked vector.transfer or linalg.copy. memref_cast alloc: memref&lt;B...&gt; to compatibleMemRefType scf.yield %4 : compatibleMemRefType, index, index */ // } /** %0 = vector.transfer_read %1#0[%1#1, %1#2] {masked = [false ... false]} ``<code> where</code>alloc` is a top of the function alloca'ed buffer of one vector.</p>
<p>Preconditions:</p><ol type="1">
<li><code>xferOp.permutation_map()</code> must be a minor identity map</li>
<li>the rank of the <code>xferOp.memref()</code> and the rank of the <code>xferOp.vector()</code> must be equal. This will be relaxed in the future but requires rank-reducing subviews. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02117">2117</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8h_source.html#l00083">mlir::vector::UnrollVectorPattern&lt; OpTy &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02421">mlir::vector::VectorTransferFullPartialRewriter::matchAndRewrite()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02348">splitFullAndPartialTransfer()</a>.</p>

</div>
</div>
<a id="a933ea17a5014ac296886e5262506d389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933ea17a5014ac296886e5262506d389">&#9670;&nbsp;</a></span>unrollSingleResultVectorOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 1 &gt; mlir::vector::unrollSingleResultVectorOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>targetShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry point for unrolling declarative pattern rewrites. </p>
<p><code>op</code> is unrolled to the <code>targetShape</code> as follows, for each of its operands:</p><ol type="1">
<li>the unrolled type <code>unrolledVectorType</code> and number of unrolled instances <code>numUnrolledInstances</code> are computed from the <code>targetShape</code>. For now it is assumed the unrolling factors divide the vector sizes.</li>
<li>a fakeFork cast op is inserted that takes the operand and returns <code>numUnrolledInstances</code> results of type <code>unrolledVectorType</code>.</li>
<li>the original op is cloned <code>numUnrolledInstances</code> times, once for each result of the fakeFork cast op.</li>
<li>a fakeJoin cast op takes all these results and merges them into a single aggregate vector result whose size matches the original non-unrolled op operand types.</li>
</ol>
<p>Example:</p>
<p>opA(operand0, operand1) // numUnrolledInstances = 3 </p><pre class="fragment">    operand0                   operand1
       |                          |
     fork                       fork
&lt;----------gather all fork ops ---------&gt;
      /|\                        /|\
  f00 f01 f02                f10 f11 f12
&lt;---------- clone op 3 times ---------&gt;
  opA0(f00, f10), opA1(f01, f11), opA2(f02, f12)
         \            |            /
</pre><p> &lt;-----------------&mdash; join ----------------------&mdash;&gt;</p>
<p>Other local patterns then kick in iteratively (including DCE) and compose until all the fakeFork and fakeJoin ops are removed.</p>
<p>This will be extended in the future to support more advanced use cases than simple pointwise ops. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l00515">515</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8cpp_source.html#l00540">mlir::Operation::getNumResults()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00457">getVectorContractionOpUnrollState()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00486">getVectorElementwiseOpUnrollState()</a>, <a class="el" href="Operator_8cpp_source.html#l00265">resultIndex()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l00367">unrollSingleResultStructuredOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8h_source.html#l00083">mlir::vector::UnrollVectorPattern&lt; OpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Aug 8 2020 16:27:21 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
