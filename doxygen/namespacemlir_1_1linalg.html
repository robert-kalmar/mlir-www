<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::linalg Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">12.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1linalg.html">linalg</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::linalg Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1AffineMinSCFCanonicalizationPattern.html">AffineMinSCFCanonicalizationPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize AffineMinOp operations in the context of enclosing scf.for and scf.parallel by:  <a href="structmlir_1_1linalg_1_1AffineMinSCFCanonicalizationPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1Aliases.html">Aliases</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A very primitive alias analysis which just records for each view, either:  <a href="classmlir_1_1linalg_1_1Aliases.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1GenerateLoopNest.html">GenerateLoopNest</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class used to generate nested loops with ranges described by <code>loopRanges</code> and loop type described by the <code>iteratorTypes</code>.  <a href="structmlir_1_1linalg_1_1GenerateLoopNest.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgBaseInterchangePattern.html">LinalgBaseInterchangePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg interchange patterns.  <a href="structmlir_1_1linalg_1_1LinalgBaseInterchangePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgBasePromotionPattern.html">LinalgBasePromotionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg promotion patterns.  <a href="structmlir_1_1linalg_1_1LinalgBasePromotionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgBaseTilingPattern.html">LinalgBaseTilingPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgBaseVectorizationPattern.html">LinalgBaseVectorizationPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg vectorization patterns.  <a href="structmlir_1_1linalg_1_1LinalgBaseVectorizationPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgCopyVTRForwardingPattern.html">LinalgCopyVTRForwardingPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match and rewrite for the pattern: ``` alloc = ...  <a href="structmlir_1_1linalg_1_1LinalgCopyVTRForwardingPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgCopyVTWForwardingPattern.html">LinalgCopyVTWForwardingPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match and rewrite for the pattern: ``` alloc = ...  <a href="structmlir_1_1linalg_1_1LinalgCopyVTWForwardingPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for holding a dependence graph that operates on LinalgOp and views as SSA values.  <a href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgInterchangePattern.html">LinalgInterchangePattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgLoweringPattern.html">LinalgLoweringPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgMarker.html">LinalgMarker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to control common attribute matching and setting behavior.  <a href="structmlir_1_1linalg_1_1LinalgMarker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionPattern.html">LinalgPromotionPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTilingPattern.html">LinalgTilingPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTransforms.html">LinalgTransforms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgVectorizationPattern.html">LinalgVectorizationPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1linalg_1_1RangeType.html">RangeType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1linalg_1_1RangeType.html" title="A RangeType represents a minimal range abstraction (min, max, step). ">RangeType</a> represents a minimal range abstraction (min, max, step).  <a href="classmlir_1_1linalg_1_1RangeType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1RegionMatcher.html">RegionMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct containing common matchers over linalg op's region.  <a href="structmlir_1_1linalg_1_1RegionMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab69975b2f4b34a10326a9b5535288ce6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab69975b2f4b34a10326a9b5535288ce6">ReassociationIndices</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 2 &gt;</td></tr>
<tr class="separator:ab69975b2f4b34a10326a9b5535288ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e7a7d808d207697fcd133ff4c46eed"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab4e7a7d808d207697fcd133ff4c46eed">ReassociationExprs</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2 &gt;</td></tr>
<tr class="separator:ab4e7a7d808d207697fcd133ff4c46eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9ca79033211e3e53e0eb25a8e9551b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, 4 &gt;</td></tr>
<tr class="separator:a4a9ca79033211e3e53e0eb25a8e9551b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6225c1f06228d3cabaf5367e60659b80"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6225c1f06228d3cabaf5367e60659b80">AllocBufferCallbackFn</a> = std::function&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, SubViewOp subView, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; boundingSubViewSize, <a class="el" href="classmlir_1_1OperationFolder.html">OperationFolder</a> *folder)&gt;</td></tr>
<tr class="memdesc:a6225c1f06228d3cabaf5367e60659b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to perform the allocation for the promoted <code>subView</code>.  <a href="#a6225c1f06228d3cabaf5367e60659b80">More...</a><br /></td></tr>
<tr class="separator:a6225c1f06228d3cabaf5367e60659b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7afb284c4be072a74a24eeb71cc985"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3d7afb284c4be072a74a24eeb71cc985">DeallocBufferCallbackFn</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> buffer)&gt;</td></tr>
<tr class="memdesc:a3d7afb284c4be072a74a24eeb71cc985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to deallocate the buffers used to hold the promoted subview.  <a href="#a3d7afb284c4be072a74a24eeb71cc985">More...</a><br /></td></tr>
<tr class="separator:a3d7afb284c4be072a74a24eeb71cc985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49994e2aab61b35167972384684cf24"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa49994e2aab61b35167972384684cf24">CopyCallbackFn</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dst)&gt;</td></tr>
<tr class="memdesc:aa49994e2aab61b35167972384684cf24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to insert copy from original subview to subview of the promoted region for the read operands/subview of promoted region to original subview for the results.  <a href="#aa49994e2aab61b35167972384684cf24">More...</a><br /></td></tr>
<tr class="separator:aa49994e2aab61b35167972384684cf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730df0415b8172eb93f8f7b346e04440"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a730df0415b8172eb93f8f7b346e04440">TileSizeComputationFunction</a> = std::function&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td></tr>
<tr class="separator:a730df0415b8172eb93f8f7b346e04440"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac9613122414870acb3dff8d9c3f0cdc2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac9613122414870acb3dff8d9c3f0cdc2">LinalgTypes</a> { <a class="el" href="namespacemlir_1_1linalg.html#ac9613122414870acb3dff8d9c3f0cdc2af0717f3c7e6eb317e4f21bef7d082962">Range</a> = Type::FIRST_LINALG_TYPE, 
<a class="el" href="namespacemlir_1_1linalg.html#ac9613122414870acb3dff8d9c3f0cdc2a4cafd9a3987bd859b625a54f6e20a68d">LAST_USED_LINALG_TYPE</a> = Range
 }</td></tr>
<tr class="separator:ac9613122414870acb3dff8d9c3f0cdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdd229e1459c7e6ed2f9c7ee7168325"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325">LinalgTilingLoopType</a> { <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325a4b2257cb98694284507e77f34e73c2d8">LinalgTilingLoopType::Loops</a> = 0, 
<a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325a6d8bf0bdeaca5ef4693524bf04c4c877">LinalgTilingLoopType::AffineLoops</a> = 1, 
<a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325ab92546344b4e3fa9b10c9472795297a7">LinalgTilingLoopType::ParallelLoops</a> = 2
 }<tr class="memdesc:a3cdd229e1459c7e6ed2f9c7ee7168325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg tiling patterns.  <a href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3cdd229e1459c7e6ed2f9c7ee7168325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98153087b663d0d7aa3ab0685cfaedaf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedaf">LinalgLoweringType</a> { <a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedafaaf6ba7cc968a74a4d611c3ab0148b33c">LinalgLoweringType::LibraryCall</a> = 0, 
<a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedafa4b2257cb98694284507e77f34e73c2d8">LinalgLoweringType::Loops</a> = 1, 
<a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedafa6d8bf0bdeaca5ef4693524bf04c4c877">LinalgLoweringType::AffineLoops</a> = 2, 
<a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedafab92546344b4e3fa9b10c9472795297a7">LinalgLoweringType::ParallelLoops</a> = 3
 }<tr class="memdesc:a98153087b663d0d7aa3ab0685cfaedaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg lowering patterns.  <a href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedaf">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a98153087b663d0d7aa3ab0685cfaedaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a754ec5c5960c640563ddcd9727b77d87"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a754ec5c5960c640563ddcd9727b77d87">generateLibraryCallName</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a754ec5c5960c640563ddcd9727b77d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name mangled library call name to disambiguate between different overloads at the C level.  <a href="#a754ec5c5960c640563ddcd9727b77d87">More...</a><br /></td></tr>
<tr class="separator:a754ec5c5960c640563ddcd9727b77d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962a46fba2ac497e30bb6d23fef35d1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a962a46fba2ac497e30bb6d23fef35d1a">makeAffineDimExprs</a> (unsigned num, unsigned &amp;startIdx, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a962a46fba2ac497e30bb6d23fef35d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>num</code> <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression. ">AffineDimExpr</a> dimensions at positions [startIdx, startIdx + num) and increments <code>startIdx</code> to <code>startIdx + num</code>.  <a href="#a962a46fba2ac497e30bb6d23fef35d1a">More...</a><br /></td></tr>
<tr class="separator:a962a46fba2ac497e30bb6d23fef35d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5dd029acdda95eeb6887d0e169bcbb5"><td class="memTemplParams" colspan="2">template&lt;typename PoolingOp &gt; </td></tr>
<tr class="memitem:ab5dd029acdda95eeb6887d0e169bcbb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab5dd029acdda95eeb6887d0e169bcbb5">weightedPoolingInputIndex</a> (PoolingOp op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; outputDims, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; windowDims)</td></tr>
<tr class="memdesc:ab5dd029acdda95eeb6887d0e169bcbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the indexing expressions for a ConvOp/PoolingOp <code>op</code>.  <a href="#ab5dd029acdda95eeb6887d0e169bcbb5">More...</a><br /></td></tr>
<tr class="separator:ab5dd029acdda95eeb6887d0e169bcbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddca37c4e3bf09cb06fc5197380bde3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6ddca37c4e3bf09cb06fc5197380bde3">extractOrIdentityMap</a> (<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maybeMap, unsigned rank, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a6ddca37c4e3bf09cb06fc5197380bde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>maybeMap.get()</code> if <code>maybeMap</code> is set, otherwise returns the symbol-less identity map of <code>rank</code>.  <a href="#a6ddca37c4e3bf09cb06fc5197380bde3">More...</a><br /></td></tr>
<tr class="separator:a6ddca37c4e3bf09cb06fc5197380bde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8ea0aae80d24eeffa3fef8f1f08c43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4f8ea0aae80d24eeffa3fef8f1f08c43">concat</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; a, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; b)</td></tr>
<tr class="memdesc:a4f8ea0aae80d24eeffa3fef8f1f08c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector that is the concatenation of <code>a</code> and <code>b</code>.  <a href="#a4f8ea0aae80d24eeffa3fef8f1f08c43">More...</a><br /></td></tr>
<tr class="separator:a4f8ea0aae80d24eeffa3fef8f1f08c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca3e5737cb6287861d9315999de8e75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1ca3e5737cb6287861d9315999de8e75">hoistViewAllocOps</a> (<a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> func)</td></tr>
<tr class="memdesc:a1ca3e5737cb6287861d9315999de8e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoist alloc/dealloc pairs and alloca op out of immediately enclosing scf::ForOp if both conditions are true:  <a href="#a1ca3e5737cb6287861d9315999de8e75">More...</a><br /></td></tr>
<tr class="separator:a1ca3e5737cb6287861d9315999de8e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc911548f9f0328faf5855ab880e7bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#afbc911548f9f0328faf5855ab880e7bc">hoistRedundantVectorTransfers</a> (<a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> func)</td></tr>
<tr class="memdesc:afbc911548f9f0328faf5855ab880e7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoist vector.transfer_read/vector.transfer_write pairs out of immediately enclosing scf::ForOp iteratively, if the following conditions are true:  <a href="#afbc911548f9f0328faf5855ab880e7bc">More...</a><br /></td></tr>
<tr class="separator:afbc911548f9f0328faf5855ab880e7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2efdb9223f206f2d1f8f8ee6b27564f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab2efdb9223f206f2d1f8f8ee6b27564f">tileLinalgOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp op, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memdesc:ab2efdb9223f206f2d1f8f8ee6b27564f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs standalone tiling of a single LinalgOp by <code>tileSizes</code>.  <a href="#ab2efdb9223f206f2d1f8f8ee6b27564f">More...</a><br /></td></tr>
<tr class="separator:ab2efdb9223f206f2d1f8f8ee6b27564f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3b16ee2227dad39c6771069df37e34"><td class="memItemLeft" align="right" valign="top">LinalgOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3d3b16ee2227dad39c6771069df37e34">interchange</a> (LinalgOp op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt; interchangeVector)</td></tr>
<tr class="memdesc:a3d3b16ee2227dad39c6771069df37e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interchanges the <code>iterator_types</code> and <code>iterator_maps</code> dimensions of <code>op</code>.  <a href="#a3d3b16ee2227dad39c6771069df37e34">More...</a><br /></td></tr>
<tr class="separator:a3d3b16ee2227dad39c6771069df37e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea396843a4c8fce5aa96c6d49a483661"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; LinalgOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aea396843a4c8fce5aa96c6d49a483661">promoteSubViews</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp op, <a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>, <a class="el" href="classmlir_1_1OperationFolder.html">OperationFolder</a> *folder=nullptr)</td></tr>
<tr class="memdesc:aea396843a4c8fce5aa96c6d49a483661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes the <code>subViews</code> into a new buffer allocated at the insertion point <code>b</code>.  <a href="#aea396843a4c8fce5aa96c6d49a483661">More...</a><br /></td></tr>
<tr class="separator:aea396843a4c8fce5aa96c6d49a483661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fae5d2ec66e658cbabd89ea5c15a5ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3fae5d2ec66e658cbabd89ea5c15a5ef">vectorizeLinalgOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a3fae5d2ec66e658cbabd89ea5c15a5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a suitable vector form for a Linalg op with fully static shape.  <a href="#a3fae5d2ec66e658cbabd89ea5c15a5ef">More...</a><br /></td></tr>
<tr class="separator:a3fae5d2ec66e658cbabd89ea5c15a5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f06d90d0f4f8c54740c7387cc7a566a"><td class="memTemplParams" colspan="2">template&lt;typename LoopTy &gt; </td></tr>
<tr class="memitem:a6f06d90d0f4f8c54740c7387cc7a566a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6f06d90d0f4f8c54740c7387cc7a566a">linalgLowerOpToLoops</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a6f06d90d0f4f8c54740c7387cc7a566a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a loop nest of <code>LoopTy</code> with the proper body for <code>op</code>.  <a href="#a6f06d90d0f4f8c54740c7387cc7a566a">More...</a><br /></td></tr>
<tr class="separator:a6f06d90d0f4f8c54740c7387cc7a566a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86639658ec94ada14e3a8569b62c5322"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a86639658ec94ada14e3a8569b62c5322">linalgOpToLoops</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a86639658ec94ada14e3a8569b62c5322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a loop nest of <code>scf.for</code> with the proper body for <code>op</code>.  <a href="#a86639658ec94ada14e3a8569b62c5322">More...</a><br /></td></tr>
<tr class="separator:a86639658ec94ada14e3a8569b62c5322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab13dd380c27183fb9cec5d731eacc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5ab13dd380c27183fb9cec5d731eacc9">linalgOpToParallelLoops</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a5ab13dd380c27183fb9cec5d731eacc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a loop nest of <code>scf.parallel</code> with the proper body for <code>op</code>.  <a href="#a5ab13dd380c27183fb9cec5d731eacc9">More...</a><br /></td></tr>
<tr class="separator:a5ab13dd380c27183fb9cec5d731eacc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b1ea88640f72268964910f4e170c2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a65b1ea88640f72268964910f4e170c2b">linalgOpToAffineLoops</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a65b1ea88640f72268964910f4e170c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a loop nest of <code>affine.for</code> with the proper body for <code>op</code>.  <a href="#a65b1ea88640f72268964910f4e170c2b">More...</a><br /></td></tr>
<tr class="separator:a65b1ea88640f72268964910f4e170c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b9fae0d74c3d13d7612c73ea66c7c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae8b9fae0d74c3d13d7612c73ea66c7c0">interchangeGenericLinalgOpPrecondition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt; interchangeVector)</td></tr>
<tr class="memdesc:ae8b9fae0d74c3d13d7612c73ea66c7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits a <code>generic</code> or <code>indexed_generic</code> operation with the <code>indexing_maps</code> and <code>iterator_types</code> permutated according to <code>permutation</code>.  <a href="#ae8b9fae0d74c3d13d7612c73ea66c7c0">More...</a><br /></td></tr>
<tr class="separator:ae8b9fae0d74c3d13d7612c73ea66c7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850b9fd11404efe17bca02011aff2e88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a850b9fd11404efe17bca02011aff2e88">promoteSubviewsPrecondition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memdesc:a850b9fd11404efe17bca02011aff2e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote std.subviews feeding linalg operations.  <a href="#a850b9fd11404efe17bca02011aff2e88">More...</a><br /></td></tr>
<tr class="separator:a850b9fd11404efe17bca02011aff2e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434bd78a651f6a42d01090db72bc039c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a434bd78a651f6a42d01090db72bc039c">vectorizeLinalgOpPrecondition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a434bd78a651f6a42d01090db72bc039c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a linalg.generic into a suitable vector.contraction op.  <a href="#a434bd78a651f6a42d01090db72bc039c">More...</a><br /></td></tr>
<tr class="separator:a434bd78a651f6a42d01090db72bc039c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4bbb94eb4bb91c171a4eec22374453"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6c4bbb94eb4bb91c171a4eec22374453">getLinalgTilingCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:a6c4bbb94eb4bb91c171a4eec22374453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalization patterns relevant to apply after tiling patterns.  <a href="#a6c4bbb94eb4bb91c171a4eec22374453">More...</a><br /></td></tr>
<tr class="separator:a6c4bbb94eb4bb91c171a4eec22374453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4076b314e281fa215bfcba6d36cc4979"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4076b314e281fa215bfcba6d36cc4979">applyStagedPatterns</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &gt; stage1Patterns, const <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;stage2Patterns, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; stage3Lambda=nullptr)</td></tr>
<tr class="memdesc:a4076b314e281fa215bfcba6d36cc4979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to allow applying rewrite patterns, interleaved with more global transformations, in a staged fashion:  <a href="#a4076b314e281fa215bfcba6d36cc4979">More...</a><br /></td></tr>
<tr class="separator:a4076b314e281fa215bfcba6d36cc4979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9742d07020a6835f7a1855ef4f81c294"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a9742d07020a6835f7a1855ef4f81c294">isParallelIteratorType</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:a9742d07020a6835f7a1855ef4f81c294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an iterator_type attribute is parallel.  <a href="#a9742d07020a6835f7a1855ef4f81c294">More...</a><br /></td></tr>
<tr class="separator:a9742d07020a6835f7a1855ef4f81c294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bde6d8fa6533d77b1d706654f0f963"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af7bde6d8fa6533d77b1d706654f0f963">isReductionIteratorType</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:af7bde6d8fa6533d77b1d706654f0f963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an iterator_type attribute is parallel.  <a href="#af7bde6d8fa6533d77b1d706654f0f963">More...</a><br /></td></tr>
<tr class="separator:af7bde6d8fa6533d77b1d706654f0f963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ecab0d508abda7349407fa91a3b47e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad0ecab0d508abda7349407fa91a3b47e">isWindowIteratorType</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:ad0ecab0d508abda7349407fa91a3b47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an iterator_type attribute is parallel.  <a href="#ad0ecab0d508abda7349407fa91a3b47e">More...</a><br /></td></tr>
<tr class="separator:ad0ecab0d508abda7349407fa91a3b47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2959f54ccc7cabc35c9337f50c0734"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1a2959f54ccc7cabc35c9337f50c0734">isProducerLastWriteOfView</a> (const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;graph, LinalgOp consumer, <a class="el" href="classmlir_1_1Value.html">Value</a> consumedView, LinalgOp producer)</td></tr>
<tr class="memdesc:a1a2959f54ccc7cabc35c9337f50c0734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the specific <code>producer</code> is the last write to exactly the whole <code>consumedView</code>.  <a href="#a1a2959f54ccc7cabc35c9337f50c0734">More...</a><br /></td></tr>
<tr class="separator:a1a2959f54ccc7cabc35c9337f50c0734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf6605778cf3f93537f2bc2e58da089"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6bf6605778cf3f93537f2bc2e58da089">isFusableInto</a> (const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;graph, LinalgOp consumer, <a class="el" href="classmlir_1_1Value.html">Value</a> consumedView, LinalgOp producer)</td></tr>
<tr class="memdesc:a6bf6605778cf3f93537f2bc2e58da089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether fusing the specific <code>producer</code> of the <code>consumedView</code> is feasible.  <a href="#a6bf6605778cf3f93537f2bc2e58da089">More...</a><br /></td></tr>
<tr class="separator:a6bf6605778cf3f93537f2bc2e58da089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af050b6d2e1be6276cf335f9306756733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af050b6d2e1be6276cf335f9306756733">fuseProducerOf</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp consumer, unsigned consumerIdx, const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;graph, <a class="el" href="classmlir_1_1OperationFolder.html">OperationFolder</a> *folder=nullptr)</td></tr>
<tr class="memdesc:af050b6d2e1be6276cf335f9306756733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuses producer into consumer if the producer is structurally feasible and the fusion would not violate dependencies.  <a href="#af050b6d2e1be6276cf335f9306756733">More...</a><br /></td></tr>
<tr class="separator:af050b6d2e1be6276cf335f9306756733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e9e5220d6ab9d3d9470aa320615bc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa6e9e5220d6ab9d3d9470aa320615bc1">fuseTensorOps</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *consumer, unsigned consumerIdx, <a class="el" href="classmlir_1_1OperationFolder.html">OperationFolder</a> *folder=nullptr)</td></tr>
<tr class="memdesc:aa6e9e5220d6ab9d3d9470aa320615bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse linalg operation on tensors, with the producer of the operand at position <code>consumerIdx</code> of the consumer.  <a href="#aa6e9e5220d6ab9d3d9470aa320615bc1">More...</a><br /></td></tr>
<tr class="separator:aa6e9e5220d6ab9d3d9470aa320615bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65179f11612f61a4f257487f60d81453"><td class="memTemplParams" colspan="2">template&lt;typename ConcreteOp &gt; </td></tr>
<tr class="memitem:a65179f11612f61a4f257487f60d81453"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a65179f11612f61a4f257487f60d81453">getViewSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, ConcreteOp linalgOp)</td></tr>
<tr class="memdesc:a65179f11612f61a4f257487f60d81453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the linearized list of all view dimensions in a linalgOp.  <a href="#a65179f11612f61a4f257487f60d81453">More...</a><br /></td></tr>
<tr class="separator:a65179f11612f61a4f257487f60d81453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd73a2c82ab8673262388ee9bca43df3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#abd73a2c82ab8673262388ee9bca43df3">applyMapToValues</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values, <a class="el" href="classmlir_1_1OperationFolder.html">OperationFolder</a> *folder=nullptr)</td></tr>
<tr class="memdesc:abd73a2c82ab8673262388ee9bca43df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the values obtained by applying <code>map</code> to the list of values.  <a href="#abd73a2c82ab8673262388ee9bca43df3">More...</a><br /></td></tr>
<tr class="separator:abd73a2c82ab8673262388ee9bca43df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81fb08b3c22666b55ac3be6f7a33ff5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a81fb08b3c22666b55ac3be6f7a33ff5a">getAssumedNonViewOperands</a> (LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a81fb08b3c22666b55ac3be6f7a33ff5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns all the operands of <code>linalgOp</code> that are not views.  <a href="#a81fb08b3c22666b55ac3be6f7a33ff5a">More...</a><br /></td></tr>
<tr class="separator:a81fb08b3c22666b55ac3be6f7a33ff5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21c196847c314c07d222ce3f6bdaa8c"><td class="memTemplParams" colspan="2">template&lt;typename T , unsigned N&gt; </td></tr>
<tr class="memitem:ad21c196847c314c07d222ce3f6bdaa8c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad21c196847c314c07d222ce3f6bdaa8c">applyPermutationToVector</a> (<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T, N &gt; &amp;inVec, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt; permutation)</td></tr>
<tr class="memdesc:ad21c196847c314c07d222ce3f6bdaa8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the permutation defined by <code>permutation</code> to <code>inVec</code>.  <a href="#ad21c196847c314c07d222ce3f6bdaa8c">More...</a><br /></td></tr>
<tr class="separator:ad21c196847c314c07d222ce3f6bdaa8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51834180e9802f949e5a880bf0ba5851"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a51834180e9802f949e5a880bf0ba5851">generateParallelLoopNest</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> steps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; iteratorTypes, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilderFn, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;ivStorage)</td></tr>
<tr class="memdesc:a51834180e9802f949e5a880bf0ba5851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a loop nest consisting of scf.parallel and scf.for, depending on the `iteratorTypes.  <a href="#a51834180e9802f949e5a880bf0ba5851">More...</a><br /></td></tr>
<tr class="separator:a51834180e9802f949e5a880bf0ba5851"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a6225c1f06228d3cabaf5367e60659b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6225c1f06228d3cabaf5367e60659b80">&#9670;&nbsp;</a></span>AllocBufferCallbackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a6225c1f06228d3cabaf5367e60659b80">mlir::linalg::AllocBufferCallbackFn</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;( <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, SubViewOp subView, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; boundingSubViewSize, <a class="el" href="classmlir_1_1OperationFolder.html">OperationFolder</a> *folder)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function type used to perform the allocation for the promoted <code>subView</code>. </p>
<p>In <code>boundingSubViewsize</code> a best attempt is made to find the smallest constant value for the size of the buffer needed for each dimension. If that is not possible, contains the dynamic size of the subview. The call back should return the buffer to use. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00069">69</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="aa49994e2aab61b35167972384684cf24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49994e2aab61b35167972384684cf24">&#9670;&nbsp;</a></span>CopyCallbackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#aa49994e2aab61b35167972384684cf24">mlir::linalg::CopyCallbackFn</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dst)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function type used to insert copy from original subview to subview of the promoted region for the read operands/subview of promoted region to original subview for the results. </p>
<p>The copy has to happen from <code>src</code> to <code>dst</code>. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00081">81</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a3d7afb284c4be072a74a24eeb71cc985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7afb284c4be072a74a24eeb71cc985">&#9670;&nbsp;</a></span>DeallocBufferCallbackFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a3d7afb284c4be072a74a24eeb71cc985">mlir::linalg::DeallocBufferCallbackFn</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> buffer)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function type used to deallocate the buffers used to hold the promoted subview. </p>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00074">74</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a4a9ca79033211e3e53e0eb25a8e9551b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9ca79033211e3e53e0eb25a8e9551b">&#9670;&nbsp;</a></span>LinalgLoops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">mlir::linalg::LinalgLoops</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00026">26</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="ab4e7a7d808d207697fcd133ff4c46eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e7a7d808d207697fcd133ff4c46eed">&#9670;&nbsp;</a></span>ReassociationExprs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#ab4e7a7d808d207697fcd133ff4c46eed">mlir::linalg::ReassociationExprs</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8h_source.html#l00039">39</a> of file <a class="el" href="LinalgOps_8h_source.html">LinalgOps.h</a>.</p>

</div>
</div>
<a id="ab69975b2f4b34a10326a9b5535288ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69975b2f4b34a10326a9b5535288ce6">&#9670;&nbsp;</a></span>ReassociationIndices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#ab69975b2f4b34a10326a9b5535288ce6">mlir::linalg::ReassociationIndices</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;int64_t, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LinalgOps_8h_source.html#l00038">38</a> of file <a class="el" href="LinalgOps_8h_source.html">LinalgOps.h</a>.</p>

</div>
</div>
<a id="a730df0415b8172eb93f8f7b346e04440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730df0415b8172eb93f8f7b346e04440">&#9670;&nbsp;</a></span>TileSizeComputationFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1linalg.html#a730df0415b8172eb93f8f7b346e04440">mlir::linalg::TileSizeComputationFunction</a> = typedef std::function&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, 4&gt;(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00236">236</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a98153087b663d0d7aa3ab0685cfaedaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98153087b663d0d7aa3ab0685cfaedaf">&#9670;&nbsp;</a></span>LinalgLoweringType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1linalg.html#a98153087b663d0d7aa3ab0685cfaedaf">mlir::linalg::LinalgLoweringType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linalg lowering patterns. </p>
<p>Apply the <code>linalgLowerOpToLoops</code> transformation as a pattern. <code>marker</code> controls LinalgTransformMarker matching and update when specified. See <code>linalgLowerOpToLoops</code> for more details. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a98153087b663d0d7aa3ab0685cfaedafaaf6ba7cc968a74a4d611c3ab0148b33c"></a>LibraryCall&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a98153087b663d0d7aa3ab0685cfaedafa4b2257cb98694284507e77f34e73c2d8"></a>Loops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a98153087b663d0d7aa3ab0685cfaedafa6d8bf0bdeaca5ef4693524bf04c4c877"></a>AffineLoops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a98153087b663d0d7aa3ab0685cfaedafab92546344b4e3fa9b10c9472795297a7"></a>ParallelLoops&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00399">399</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="a3cdd229e1459c7e6ed2f9c7ee7168325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cdd229e1459c7e6ed2f9c7ee7168325">&#9670;&nbsp;</a></span>LinalgTilingLoopType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1linalg.html#a3cdd229e1459c7e6ed2f9c7ee7168325">mlir::linalg::LinalgTilingLoopType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linalg tiling patterns. </p>
<p>Apply the <code>tileLinalgOp</code> transformation as a pattern. <code>marker</code> controls LinalgTransformMarker matching and update when specified. See <code>tileLinalgOp</code> for more details. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3cdd229e1459c7e6ed2f9c7ee7168325a4b2257cb98694284507e77f34e73c2d8"></a>Loops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3cdd229e1459c7e6ed2f9c7ee7168325a6d8bf0bdeaca5ef4693524bf04c4c877"></a>AffineLoops&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3cdd229e1459c7e6ed2f9c7ee7168325ab92546344b4e3fa9b10c9472795297a7"></a>ParallelLoops&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00230">230</a> of file <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html">Transforms.h</a>.</p>

</div>
</div>
<a id="ac9613122414870acb3dff8d9c3f0cdc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9613122414870acb3dff8d9c3f0cdc2">&#9670;&nbsp;</a></span>LinalgTypes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1linalg.html#ac9613122414870acb3dff8d9c3f0cdc2">mlir::linalg::LinalgTypes</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac9613122414870acb3dff8d9c3f0cdc2af0717f3c7e6eb317e4f21bef7d082962"></a>Range&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac9613122414870acb3dff8d9c3f0cdc2a4cafd9a3987bd859b625a54f6e20a68d"></a>LAST_USED_LINALG_TYPE&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="LinalgTypes_8h_source.html#l00019">19</a> of file <a class="el" href="LinalgTypes_8h_source.html">LinalgTypes.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="abd73a2c82ab8673262388ee9bca43df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd73a2c82ab8673262388ee9bca43df3">&#9670;&nbsp;</a></span>applyMapToValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt; mlir::linalg::applyMapToValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationFolder.html">OperationFolder</a> *&#160;</td>
          <td class="paramname"><em>folder</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the values obtained by applying <code>map</code> to the list of values. </p>
<p>When non-null, the optional pointer <code>folder</code> is used to call into the <code>createAndFold</code> builder method. If <code>folder</code> is null, the regular <code>create</code> method is called. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00069">69</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00058">emitOrFoldComposedAffineApply()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00807">mlir::AffineMap::get()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00203">mlir::AffineMap::getNumDims()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00211">mlir::AffineMap::getNumResults()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00207">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="AffineMap_8cpp_source.html#l00220">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Loops_8cpp_source.html#l00068">emitLoopRanges()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00101">getViewSizes()</a>, <a class="el" href="Tiling_8cpp_source.html#l00058">makeTiledLoopRanges()</a>, <a class="el" href="Tiling_8cpp_source.html#l00225">makeTiledViews()</a>, <a class="el" href="Loops_8cpp_source.html#l00053">permuteIvs()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00317">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="ad21c196847c314c07d222ce3f6bdaa8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad21c196847c314c07d222ce3f6bdaa8c">&#9670;&nbsp;</a></span>applyPermutationToVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , unsigned N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::applyPermutationToVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>inVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>permutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the permutation defined by <code>permutation</code> to <code>inVec</code>. </p>
<p>Element <code>i</code> in <code>inVec</code> is mapped to location <code>j = permutation[i]</code>. E.g.: for an input vector `inVec = ['a', 'b', 'c']<code>and a permutation vector </code>permutation = [2, 0, 1]<code>, this function leaves</code>inVec = ['c', 'a', 'b']`. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00151">151</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Interchange_8cpp_source.html#l00056">interchange()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00317">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="a4076b314e281fa215bfcba6d36cc4979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4076b314e281fa215bfcba6d36cc4979">&#9670;&nbsp;</a></span>applyStagedPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::applyStagedPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &gt;&#160;</td>
          <td class="paramname"><em>stage1Patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>stage2Patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>stage3Lambda</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to allow applying rewrite patterns, interleaved with more global transformations, in a staged fashion: </p>
<ol type="1">
<li>the first stage consists of a list of <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a>. Each <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> in this list is applied once, in order.</li>
<li>the second stage consists of a single OwningRewritePattern that is applied greedily until convergence.</li>
<li>the third stage consists of applying a lambda, generally used for non-local transformation effects. This allows creating custom fused transformations where patterns can be ordered and applied at a finer granularity than a sequence of traditional compiler passes. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Transforms_8cpp_source.html#l00209">209</a> of file <a class="el" href="Transforms_8cpp_source.html">Transforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00220">mlir::applyPatternsAndFoldGreedily()</a>, <a class="el" href="Transforms_8cpp_source.html#l00038">DBGS</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

</div>
</div>
<a id="a4f8ea0aae80d24eeffa3fef8f1f08c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8ea0aae80d24eeffa3fef8f1f08c43">&#9670;&nbsp;</a></span>concat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt; mlir::linalg::concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the vector that is the concatenation of <code>a</code> and <code>b</code>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l01110">1110</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Simplex_8cpp_source.html#l00513">mlir::Simplex::makeProduct()</a>.</p>

</div>
</div>
<a id="a6ddca37c4e3bf09cb06fc5197380bde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ddca37c4e3bf09cb06fc5197380bde3">&#9670;&nbsp;</a></span>extractOrIdentityMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::linalg::extractOrIdentityMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>maybeMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>maybeMap.get()</code> if <code>maybeMap</code> is set, otherwise returns the symbol-less identity map of <code>rank</code>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l01062">1062</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00807">mlir::AffineMap::get()</a>, and <a class="el" href="AffineMap_8cpp_source.html#l00167">mlir::AffineMap::getMultiDimIdentityMap()</a>.</p>

</div>
</div>
<a id="af050b6d2e1be6276cf335f9306756733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af050b6d2e1be6276cf335f9306756733">&#9670;&nbsp;</a></span>fuseProducerOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1FusionInfo.html">FusionInfo</a> &gt; mlir::linalg::fuseProducerOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>consumerIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationFolder.html">OperationFolder</a> *&#160;</td>
          <td class="paramname"><em>folder</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fuses producer into consumer if the producer is structurally feasible and the fusion would not violate dependencies. </p>
<p>When non-null, the optional pointer <code>folder</code> is used to call into the <code>createAndFold</code> builder method. If <code>folder</code> is null, the regular <code>create</code> method is called. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00377">377</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Fusion_8cpp_source.html#l00323">fuseProducerOfDep()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00392">fuseLinalgOpsGreedily()</a>.</p>

</div>
</div>
<a id="aa6e9e5220d6ab9d3d9470aa320615bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e9e5220d6ab9d3d9470aa320615bc1">&#9670;&nbsp;</a></span>fuseTensorOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * mlir::linalg::fuseTensorOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>consumerIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationFolder.html">OperationFolder</a> *&#160;</td>
          <td class="paramname"><em>folder</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fuse linalg operation on tensors, with the producer of the operand at position <code>consumerIdx</code> of the consumer. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00951">951</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00220">mlir::applyPatternsAndFoldGreedily()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00094">mlir::PatternRewriter::eraseOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="Fusion_8cpp_source.html#l00157">fuse()</a>, <a class="el" href="Fusion_8cpp_source.html#l00392">fuseLinalgOpsGreedily()</a>, <a class="el" href="Operation_8cpp_source.html#l00206">mlir::Operation::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>, <a class="el" href="Operation_8h_source.html#l00225">mlir::Operation::getNumOperands()</a>, <a class="el" href="Operation_8cpp_source.html#l00540">mlir::Operation::getNumResults()</a>, <a class="el" href="Operation_8h_source.html#l00229">mlir::Operation::getOperand()</a>, <a class="el" href="Operation_8h_source.html#l00400">mlir::Operation::getRegions()</a>, <a class="el" href="Operation_8h_source.html#l00283">mlir::Operation::getResults()</a>, <a class="el" href="Fusion_8cpp_source.html#l01030">mlir::populateLinalgTensorOpsFusionPatterns()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00080">mlir::PatternRewriter::replaceOp()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

</div>
</div>
<a id="a754ec5c5960c640563ddcd9727b77d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754ec5c5960c640563ddcd9727b77d87">&#9670;&nbsp;</a></span>generateLibraryCallName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlir::linalg::generateLibraryCallName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the name mangled library call name to disambiguate between different overloads at the C level. </p>
<p>The name mangling scheme is basic and uses MLIR type names:</p><ol type="1">
<li>form a string which is the concatenation of the linalg op name with all the operand type names, separate by underscores;</li>
<li>drop the <code>linalg.</code> prefix, and the <code>&lt;</code>, <code>&gt;</code>, <code>?</code> symbols from the type. Assumes <code>op</code> is a LinalgOp.</li>
</ol>
<p>Examples:</p>
<ol type="1">
<li>linalg.fill(A, f) : memref&lt;f32&gt;, f32 name mangles into <code>linalg_fill_viewf32_f32_impl</code></li>
<li>linalg.dot A, B, C : (memref&lt;?xf32, stride_specification&gt;, memref&lt;?xf32, stride_specification&gt;, memref&lt;f32&gt;) name mangles into <code>linalg_dot_viewxf32_viewxf32_viewf32_impl</code></li>
<li>linalg.matmul(...) : memref&lt;?x?xf32, stride_specification&gt;, memref&lt;?x?xf32, stride_specification&gt;, memref&lt;?x?xf32, stride_specification&gt; name mangles into <code>linalg_matmul_viewxxf32_viewxxf32_viewxxf32_impl</code> </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l01139">1139</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgOps_8cpp_source.html#l01118">appendMangledType()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00052">foldMemRefCast()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00398">foldReshapeOp()</a>, <a class="el" href="Operation_8h_source.html#l00057">mlir::Operation::getName()</a>, <a class="el" href="Operation_8h_source.html#l00265">mlir::Operation::getOperandTypes()</a>, <a class="el" href="Operation_8cpp_source.html#l00048">mlir::OperationName::getStringRef()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00040">mlir::succeeded()</a>.</p>

</div>
</div>
<a id="a51834180e9802f949e5a880bf0ba5851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51834180e9802f949e5a880bf0ba5851">&#9670;&nbsp;</a></span>generateParallelLoopNest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mlir::linalg::generateParallelLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>iteratorTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilderFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ivStorage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a loop nest consisting of scf.parallel and scf.for, depending on the `iteratorTypes. </p>
<p>` Consecutive parallel loops create a single scf.parallel operation; each sequential loop creates a new scf.for operation. The body of the innermost loop is populated by <code>bodyBuilderFn</code> that accepts a range of induction variables for all loops. <code>ivStorage</code> is used to store the partial list of induction variables. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00188">188</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00106">isParallelIteratorType()</a>, and <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html#l00018">mlir::edsc::loopNestBuilder()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00236">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>.</p>

</div>
</div>
<a id="a81fb08b3c22666b55ac3be6f7a33ff5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81fb08b3c22666b55ac3be6f7a33ff5a">&#9670;&nbsp;</a></span>getAssumedNonViewOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt; mlir::linalg::getAssumedNonViewOperands </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>linalgOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns all the operands of <code>linalgOp</code> that are not views. </p>
<p>Asserts that these operands are value types to allow transformations like tiling to just use the values when cloning <code>linalgOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00090">90</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00061">cloneWithLoopRanges()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00101">getViewSizes()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00317">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="a6c4bbb94eb4bb91c171a4eec22374453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4bbb94eb4bb91c171a4eec22374453">&#9670;&nbsp;</a></span>getLinalgTilingCanonicalizationPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> mlir::linalg::getLinalgTilingCanonicalizationPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalization patterns relevant to apply after tiling patterns. </p>
<p>These are applied automatically by the tiling pass but need to be applied manually when tiling is called programmatically. </p>

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00474">474</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tiling_8cpp_source.html#l00502">applyTilingToLoopPatterns()</a>, and <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00269">mlir::linalg::LinalgTilingOptions::setLoopType()</a>.</p>

</div>
</div>
<a id="a65179f11612f61a4f257487f60d81453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65179f11612f61a4f257487f60d81453">&#9670;&nbsp;</a></span>getViewSizes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, 8&gt; mlir::linalg::getViewSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConcreteOp&#160;</td>
          <td class="paramname"><em>linalgOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the linearized list of all view dimensions in a linalgOp. </p>
<p>Applying the inverse, concatenated loopToOperandRangeMaps to this list allows the derivation of loop ranges for any linalgOp. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00101">101</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00069">applyMapToValues()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00376">mlir::OpBuilder::create()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00090">getAssumedNonViewOperands()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Loops_8cpp_source.html#l00165">getInputAndOutputIndices()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00317">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="afbc911548f9f0328faf5855ab880e7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc911548f9f0328faf5855ab880e7bc">&#9670;&nbsp;</a></span>hoistRedundantVectorTransfers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::hoistRedundantVectorTransfers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoist vector.transfer_read/vector.transfer_write pairs out of immediately enclosing scf::ForOp iteratively, if the following conditions are true: </p>
<ol type="1">
<li>The two ops access the same memref with the same indices.</li>
<li>All operands are invariant under the enclosing scf::ForOp.</li>
<li>No uses of the memref either dominate the transfer_read or are dominated by the transfer_write (i.e. no aliasing between the write and the read across the loop) To improve hoisting opportunities, call the <code>moveLoopInvariantCode</code> helper function on the candidate loop above which to hoist. Hoisting the transfers results in scf::ForOp yielding the value that originally transited through memory. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Hoisting_8cpp_source.html#l00119">119</a> of file <a class="el" href="Hoisting_8cpp_source.html">Hoisting.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00044">mlir::WalkResult::advance()</a>, <a class="el" href="Dialect_2SCF_2Transforms_2Utils_8cpp_source.html#l00025">mlir::cloneWithNewYields()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00029">DBGS</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">mlir::failed()</a>, <a class="el" href="namespacemlir.html#ab3c9138cd38e82a78b5895b0e606d5d6">mlir::getForwardSlice()</a>, <a class="el" href="Visitors_8h_source.html#l00043">mlir::WalkResult::interrupt()</a>, <a class="el" href="Hoisting_8cpp_source.html#l00085">isDisjoint()</a>, <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html#l00078">mlir::moveLoopInvariantCode()</a>, <a class="el" href="Dominance_8cpp_source.html#l00222">mlir::DominanceInfo::properlyDominates()</a>, and <a class="el" href="OpDefinition_8h_source.html#l00218">mlir::OpState::walk()</a>.</p>

</div>
</div>
<a id="a1ca3e5737cb6287861d9315999de8e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca3e5737cb6287861d9315999de8e75">&#9670;&nbsp;</a></span>hoistViewAllocOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::hoistViewAllocOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoist alloc/dealloc pairs and alloca op out of immediately enclosing scf::ForOp if both conditions are true: </p>
<ol type="1">
<li>All operands are defined outside the loop.</li>
<li>All uses are ViewLikeOp or DeallocOp. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Hoisting_8cpp_source.html#l00036">36</a> of file <a class="el" href="Hoisting_8cpp_source.html">Hoisting.cpp</a>.</p>

<p class="reference">References <a class="el" href="Hoisting_8cpp_source.html#l00029">DBGS</a>, <a class="el" href="Operation_8cpp_source.html#l00540">mlir::Operation::getNumResults()</a>, <a class="el" href="Operation_8h_source.html#l00251">mlir::Operation::getOperands()</a>, <a class="el" href="Operation_8cpp_source.html#l00223">mlir::Operation::getParentOp()</a>, <a class="el" href="Operation_8h_source.html#l00275">mlir::Operation::getResult()</a>, <a class="el" href="Value_8h_source.html#l00183">mlir::Value::getUses()</a>, <a class="el" href="Operation_8cpp_source.html#l00503">mlir::Operation::moveAfter()</a>, and <a class="el" href="OpDefinition_8h_source.html#l00218">mlir::OpState::walk()</a>.</p>

</div>
</div>
<a id="a3d3b16ee2227dad39c6771069df37e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3b16ee2227dad39c6771069df37e34">&#9670;&nbsp;</a></span>interchange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LinalgOp mlir::linalg::interchange </td>
          <td>(</td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>interchangeVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interchanges the <code>iterator_types</code> and <code>iterator_maps</code> dimensions of <code>op</code>. </p>
<p>This is an in-place transformation controlled by <code>interchangeVector</code>. An empty vector is interpreted as the identity permutation and the transformation returns early.</p>
<p>E.g. the permutation <code>(i,j,k) -&gt; (j,k,i)</code> is expressed with <code>interchangeVector = [1,2,0]</code>. All values in <code>interchangeVector</code> must be integers, in the range 0..<code>op.rank</code> without duplications (i.e. <code>[1,1,2]</code> is an invalid permutation). </p>

<p class="definition">Definition at line <a class="el" href="Interchange_8cpp_source.html#l00056">56</a> of file <a class="el" href="Interchange_8cpp_source.html">Interchange.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html#l00151">applyPermutationToVector()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00307">mlir::AffineMap::compose()</a>, <a class="el" href="Attributes_8cpp_source.html#l00058">mlir::AffineMapAttr::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l00068">mlir::ArrayAttr::get()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00055">mlir::getIndexingMapsAttrName()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00059">mlir::getIteratorTypesAttrName()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00113">mlir::AffineMap::getPermutationMap()</a>, and <a class="el" href="AffineMap_8cpp_source.html#l00412">mlir::inversePermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Transforms_8cpp_source.html#l00142">mlir::linalg::LinalgBaseInterchangePattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ae8b9fae0d74c3d13d7612c73ea66c7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b9fae0d74c3d13d7612c73ea66c7c0">&#9670;&nbsp;</a></span>interchangeGenericLinalgOpPrecondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::interchangeGenericLinalgOpPrecondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>interchangeVector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits a <code>generic</code> or <code>indexed_generic</code> operation with the <code>indexing_maps</code> and <code>iterator_types</code> permutated according to <code>permutation</code>. </p>

<p class="definition">Definition at line <a class="el" href="Interchange_8cpp_source.html#l00035">35</a> of file <a class="el" href="Interchange_8cpp_source.html">Interchange.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="Operation_8cpp_source.html#l00206">mlir::Operation::getContext()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00113">mlir::AffineMap::getPermutationMap()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00412">mlir::inversePermutation()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Transforms_8cpp_source.html#l00142">mlir::linalg::LinalgBaseInterchangePattern::matchAndRewrite()</a>, and <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00147">mlir::linalg::LinalgPromotionOptions::setCopyInOutFns()</a>.</p>

</div>
</div>
<a id="a6bf6605778cf3f93537f2bc2e58da089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf6605778cf3f93537f2bc2e58da089">&#9670;&nbsp;</a></span>isFusableInto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isFusableInto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>consumedView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>producer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether fusing the specific <code>producer</code> of the <code>consumedView</code> is feasible. </p>
<p>This checks <code>producer</code> is the last write of <code>consumedView</code> and that no interleaved dependence would be violated (RAW, WAR or WAW). </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00265">265</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DependenceAnalysis_8cpp_source.html#l00192">mlir::linalg::LinalgDependenceGraph::findCoveringDependences()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00241">isProducerLastWriteOfView()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00323">fuseProducerOfDep()</a>.</p>

</div>
</div>
<a id="a9742d07020a6835f7a1855ef4f81c294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9742d07020a6835f7a1855ef4f81c294">&#9670;&nbsp;</a></span>isParallelIteratorType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isParallelIteratorType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an iterator_type attribute is parallel. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00106">106</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l01618">mlir::Attribute::dyn_cast()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00087">mlir::getParallelIteratorTypeName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00188">generateParallelLoopNest()</a>.</p>

</div>
</div>
<a id="a1a2959f54ccc7cabc35c9337f50c0734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2959f54ccc7cabc35c9337f50c0734">&#9670;&nbsp;</a></span>isProducerLastWriteOfView()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isProducerLastWriteOfView </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1linalg_1_1LinalgDependenceGraph.html">LinalgDependenceGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>consumedView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>producer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the specific <code>producer</code> is the last write to exactly the whole <code>consumedView</code>. </p>
<p>This checks structural dominance, that the dependence is a RAW without any interleaved write to any piece of <code>consumedView</code>. </p>

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00241">241</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DependenceAnalysis_8cpp_source.html#l00199">mlir::linalg::LinalgDependenceGraph::findCoveringWrites()</a>, and <a class="el" href="Fusion_8cpp_source.html#l00219">isStructurallyFusableProducer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Fusion_8cpp_source.html#l00265">isFusableInto()</a>.</p>

</div>
</div>
<a id="af7bde6d8fa6533d77b1d706654f0f963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bde6d8fa6533d77b1d706654f0f963">&#9670;&nbsp;</a></span>isReductionIteratorType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isReductionIteratorType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an iterator_type attribute is parallel. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00113">113</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l01618">mlir::Attribute::dyn_cast()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00094">mlir::getReductionIteratorTypeName()</a>.</p>

</div>
</div>
<a id="ad0ecab0d508abda7349407fa91a3b47e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ecab0d508abda7349407fa91a3b47e">&#9670;&nbsp;</a></span>isWindowIteratorType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::linalg::isWindowIteratorType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an iterator_type attribute is parallel. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00120">120</a> of file <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l01618">mlir::Attribute::dyn_cast()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00101">mlir::getWindowIteratorTypeName()</a>.</p>

</div>
</div>
<a id="a6f06d90d0f4f8c54740c7387cc7a566a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f06d90d0f4f8c54740c7387cc7a566a">&#9670;&nbsp;</a></span>linalgLowerOpToLoops()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LoopTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt; mlir::linalg::linalgLowerOpToLoops&lt; AffineForOp &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits a loop nest of <code>LoopTy</code> with the proper body for <code>op</code>. </p>
<p>Emits a loop nest with the proper body for <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00709">709</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00147">mlir::linalg::LinalgPromotionOptions::setCopyInOutFns()</a>.</p>

</div>
</div>
<a id="a65b1ea88640f72268964910f4e170c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b1ea88640f72268964910f4e170c2b">&#9670;&nbsp;</a></span>linalgOpToAffineLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::linalgOpToAffineLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits a loop nest of <code>affine.for</code> with the proper body for <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00725">725</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00412">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>, and <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00147">mlir::linalg::LinalgPromotionOptions::setCopyInOutFns()</a>.</p>

</div>
</div>
<a id="a86639658ec94ada14e3a8569b62c5322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86639658ec94ada14e3a8569b62c5322">&#9670;&nbsp;</a></span>linalgOpToLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::linalgOpToLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits a loop nest of <code>scf.for</code> with the proper body for <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00732">732</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00412">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>, and <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00147">mlir::linalg::LinalgPromotionOptions::setCopyInOutFns()</a>.</p>

</div>
</div>
<a id="a5ab13dd380c27183fb9cec5d731eacc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab13dd380c27183fb9cec5d731eacc9">&#9670;&nbsp;</a></span>linalgOpToParallelLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::linalgOpToParallelLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emits a loop nest of <code>scf.parallel</code> with the proper body for <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="Loops_8cpp_source.html#l00738">738</a> of file <a class="el" href="Loops_8cpp_source.html">Loops.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00412">mlir::linalg::LinalgLoweringPattern&lt; OpTy &gt;::matchAndRewrite()</a>, and <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00147">mlir::linalg::LinalgPromotionOptions::setCopyInOutFns()</a>.</p>

</div>
</div>
<a id="a962a46fba2ac497e30bb6d23fef35d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962a46fba2ac497e30bb6d23fef35d1a">&#9670;&nbsp;</a></span>makeAffineDimExprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt; mlir::linalg::makeAffineDimExprs </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>startIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>num</code> <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression. ">AffineDimExpr</a> dimensions at positions [startIdx, startIdx + num) and increments <code>startIdx</code> to <code>startIdx + num</code>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l01073">1073</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineExpr_8cpp_source.html#l00456">mlir::getAffineDimExpr()</a>.</p>

</div>
</div>
<a id="aea396843a4c8fce5aa96c6d49a483661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea396843a4c8fce5aa96c6d49a483661">&#9670;&nbsp;</a></span>promoteSubViews()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; LinalgOp &gt; mlir::linalg::promoteSubViews </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationFolder.html">OperationFolder</a> *&#160;</td>
          <td class="paramname"><em>folder</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes the <code>subViews</code> into a new buffer allocated at the insertion point <code>b</code>. </p>
<p>Promotion occurs in 3 steps:</p><ol type="1">
<li>Create a new buffer for a full tile (i.e. not clipped at the boundary).</li>
<li>Take a full view on the buffer.</li>
<li>Take a partial slice of the full view in step 2. and copy into it. Infers statically sized buffers from subViews unless <code>dynamicBuffers</code> is true.</li>
</ol>
<p>Returns the modified linalg op (the modification happens in place) as well as all the copy ops created. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00393">393</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00046">mlir::failed()</a>, <a class="el" href="Promotion_8cpp_source.html#l00271">promoteSubViews()</a>, <a class="el" href="Promotion_8cpp_source.html#l00373">promoteSubviewsPrecondition()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00115">mlir::linalg::LinalgPromotionOptions::setDynamicBuffers()</a>, and <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00127">mlir::linalg::LinalgPromotionOptions::setUseAlloca()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Transforms_8cpp_source.html#l00168">mlir::linalg::LinalgBasePromotionPattern::matchAndRewrite()</a>, and <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00147">mlir::linalg::LinalgPromotionOptions::setCopyInOutFns()</a>.</p>

</div>
</div>
<a id="a850b9fd11404efe17bca02011aff2e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850b9fd11404efe17bca02011aff2e88">&#9670;&nbsp;</a></span>promoteSubviewsPrecondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::promoteSubviewsPrecondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a>&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promote std.subviews feeding linalg operations. </p>

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00373">373</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00185">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00085">mlir::linalg::LinalgPromotionOptions::operandsToPromote</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Transforms_8cpp_source.html#l00168">mlir::linalg::LinalgBasePromotionPattern::matchAndRewrite()</a>, <a class="el" href="Promotion_8cpp_source.html#l00393">promoteSubViews()</a>, and <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00147">mlir::linalg::LinalgPromotionOptions::setCopyInOutFns()</a>.</p>

</div>
</div>
<a id="ab2efdb9223f206f2d1f8f8ee6b27564f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2efdb9223f206f2d1f8f8ee6b27564f">&#9670;&nbsp;</a></span>tileLinalgOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a> &gt; mlir::linalg::tileLinalgOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs standalone tiling of a single LinalgOp by <code>tileSizes</code>. </p>
<p>and permute the loop nest according to <code>interchangeVector</code> The permutation is expressed as a list of integers that specify the new ordering of the loop nest. The length of <code>interchangeVector</code> must be equal to the length of <code>tileSizes</code>. An empty vector is interpreted as the identity permutation and the transformation returns early.</p>
<p>Returns a struct containing the tiled loops in the specified order and the cloned op if successful, llvm::None otherwise.</p>
<p>E.g. the permutation <code>(i,j,k) -&gt; (j,k,i)</code> is expressed by <code>interchangeVector = [1,2,0]</code>. All values in <code>interchangeVector</code> must be integers, in the range 0..<code>tileSizes.size()</code> without duplications (i.e. <code>[1,1,2]</code> is an invalid permutation). </p>

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00420">420</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00631">mlir::Identifier::get()</a>, <a class="el" href="PatternMatch_8h_source.html#l00454">mlir::OwningRewritePatternList::insert()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00268">mlir::linalg::LinalgTilingOptions::loopType</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00096">options</a>.</p>

<p class="reference">Referenced by <a class="el" href="Transforms_8cpp_source.html#l00114">mlir::linalg::LinalgBaseTilingPattern::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a3fae5d2ec66e658cbabd89ea5c15a5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fae5d2ec66e658cbabd89ea5c15a5ef">&#9670;&nbsp;</a></span>vectorizeLinalgOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::linalg::vectorizeLinalgOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a suitable vector form for a Linalg op with fully static shape. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00105">105</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="Vectorization_8cpp_source.html#l00037">DEBUG_TYPE</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00271">mlir::VectorType::get()</a>, <a class="el" href="Operation_8h_source.html#l00103">mlir::Operation::getLoc()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00455">mlir::MemRefType::getShape()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00069">isContraction()</a>, <a class="el" href="LogicalResult_8h_source.html#l00040">mlir::succeeded()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00089">vectorizeLinalgOpPrecondition()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Transforms_8cpp_source.html#l00195">mlir::linalg::LinalgBaseVectorizationPattern::matchAndRewrite()</a>, and <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00147">mlir::linalg::LinalgPromotionOptions::setCopyInOutFns()</a>.</p>

</div>
</div>
<a id="a434bd78a651f6a42d01090db72bc039c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434bd78a651f6a42d01090db72bc039c">&#9670;&nbsp;</a></span>vectorizeLinalgOpPrecondition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::linalg::vectorizeLinalgOpPrecondition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite a linalg.generic into a suitable vector.contraction op. </p>

<p class="definition">Definition at line <a class="el" href="Vectorization_8cpp_source.html#l00089">89</a> of file <a class="el" href="Vectorization_8cpp_source.html">Vectorization.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00259">mlir::ShapedType::hasStaticShape()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00069">isContraction()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Transforms_8cpp_source.html#l00195">mlir::linalg::LinalgBaseVectorizationPattern::matchAndRewrite()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8h_source.html#l00147">mlir::linalg::LinalgPromotionOptions::setCopyInOutFns()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00105">vectorizeLinalgOp()</a>.</p>

</div>
</div>
<a id="ab5dd029acdda95eeb6887d0e169bcbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5dd029acdda95eeb6887d0e169bcbb5">&#9670;&nbsp;</a></span>weightedPoolingInputIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PoolingOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt; mlir::linalg::weightedPoolingInputIndex </td>
          <td>(</td>
          <td class="paramtype">PoolingOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>outputDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>windowDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds the indexing expressions for a ConvOp/PoolingOp <code>op</code>. </p>
<p>Returns the vector of AffineMaps representing: <code>stride[i] * outputDims[i] + dilation[i] * windowDims[i] - pad_low[i]</code> </p>

<p class="definition">Definition at line <a class="el" href="LinalgOps_8cpp_source.html#l01084">1084</a> of file <a class="el" href="LinalgOps_8cpp_source.html">LinalgOps.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Aug 8 2020 16:27:20 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
