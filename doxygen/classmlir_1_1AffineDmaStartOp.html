<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::AffineDmaStartOp Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">12.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1AffineDmaStartOp.html">AffineDmaStartOp</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmlir_1_1AffineDmaStartOp-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::AffineDmaStartOp Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classmlir_1_1AffineDmaStartOp.html" title="AffineDmaStartOp starts a non-blocking DMA operation that transfers data from a source memref to a de...">AffineDmaStartOp</a> starts a non-blocking DMA operation that transfers data from a source memref to a destination memref.  
 <a href="classmlir_1_1AffineDmaStartOp.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code></p>
<div class="dynheader">
Inheritance diagram for mlir::AffineDmaStartOp:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1AffineDmaStartOp__inherit__graph.png" border="0" usemap="#mlir_1_1AffineDmaStartOp_inherit__map" alt="Inheritance graph"/></div>
<map name="mlir_1_1AffineDmaStartOp_inherit__map" id="mlir_1_1AffineDmaStartOp_inherit__map">
<area shape="rect" id="node2" href="classmlir_1_1Op.html" title="mlir::Op\&lt; AffineDmaStart\lOp, OpTrait::VariadicOperands,\l OpTrait::ZeroResult \&gt;" alt="" coords="2303,155,2508,211"/>
<area shape="rect" id="node3" href="classmlir_1_1OpState.html" title="This is the concrete base class that holds the operation pointer and has non&#45;generic methods that onl..." alt="" coords="1435,5,1533,32"/>
<area shape="rect" id="node14" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have. " alt="" coords="1906,127,2073,169"/>
<area shape="rect" id="node4" href="classmlir_1_1OpTrait_1_1VariadicOperands.html" title="mlir::OpTrait::VariadicOperands\l\&lt; AffineDmaStartOp \&gt;" alt="" coords="1887,293,2092,334"/>
<area shape="rect" id="node5" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html" title="mlir::OpTrait::detail\l::MultiOperandTraitBase\l\&lt; AffineDmaStartOp, VariadicOperands \&gt;" alt="" coords="863,356,1127,412"/>
<area shape="rect" id="node6" href="classmlir_1_1OpTrait_1_1TraitBase.html" title="mlir::OpTrait::TraitBase\l\&lt; AffineDmaStartOp, VariadicOperands \&gt;" alt="" coords="397,394,661,435"/>
<area shape="rect" id="node7" href="classmlir_1_1OpTrait_1_1TraitBase.html" title="Helper class for implementing traits. " alt="" coords="5,319,196,361"/>
<area shape="rect" id="node8" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html" title="Utility trait base that provides accessors for derived traits that have multiple operands. " alt="" coords="434,312,625,368"/>
<area shape="rect" id="node11" href="classmlir_1_1OpTrait_1_1TraitBase.html" title="mlir::OpTrait::TraitBase\l\&lt; ConcreteType, VariadicOperands \&gt;" alt="" coords="410,245,649,286"/>
<area shape="rect" id="node10" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html" title="mlir::OpTrait::detail\l::MultiOperandTraitBase\l\&lt; ConcreteType, VariadicOperands \&gt;" alt="" coords="875,276,1114,332"/>
<area shape="rect" id="node9" href="classmlir_1_1OpTrait_1_1VariadicOperands.html" title="This class provides the API for ops which have an unknown number of SSA operands. ..." alt="" coords="1381,289,1587,330"/>
<area shape="rect" id="node12" href="classmlir_1_1FoldingHook.html" title="mlir::FoldingHook\&lt;\l AffineDmaStartOp, llvm\l::is_one_of\&lt; OpTrait::OneResult\l\&lt; AffineDmaStartOp \&gt;, OpTrait\l::VariadicOperands\&lt; AffineDmaStartOp\l \&gt;... \&gt;::value \&gt;" alt="" coords="1611,193,1863,293"/>
<area shape="rect" id="node13" href="classmlir_1_1FoldingHook.html" title="This template defines the foldHook as used by AbstractOperation. " alt="" coords="893,160,1097,216"/>
<area shape="rect" id="node16" href="classmlir_1_1FoldingHook.html" title="mlir::FoldingHook\&lt;\l ConcreteType, llvm\l::is_one_of\&lt; OpTrait\l::OneResult\&lt; ConcreteType\l \&gt;, Traits\&lt; ConcreteType\l \&gt;... \&gt;::value \&gt;" alt="" coords="1391,57,1577,157"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mlir::AffineDmaStartOp:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1AffineDmaStartOp__coll__graph.png" border="0" usemap="#mlir_1_1AffineDmaStartOp_coll__map" alt="Collaboration graph"/></div>
<map name="mlir_1_1AffineDmaStartOp_coll__map" id="mlir_1_1AffineDmaStartOp_coll__map">
<area shape="rect" id="node2" href="classmlir_1_1Op.html" title="mlir::Op\&lt; AffineDmaStart\lOp, OpTrait::VariadicOperands,\l OpTrait::ZeroResult \&gt;" alt="" coords="2303,155,2508,211"/>
<area shape="rect" id="node3" href="classmlir_1_1OpState.html" title="This is the concrete base class that holds the operation pointer and has non&#45;generic methods that onl..." alt="" coords="1435,5,1533,32"/>
<area shape="rect" id="node14" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have. " alt="" coords="1906,127,2073,169"/>
<area shape="rect" id="node4" href="classmlir_1_1OpTrait_1_1VariadicOperands.html" title="mlir::OpTrait::VariadicOperands\l\&lt; AffineDmaStartOp \&gt;" alt="" coords="1887,293,2092,334"/>
<area shape="rect" id="node5" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html" title="mlir::OpTrait::detail\l::MultiOperandTraitBase\l\&lt; AffineDmaStartOp, VariadicOperands \&gt;" alt="" coords="863,356,1127,412"/>
<area shape="rect" id="node6" href="classmlir_1_1OpTrait_1_1TraitBase.html" title="mlir::OpTrait::TraitBase\l\&lt; AffineDmaStartOp, VariadicOperands \&gt;" alt="" coords="397,394,661,435"/>
<area shape="rect" id="node7" href="classmlir_1_1OpTrait_1_1TraitBase.html" title="Helper class for implementing traits. " alt="" coords="5,319,196,361"/>
<area shape="rect" id="node8" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html" title="Utility trait base that provides accessors for derived traits that have multiple operands. " alt="" coords="434,312,625,368"/>
<area shape="rect" id="node11" href="classmlir_1_1OpTrait_1_1TraitBase.html" title="mlir::OpTrait::TraitBase\l\&lt; ConcreteType, VariadicOperands \&gt;" alt="" coords="410,245,649,286"/>
<area shape="rect" id="node10" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html" title="mlir::OpTrait::detail\l::MultiOperandTraitBase\l\&lt; ConcreteType, VariadicOperands \&gt;" alt="" coords="875,276,1114,332"/>
<area shape="rect" id="node9" href="classmlir_1_1OpTrait_1_1VariadicOperands.html" title="This class provides the API for ops which have an unknown number of SSA operands. ..." alt="" coords="1381,289,1587,330"/>
<area shape="rect" id="node12" href="classmlir_1_1FoldingHook.html" title="mlir::FoldingHook\&lt;\l AffineDmaStartOp, llvm\l::is_one_of\&lt; OpTrait::OneResult\l\&lt; AffineDmaStartOp \&gt;, OpTrait\l::VariadicOperands\&lt; AffineDmaStartOp\l \&gt;... \&gt;::value \&gt;" alt="" coords="1611,193,1863,293"/>
<area shape="rect" id="node13" href="classmlir_1_1FoldingHook.html" title="This template defines the foldHook as used by AbstractOperation. " alt="" coords="893,160,1097,216"/>
<area shape="rect" id="node16" href="classmlir_1_1FoldingHook.html" title="mlir::FoldingHook\&lt;\l ConcreteType, llvm\l::is_one_of\&lt; OpTrait\l::OneResult\&lt; ConcreteType\l \&gt;, Traits\&lt; ConcreteType\l \&gt;... \&gt;::value \&gt;" alt="" coords="1391,57,1577,157"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a20647412938b7c5ac6c7d126e46aa0b0"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a20647412938b7c5ac6c7d126e46aa0b0">getSrcMemRefOperandIndex</a> ()</td></tr>
<tr class="memdesc:a20647412938b7c5ac6c7d126e46aa0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the operand index of the src memref.  <a href="#a20647412938b7c5ac6c7d126e46aa0b0">More...</a><br /></td></tr>
<tr class="separator:a20647412938b7c5ac6c7d126e46aa0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df5461067827388e19a459177ea8027"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a8df5461067827388e19a459177ea8027">getSrcMemRef</a> ()</td></tr>
<tr class="memdesc:a8df5461067827388e19a459177ea8027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the source <a class="el" href="classmlir_1_1MemRefType.html" title="MemRef types represent a region of memory that have a shape with a fixed number of dimensions...">MemRefType</a> for this DMA operation.  <a href="#a8df5461067827388e19a459177ea8027">More...</a><br /></td></tr>
<tr class="separator:a8df5461067827388e19a459177ea8027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3651e5d95c9fe31d470e4d7b4952481b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a3651e5d95c9fe31d470e4d7b4952481b">getSrcMemRefType</a> ()</td></tr>
<tr class="separator:a3651e5d95c9fe31d470e4d7b4952481b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7668f3b3e876c6cfedf29822a71859a3"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a7668f3b3e876c6cfedf29822a71859a3">getSrcMemRefRank</a> ()</td></tr>
<tr class="memdesc:a7668f3b3e876c6cfedf29822a71859a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank (number of indices) of the source <a class="el" href="classmlir_1_1MemRefType.html" title="MemRef types represent a region of memory that have a shape with a fixed number of dimensions...">MemRefType</a>.  <a href="#a7668f3b3e876c6cfedf29822a71859a3">More...</a><br /></td></tr>
<tr class="separator:a7668f3b3e876c6cfedf29822a71859a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd808c35b1a94571b9afb7cc6d8400b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#acd808c35b1a94571b9afb7cc6d8400b0">getSrcMap</a> ()</td></tr>
<tr class="memdesc:acd808c35b1a94571b9afb7cc6d8400b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the affine map used to access the src memref.  <a href="#acd808c35b1a94571b9afb7cc6d8400b0">More...</a><br /></td></tr>
<tr class="separator:acd808c35b1a94571b9afb7cc6d8400b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af916c2797cb31cc32c209039862dafec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMapAttr.html">AffineMapAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#af916c2797cb31cc32c209039862dafec">getSrcMapAttr</a> ()</td></tr>
<tr class="separator:af916c2797cb31cc32c209039862dafec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd0116c02294ad87dd632b855f8112a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#a5b0c59db57bad8ce8bd0687f2527c4d3">operand_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#afdd0116c02294ad87dd632b855f8112a">getSrcIndices</a> ()</td></tr>
<tr class="memdesc:afdd0116c02294ad87dd632b855f8112a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the source memref affine map indices for this DMA operation.  <a href="#afdd0116c02294ad87dd632b855f8112a">More...</a><br /></td></tr>
<tr class="separator:afdd0116c02294ad87dd632b855f8112a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca580bc4d944e79bef3b27e9cd4bb064"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#aca580bc4d944e79bef3b27e9cd4bb064">getSrcMemorySpace</a> ()</td></tr>
<tr class="memdesc:aca580bc4d944e79bef3b27e9cd4bb064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the memory space of the src memref.  <a href="#aca580bc4d944e79bef3b27e9cd4bb064">More...</a><br /></td></tr>
<tr class="separator:aca580bc4d944e79bef3b27e9cd4bb064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8405ebd5893de7ec19d347074057295"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#ac8405ebd5893de7ec19d347074057295">getDstMemRefOperandIndex</a> ()</td></tr>
<tr class="memdesc:ac8405ebd5893de7ec19d347074057295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the operand index of the dst memref.  <a href="#ac8405ebd5893de7ec19d347074057295">More...</a><br /></td></tr>
<tr class="separator:ac8405ebd5893de7ec19d347074057295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780f50de5bdcfa29a131e941050fdcd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a780f50de5bdcfa29a131e941050fdcd1">getDstMemRef</a> ()</td></tr>
<tr class="memdesc:a780f50de5bdcfa29a131e941050fdcd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the destination <a class="el" href="classmlir_1_1MemRefType.html" title="MemRef types represent a region of memory that have a shape with a fixed number of dimensions...">MemRefType</a> for this DMA operations.  <a href="#a780f50de5bdcfa29a131e941050fdcd1">More...</a><br /></td></tr>
<tr class="separator:a780f50de5bdcfa29a131e941050fdcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1763308691b432116b413ea27d890bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#af1763308691b432116b413ea27d890bf">getDstMemRefType</a> ()</td></tr>
<tr class="separator:af1763308691b432116b413ea27d890bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1479ef9963ac09985141a38ea5939946"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a1479ef9963ac09985141a38ea5939946">getDstMemRefRank</a> ()</td></tr>
<tr class="memdesc:a1479ef9963ac09985141a38ea5939946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank (number of indices) of the destination <a class="el" href="classmlir_1_1MemRefType.html" title="MemRef types represent a region of memory that have a shape with a fixed number of dimensions...">MemRefType</a>.  <a href="#a1479ef9963ac09985141a38ea5939946">More...</a><br /></td></tr>
<tr class="separator:a1479ef9963ac09985141a38ea5939946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343a3dd850208dec35b4b1b193562a3d"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a343a3dd850208dec35b4b1b193562a3d">getDstMemorySpace</a> ()</td></tr>
<tr class="memdesc:a343a3dd850208dec35b4b1b193562a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the memory space of the src memref.  <a href="#a343a3dd850208dec35b4b1b193562a3d">More...</a><br /></td></tr>
<tr class="separator:a343a3dd850208dec35b4b1b193562a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1071dcc7323a4600ba6632a8da6e568"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#ad1071dcc7323a4600ba6632a8da6e568">getDstMap</a> ()</td></tr>
<tr class="memdesc:ad1071dcc7323a4600ba6632a8da6e568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the affine map used to access the dst memref.  <a href="#ad1071dcc7323a4600ba6632a8da6e568">More...</a><br /></td></tr>
<tr class="separator:ad1071dcc7323a4600ba6632a8da6e568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f4727e1b39839f61634fd76a18ba45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMapAttr.html">AffineMapAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#ae3f4727e1b39839f61634fd76a18ba45">getDstMapAttr</a> ()</td></tr>
<tr class="separator:ae3f4727e1b39839f61634fd76a18ba45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87dbb4d8b9952f3020ba83c3a1e6ef30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#a5b0c59db57bad8ce8bd0687f2527c4d3">operand_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a87dbb4d8b9952f3020ba83c3a1e6ef30">getDstIndices</a> ()</td></tr>
<tr class="memdesc:a87dbb4d8b9952f3020ba83c3a1e6ef30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the destination memref indices for this DMA operation.  <a href="#a87dbb4d8b9952f3020ba83c3a1e6ef30">More...</a><br /></td></tr>
<tr class="separator:a87dbb4d8b9952f3020ba83c3a1e6ef30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24197fa6a7763cbe95231f94440a1d6f"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a24197fa6a7763cbe95231f94440a1d6f">getTagMemRefOperandIndex</a> ()</td></tr>
<tr class="memdesc:a24197fa6a7763cbe95231f94440a1d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the operand index of the tag memref.  <a href="#a24197fa6a7763cbe95231f94440a1d6f">More...</a><br /></td></tr>
<tr class="separator:a24197fa6a7763cbe95231f94440a1d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58573e225acd3779ffcbce9c0f221b62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a58573e225acd3779ffcbce9c0f221b62">getTagMemRef</a> ()</td></tr>
<tr class="memdesc:a58573e225acd3779ffcbce9c0f221b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Tag MemRef for this DMA operation.  <a href="#a58573e225acd3779ffcbce9c0f221b62">More...</a><br /></td></tr>
<tr class="separator:a58573e225acd3779ffcbce9c0f221b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c1413eb6cf07334af04f2444e24524"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a46c1413eb6cf07334af04f2444e24524">getTagMemRefType</a> ()</td></tr>
<tr class="separator:a46c1413eb6cf07334af04f2444e24524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d6292747dc7158fa1f89cdd7421e27"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a53d6292747dc7158fa1f89cdd7421e27">getTagMemRefRank</a> ()</td></tr>
<tr class="memdesc:a53d6292747dc7158fa1f89cdd7421e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank (number of indices) of the tag <a class="el" href="classmlir_1_1MemRefType.html" title="MemRef types represent a region of memory that have a shape with a fixed number of dimensions...">MemRefType</a>.  <a href="#a53d6292747dc7158fa1f89cdd7421e27">More...</a><br /></td></tr>
<tr class="separator:a53d6292747dc7158fa1f89cdd7421e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8fc80d81f721e96e2403a32e776b2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a5f8fc80d81f721e96e2403a32e776b2b">getTagMap</a> ()</td></tr>
<tr class="memdesc:a5f8fc80d81f721e96e2403a32e776b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the affine map used to access the tag memref.  <a href="#a5f8fc80d81f721e96e2403a32e776b2b">More...</a><br /></td></tr>
<tr class="separator:a5f8fc80d81f721e96e2403a32e776b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305b5739572b65da83f894e4fab37cbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMapAttr.html">AffineMapAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a305b5739572b65da83f894e4fab37cbf">getTagMapAttr</a> ()</td></tr>
<tr class="separator:a305b5739572b65da83f894e4fab37cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa583874531e254538cac4f0af7cbdffd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#a5b0c59db57bad8ce8bd0687f2527c4d3">operand_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#aa583874531e254538cac4f0af7cbdffd">getTagIndices</a> ()</td></tr>
<tr class="memdesc:aa583874531e254538cac4f0af7cbdffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tag memref indices for this DMA operation.  <a href="#aa583874531e254538cac4f0af7cbdffd">More...</a><br /></td></tr>
<tr class="separator:aa583874531e254538cac4f0af7cbdffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202053be4264f6904749c574c62e66f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a202053be4264f6904749c574c62e66f8">getNumElements</a> ()</td></tr>
<tr class="memdesc:a202053be4264f6904749c574c62e66f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements being transferred by this DMA operation.  <a href="#a202053be4264f6904749c574c62e66f8">More...</a><br /></td></tr>
<tr class="separator:a202053be4264f6904749c574c62e66f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0032ca693e04d266e33693352f7cb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a2bd440a077557b4421b2cfd06d48956a">NamedAttribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a6d0032ca693e04d266e33693352f7cb7">getAffineMapAttrForMemRef</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> memref)</td></tr>
<tr class="memdesc:a6d0032ca693e04d266e33693352f7cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classmlir_1_1AffineMapAttr.html">AffineMapAttr</a> associated with 'memref'.  <a href="#a6d0032ca693e04d266e33693352f7cb7">More...</a><br /></td></tr>
<tr class="separator:a6d0032ca693e04d266e33693352f7cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214228a73e969cbb97bf52b9fb0004da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a214228a73e969cbb97bf52b9fb0004da">isDestMemorySpaceFaster</a> ()</td></tr>
<tr class="memdesc:a214228a73e969cbb97bf52b9fb0004da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is a DMA from a faster memory space to a slower one.  <a href="#a214228a73e969cbb97bf52b9fb0004da">More...</a><br /></td></tr>
<tr class="separator:a214228a73e969cbb97bf52b9fb0004da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a401c930cc6f0c0eb393f85e38b0586"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a6a401c930cc6f0c0eb393f85e38b0586">isSrcMemorySpaceFaster</a> ()</td></tr>
<tr class="memdesc:a6a401c930cc6f0c0eb393f85e38b0586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this is a DMA from a slower memory space to a faster one.  <a href="#a6a401c930cc6f0c0eb393f85e38b0586">More...</a><br /></td></tr>
<tr class="separator:a6a401c930cc6f0c0eb393f85e38b0586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c816ecef9218bae44396d375ae2755e"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a3c816ecef9218bae44396d375ae2755e">getFasterMemPos</a> ()</td></tr>
<tr class="memdesc:a3c816ecef9218bae44396d375ae2755e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a DMA start operation, returns the operand position of either the source or destination memref depending on the one that is at the higher level of the memory hierarchy.  <a href="#a3c816ecef9218bae44396d375ae2755e">More...</a><br /></td></tr>
<tr class="separator:a3c816ecef9218bae44396d375ae2755e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a378a1f108aa52ebda32f5df80c4e3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a4a378a1f108aa52ebda32f5df80c4e3e">print</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p)</td></tr>
<tr class="separator:a4a378a1f108aa52ebda32f5df80c4e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3f59c96b14a93dd1f124c385b3d876"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a3f3f59c96b14a93dd1f124c385b3d876">verify</a> ()</td></tr>
<tr class="separator:a3f3f59c96b14a93dd1f124c385b3d876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0550bb3a330b3f291f20deade5b58d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#af0550bb3a330b3f291f20deade5b58d1">fold</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; cstOperands, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;results)</td></tr>
<tr class="separator:af0550bb3a330b3f291f20deade5b58d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8e973a7baf40d04164ba7f16e2652c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a3c8e973a7baf40d04164ba7f16e2652c">isStrided</a> ()</td></tr>
<tr class="memdesc:a3c8e973a7baf40d04164ba7f16e2652c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this DMA operation is strided, returns false otherwise.  <a href="#a3c8e973a7baf40d04164ba7f16e2652c">More...</a><br /></td></tr>
<tr class="separator:a3c8e973a7baf40d04164ba7f16e2652c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e74d1c1e2a656c1c2ddc221d198987"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a50e74d1c1e2a656c1c2ddc221d198987">getStride</a> ()</td></tr>
<tr class="memdesc:a50e74d1c1e2a656c1c2ddc221d198987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stride value for this DMA operation.  <a href="#a50e74d1c1e2a656c1c2ddc221d198987">More...</a><br /></td></tr>
<tr class="separator:a50e74d1c1e2a656c1c2ddc221d198987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ef6994b499ac19c668537866452ef0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#ae9ef6994b499ac19c668537866452ef0">getNumElementsPerStride</a> ()</td></tr>
<tr class="memdesc:ae9ef6994b499ac19c668537866452ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements to transfer per stride for this DMA op.  <a href="#ae9ef6994b499ac19c668537866452ef0">More...</a><br /></td></tr>
<tr class="separator:ae9ef6994b499ac19c668537866452ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1Op"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1Op')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1Op.html">mlir::Op&lt; AffineDmaStartOp, OpTrait::VariadicOperands, OpTrait::ZeroResult &gt;</a></td></tr>
<tr class="memitem:acc1633a87c5b5b8e149483a564251c7b inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#acc1633a87c5b5b8e149483a564251c7b">getOperation</a> ()</td></tr>
<tr class="memdesc:acc1633a87c5b5b8e149483a564251c7b inherit pub_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the operation that this refers to.  <a href="classmlir_1_1Op.html#acc1633a87c5b5b8e149483a564251c7b">More...</a><br /></td></tr>
<tr class="separator:acc1633a87c5b5b8e149483a564251c7b inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d7e2ead4d30cbc9c32d8ecfa1d1fbb inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineDmaStartOp.html">AffineDmaStartOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a78d7e2ead4d30cbc9c32d8ecfa1d1fbb">clone</a> ()</td></tr>
<tr class="memdesc:a78d7e2ead4d30cbc9c32d8ecfa1d1fbb inherit pub_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a deep copy of this operation.  <a href="classmlir_1_1Op.html#a78d7e2ead4d30cbc9c32d8ecfa1d1fbb">More...</a><br /></td></tr>
<tr class="separator:a78d7e2ead4d30cbc9c32d8ecfa1d1fbb inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcbe19488b3c38705a819fb09e0be5d inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineDmaStartOp.html">AffineDmaStartOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#aebcbe19488b3c38705a819fb09e0be5d">cloneWithoutRegions</a> ()</td></tr>
<tr class="memdesc:aebcbe19488b3c38705a819fb09e0be5d inherit pub_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a partial copy of this operation without traversing into attached regions.  <a href="classmlir_1_1Op.html#aebcbe19488b3c38705a819fb09e0be5d">More...</a><br /></td></tr>
<tr class="separator:aebcbe19488b3c38705a819fb09e0be5d inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d20cdf0c816d7f1b1abec6531fdbf1 inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Dialect.html">Dialect</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a73d20cdf0c816d7f1b1abec6531fdbf1">getDialect</a> ()</td></tr>
<tr class="memdesc:a73d20cdf0c816d7f1b1abec6531fdbf1 inherit pub_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dialect that this refers to.  <a href="classmlir_1_1Op.html#a73d20cdf0c816d7f1b1abec6531fdbf1">More...</a><br /></td></tr>
<tr class="separator:a73d20cdf0c816d7f1b1abec6531fdbf1 inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3f78c5f7c23acbe779d2e139cded9e inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#add3f78c5f7c23acbe779d2e139cded9e">getParentRegion</a> ()</td></tr>
<tr class="memdesc:add3f78c5f7c23acbe779d2e139cded9e inherit pub_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the parent Region of this operation.  <a href="classmlir_1_1Op.html#add3f78c5f7c23acbe779d2e139cded9e">More...</a><br /></td></tr>
<tr class="separator:add3f78c5f7c23acbe779d2e139cded9e inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9f320696122f31b6b22509d137d33d inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#abe9f320696122f31b6b22509d137d33d">Op</a> ()</td></tr>
<tr class="memdesc:abe9f320696122f31b6b22509d137d33d inherit pub_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a public constructor. Any op can be initialized to null.  <a href="classmlir_1_1Op.html#abe9f320696122f31b6b22509d137d33d">More...</a><br /></td></tr>
<tr class="separator:abe9f320696122f31b6b22509d137d33d inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b3a86209028ced4a8405877fb51b5b inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a25b3a86209028ced4a8405877fb51b5b">Op</a> (std::nullptr_t)</td></tr>
<tr class="separator:a25b3a86209028ced4a8405877fb51b5b inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5905d939c92414ac6cce2c7d54f8f05e inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a5905d939c92414ac6cce2c7d54f8f05e">Op</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *state)</td></tr>
<tr class="memdesc:a5905d939c92414ac6cce2c7d54f8f05e inherit pub_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a public constructor to enable access via the llvm::cast family of methods.  <a href="classmlir_1_1Op.html#a5905d939c92414ac6cce2c7d54f8f05e">More...</a><br /></td></tr>
<tr class="separator:a5905d939c92414ac6cce2c7d54f8f05e inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab748974126586683a89d2355aeccc2f9 inherit pub_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#ab748974126586683a89d2355aeccc2f9">getAsOpaquePointer</a> () const</td></tr>
<tr class="memdesc:ab748974126586683a89d2355aeccc2f9 inherit pub_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for supporting PointerLikeTypeTraits.  <a href="classmlir_1_1Op.html#ab748974126586683a89d2355aeccc2f9">More...</a><br /></td></tr>
<tr class="separator:ab748974126586683a89d2355aeccc2f9 inherit pub_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1OpState"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1OpState')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memitem:a4a630754c7bac8e1c33ced0f4f25e3ba inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a4a630754c7bac8e1c33ced0f4f25e3ba">operator bool</a> ()</td></tr>
<tr class="memdesc:a4a630754c7bac8e1c33ced0f4f25e3ba inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ops are pointer-like, so we allow implicit conversion to bool.  <a href="classmlir_1_1OpState.html#a4a630754c7bac8e1c33ced0f4f25e3ba">More...</a><br /></td></tr>
<tr class="separator:a4a630754c7bac8e1c33ced0f4f25e3ba inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53baa7db4eecd983c7387027ebf0f44 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ac53baa7db4eecd983c7387027ebf0f44">operator Operation *</a> () const</td></tr>
<tr class="memdesc:ac53baa7db4eecd983c7387027ebf0f44 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">This implicitly converts to Operation*.  <a href="classmlir_1_1OpState.html#ac53baa7db4eecd983c7387027ebf0f44">More...</a><br /></td></tr>
<tr class="separator:ac53baa7db4eecd983c7387027ebf0f44 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0de86e7f83e0d3c90eb5ac7b36d5b3b inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ab0de86e7f83e0d3c90eb5ac7b36d5b3b">getOperation</a> ()</td></tr>
<tr class="memdesc:ab0de86e7f83e0d3c90eb5ac7b36d5b3b inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the operation that this refers to.  <a href="classmlir_1_1OpState.html#ab0de86e7f83e0d3c90eb5ac7b36d5b3b">More...</a><br /></td></tr>
<tr class="separator:ab0de86e7f83e0d3c90eb5ac7b36d5b3b inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d7c891a68c23af6c45fc68ddd89962 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a53d7c891a68c23af6c45fc68ddd89962">getParentOp</a> ()</td></tr>
<tr class="memdesc:a53d7c891a68c23af6c45fc68ddd89962 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the closest surrounding operation that contains this operation or nullptr if this is a top-level operation.  <a href="classmlir_1_1OpState.html#a53d7c891a68c23af6c45fc68ddd89962">More...</a><br /></td></tr>
<tr class="separator:a53d7c891a68c23af6c45fc68ddd89962 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eed1368f1e3bdc6a8d19166c32a86f5 inherit pub_methods_classmlir_1_1OpState"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:a4eed1368f1e3bdc6a8d19166c32a86f5 inherit pub_methods_classmlir_1_1OpState"><td class="memTemplItemLeft" align="right" valign="top">OpTy&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a4eed1368f1e3bdc6a8d19166c32a86f5">getParentOfType</a> ()</td></tr>
<tr class="memdesc:a4eed1368f1e3bdc6a8d19166c32a86f5 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the closest surrounding parent operation that is of type 'OpTy'.  <a href="classmlir_1_1OpState.html#a4eed1368f1e3bdc6a8d19166c32a86f5">More...</a><br /></td></tr>
<tr class="separator:a4eed1368f1e3bdc6a8d19166c32a86f5 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adece33dcfc17ca370d9740a019162016 inherit pub_methods_classmlir_1_1OpState"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename T &gt; class Trait&gt; </td></tr>
<tr class="memitem:adece33dcfc17ca370d9740a019162016 inherit pub_methods_classmlir_1_1OpState"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#adece33dcfc17ca370d9740a019162016">getParentWithTrait</a> ()</td></tr>
<tr class="memdesc:adece33dcfc17ca370d9740a019162016 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the closest surrounding parent operation with trait <code>Trait</code>.  <a href="classmlir_1_1OpState.html#adece33dcfc17ca370d9740a019162016">More...</a><br /></td></tr>
<tr class="separator:adece33dcfc17ca370d9740a019162016 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15857fa62a3a6e8423b3d1511acfc040 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a15857fa62a3a6e8423b3d1511acfc040">getContext</a> ()</td></tr>
<tr class="memdesc:a15857fa62a3a6e8423b3d1511acfc040 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the context this operation belongs to.  <a href="classmlir_1_1OpState.html#a15857fa62a3a6e8423b3d1511acfc040">More...</a><br /></td></tr>
<tr class="separator:a15857fa62a3a6e8423b3d1511acfc040 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6be08fdf07ed51616a0ca5e19d31c8 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a9a6be08fdf07ed51616a0ca5e19d31c8">print</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags=llvm::None)</td></tr>
<tr class="memdesc:a9a6be08fdf07ed51616a0ca5e19d31c8 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the operation to the given stream.  <a href="classmlir_1_1OpState.html#a9a6be08fdf07ed51616a0ca5e19d31c8">More...</a><br /></td></tr>
<tr class="separator:a9a6be08fdf07ed51616a0ca5e19d31c8 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c30361ec520a3ca2a401bb67b42c4c inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a92c30361ec520a3ca2a401bb67b42c4c">print</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1AsmState.html">AsmState</a> &amp;asmState, <a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a> flags=llvm::None)</td></tr>
<tr class="separator:a92c30361ec520a3ca2a401bb67b42c4c inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023cde86e8d01c23ae2f7c07d084d21a inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a023cde86e8d01c23ae2f7c07d084d21a">dump</a> ()</td></tr>
<tr class="memdesc:a023cde86e8d01c23ae2f7c07d084d21a inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump this operation.  <a href="classmlir_1_1OpState.html#a023cde86e8d01c23ae2f7c07d084d21a">More...</a><br /></td></tr>
<tr class="separator:a023cde86e8d01c23ae2f7c07d084d21a inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad824acf76e230e3cd64a02d66a82a0cb inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ad824acf76e230e3cd64a02d66a82a0cb">getLoc</a> ()</td></tr>
<tr class="memdesc:ad824acf76e230e3cd64a02d66a82a0cb inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">The source location the operation was defined or derived from.  <a href="classmlir_1_1OpState.html#ad824acf76e230e3cd64a02d66a82a0cb">More...</a><br /></td></tr>
<tr class="separator:ad824acf76e230e3cd64a02d66a82a0cb inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c894aaabd1b9c8fab2090735964b9f inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ac3c894aaabd1b9c8fab2090735964b9f">setLoc</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="separator:ac3c894aaabd1b9c8fab2090735964b9f inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9331db6639d9965f160c08a413492de8 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#a2bd440a077557b4421b2cfd06d48956a">NamedAttribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a9331db6639d9965f160c08a413492de8">getAttrs</a> ()</td></tr>
<tr class="memdesc:a9331db6639d9965f160c08a413492de8 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all of the attributes on this operation.  <a href="classmlir_1_1OpState.html#a9331db6639d9965f160c08a413492de8">More...</a><br /></td></tr>
<tr class="separator:a9331db6639d9965f160c08a413492de8 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa11c2b98c3ca83f8ecbd06d42326c8 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpState.html#a12daf70ad798e71edf66e5464bc10404">dialect_attr_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a0aa11c2b98c3ca83f8ecbd06d42326c8">getDialectAttrs</a> ()</td></tr>
<tr class="memdesc:a0aa11c2b98c3ca83f8ecbd06d42326c8 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a range corresponding to the dialect attributes for this operation.  <a href="classmlir_1_1OpState.html#a0aa11c2b98c3ca83f8ecbd06d42326c8">More...</a><br /></td></tr>
<tr class="separator:a0aa11c2b98c3ca83f8ecbd06d42326c8 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefb9aeef2eba7850a36c257d4771d03 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpState.html#a87cc746d9bbfe144144b1dd6735451dd">dialect_attr_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#aeefb9aeef2eba7850a36c257d4771d03">dialect_attr_begin</a> ()</td></tr>
<tr class="separator:aeefb9aeef2eba7850a36c257d4771d03 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2704824bb2a15eef5b3298cb7ed3a5fd inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpState.html#a87cc746d9bbfe144144b1dd6735451dd">dialect_attr_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a2704824bb2a15eef5b3298cb7ed3a5fd">dialect_attr_end</a> ()</td></tr>
<tr class="separator:a2704824bb2a15eef5b3298cb7ed3a5fd inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96cf73497da1b8c112ebbfdf209e2f02 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a96cf73497da1b8c112ebbfdf209e2f02">getAttr</a> (StringRef name)</td></tr>
<tr class="memdesc:a96cf73497da1b8c112ebbfdf209e2f02 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an attribute with the specified name.  <a href="classmlir_1_1OpState.html#a96cf73497da1b8c112ebbfdf209e2f02">More...</a><br /></td></tr>
<tr class="separator:a96cf73497da1b8c112ebbfdf209e2f02 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf19eeac15524a32d218c799b45d573 inherit pub_methods_classmlir_1_1OpState"><td class="memTemplParams" colspan="2">template&lt;typename AttrClass &gt; </td></tr>
<tr class="memitem:aaaf19eeac15524a32d218c799b45d573 inherit pub_methods_classmlir_1_1OpState"><td class="memTemplItemLeft" align="right" valign="top">AttrClass&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#aaaf19eeac15524a32d218c799b45d573">getAttrOfType</a> (StringRef name)</td></tr>
<tr class="memdesc:aaaf19eeac15524a32d218c799b45d573 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the operation has an attribute of the specified type, return it.  <a href="classmlir_1_1OpState.html#aaaf19eeac15524a32d218c799b45d573">More...</a><br /></td></tr>
<tr class="separator:aaaf19eeac15524a32d218c799b45d573 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2cdf5f3afd75b2d941b861700cdb81 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#acc2cdf5f3afd75b2d941b861700cdb81">setAttr</a> (<a class="el" href="classmlir_1_1Identifier.html">Identifier</a> name, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> value)</td></tr>
<tr class="memdesc:acc2cdf5f3afd75b2d941b861700cdb81 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the an attribute exists with the specified name, change it to the new value.  <a href="classmlir_1_1OpState.html#acc2cdf5f3afd75b2d941b861700cdb81">More...</a><br /></td></tr>
<tr class="separator:acc2cdf5f3afd75b2d941b861700cdb81 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06b78ced11b2926820dbc64ff02a981 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ae06b78ced11b2926820dbc64ff02a981">setAttr</a> (StringRef name, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> value)</td></tr>
<tr class="separator:ae06b78ced11b2926820dbc64ff02a981 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51af7d3f6647b6e190f4f53db72884fe inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a51af7d3f6647b6e190f4f53db72884fe">setAttrs</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#a2bd440a077557b4421b2cfd06d48956a">NamedAttribute</a> &gt; attributes)</td></tr>
<tr class="memdesc:a51af7d3f6647b6e190f4f53db72884fe inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the attributes held by this operation.  <a href="classmlir_1_1OpState.html#a51af7d3f6647b6e190f4f53db72884fe">More...</a><br /></td></tr>
<tr class="separator:a51af7d3f6647b6e190f4f53db72884fe inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4020e3173d74afdbede0ccf2e69f5fe inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ac4020e3173d74afdbede0ccf2e69f5fe">setAttrs</a> (<a class="el" href="classmlir_1_1MutableDictionaryAttr.html">MutableDictionaryAttr</a> newAttrs)</td></tr>
<tr class="separator:ac4020e3173d74afdbede0ccf2e69f5fe inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3018daf1473e86f9f854185ff4991afd inherit pub_methods_classmlir_1_1OpState"><td class="memTemplParams" colspan="2">template&lt;typename DialectAttrs &gt; </td></tr>
<tr class="memitem:a3018daf1473e86f9f854185ff4991afd inherit pub_methods_classmlir_1_1OpState"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a3018daf1473e86f9f854185ff4991afd">setDialectAttrs</a> (DialectAttrs &amp;&amp;attrs)</td></tr>
<tr class="memdesc:a3018daf1473e86f9f854185ff4991afd inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the dialect attributes for this operation, and preserve all dependent.  <a href="classmlir_1_1OpState.html#a3018daf1473e86f9f854185ff4991afd">More...</a><br /></td></tr>
<tr class="separator:a3018daf1473e86f9f854185ff4991afd inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34379f9c72eaf18ac8db5f0e13d5cee7 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MutableDictionaryAttr.html#a9fd6036eb69f3cf4d8ae5af9a9ab897e">MutableDictionaryAttr::RemoveResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a34379f9c72eaf18ac8db5f0e13d5cee7">removeAttr</a> (<a class="el" href="classmlir_1_1Identifier.html">Identifier</a> name)</td></tr>
<tr class="memdesc:a34379f9c72eaf18ac8db5f0e13d5cee7 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the attribute with the specified name if it exists.  <a href="classmlir_1_1OpState.html#a34379f9c72eaf18ac8db5f0e13d5cee7">More...</a><br /></td></tr>
<tr class="separator:a34379f9c72eaf18ac8db5f0e13d5cee7 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d80e8b6c0fd548f8ebcd8aa172e741 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MutableDictionaryAttr.html#a9fd6036eb69f3cf4d8ae5af9a9ab897e">MutableDictionaryAttr::RemoveResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a11d80e8b6c0fd548f8ebcd8aa172e741">removeAttr</a> (StringRef name)</td></tr>
<tr class="separator:a11d80e8b6c0fd548f8ebcd8aa172e741 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3159f7aa51ff5db54cbab48867d00365 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a3159f7aa51ff5db54cbab48867d00365">use_empty</a> ()</td></tr>
<tr class="memdesc:a3159f7aa51ff5db54cbab48867d00365 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there are no users of any results of this operation.  <a href="classmlir_1_1OpState.html#a3159f7aa51ff5db54cbab48867d00365">More...</a><br /></td></tr>
<tr class="separator:a3159f7aa51ff5db54cbab48867d00365 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202c02a251ca0fce2c2a9df84b9ea32f inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a202c02a251ca0fce2c2a9df84b9ea32f">erase</a> ()</td></tr>
<tr class="memdesc:a202c02a251ca0fce2c2a9df84b9ea32f inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove this operation from its parent block and delete it.  <a href="classmlir_1_1OpState.html#a202c02a251ca0fce2c2a9df84b9ea32f">More...</a><br /></td></tr>
<tr class="separator:a202c02a251ca0fce2c2a9df84b9ea32f inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a602baeafc892ba94fd30bfeb0624b inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a96a602baeafc892ba94fd30bfeb0624b">emitOpError</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:a96a602baeafc892ba94fd30bfeb0624b inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an error with the op name prefixed, like "'dim' op " which is convenient for verifiers.  <a href="classmlir_1_1OpState.html#a96a602baeafc892ba94fd30bfeb0624b">More...</a><br /></td></tr>
<tr class="separator:a96a602baeafc892ba94fd30bfeb0624b inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ab2e156408bc77bb5d5629068bda60 inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a78ab2e156408bc77bb5d5629068bda60">emitError</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:a78ab2e156408bc77bb5d5629068bda60 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an error about fatal conditions with this operation, reporting up to any diagnostic handlers that may be listening.  <a href="classmlir_1_1OpState.html#a78ab2e156408bc77bb5d5629068bda60">More...</a><br /></td></tr>
<tr class="separator:a78ab2e156408bc77bb5d5629068bda60 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94173f14645d198ba9e07f763acfe4b inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#aa94173f14645d198ba9e07f763acfe4b">emitWarning</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:aa94173f14645d198ba9e07f763acfe4b inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a warning about this operation, reporting up to any diagnostic handlers that may be listening.  <a href="classmlir_1_1OpState.html#aa94173f14645d198ba9e07f763acfe4b">More...</a><br /></td></tr>
<tr class="separator:aa94173f14645d198ba9e07f763acfe4b inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac456e15c3588fd348490eb8e423617ea inherit pub_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ac456e15c3588fd348490eb8e423617ea">emitRemark</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:ac456e15c3588fd348490eb8e423617ea inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a remark about this operation, reporting up to any diagnostic handlers that may be listening.  <a href="classmlir_1_1OpState.html#ac456e15c3588fd348490eb8e423617ea">More...</a><br /></td></tr>
<tr class="separator:ac456e15c3588fd348490eb8e423617ea inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f85a4dbd4e82d94df05a6191571962 inherit pub_methods_classmlir_1_1OpState"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename RetT  = detail::walkResultType&lt;FnT&gt;&gt; </td></tr>
<tr class="memitem:a38f85a4dbd4e82d94df05a6191571962 inherit pub_methods_classmlir_1_1OpState"><td class="memTemplItemLeft" align="right" valign="top">RetT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a38f85a4dbd4e82d94df05a6191571962">walk</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:a38f85a4dbd4e82d94df05a6191571962 inherit pub_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk the operation in postorder, calling the callback for each nested operation(including this one).  <a href="classmlir_1_1OpState.html#a38f85a4dbd4e82d94df05a6191571962">More...</a><br /></td></tr>
<tr class="separator:a38f85a4dbd4e82d94df05a6191571962 inherit pub_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html">mlir::OpTrait::detail::MultiOperandTraitBase&lt; AffineDmaStartOp, VariadicOperands &gt;</a></td></tr>
<tr class="memitem:a7279b84ca744536af8b46d115f57c55c inherit pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#a7279b84ca744536af8b46d115f57c55c">getNumOperands</a> ()</td></tr>
<tr class="memdesc:a7279b84ca744536af8b46d115f57c55c inherit pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of operands.  <a href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#a7279b84ca744536af8b46d115f57c55c">More...</a><br /></td></tr>
<tr class="separator:a7279b84ca744536af8b46d115f57c55c inherit pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f2e3f2a03ad80fc7552b6f26df5c83 inherit pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#a28f2e3f2a03ad80fc7552b6f26df5c83">getOperand</a> (unsigned i)</td></tr>
<tr class="memdesc:a28f2e3f2a03ad80fc7552b6f26df5c83 inherit pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the operand at index 'i'.  <a href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#a28f2e3f2a03ad80fc7552b6f26df5c83">More...</a><br /></td></tr>
<tr class="separator:a28f2e3f2a03ad80fc7552b6f26df5c83 inherit pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd04d9f9b4a2e190d23c7076f5bc2101 inherit pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#abd04d9f9b4a2e190d23c7076f5bc2101">setOperand</a> (unsigned i, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:abd04d9f9b4a2e190d23c7076f5bc2101 inherit pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the operand at index 'i' to 'value'.  <a href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#abd04d9f9b4a2e190d23c7076f5bc2101">More...</a><br /></td></tr>
<tr class="separator:abd04d9f9b4a2e190d23c7076f5bc2101 inherit pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ef31b93cfa2a0e60caec1c53861be9 inherit pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#aec354f48f345b77b3177e8b4292cc051">operand_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#a89ef31b93cfa2a0e60caec1c53861be9">operand_begin</a> ()</td></tr>
<tr class="memdesc:a89ef31b93cfa2a0e60caec1c53861be9 inherit pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operand iterator access.  <a href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#a89ef31b93cfa2a0e60caec1c53861be9">More...</a><br /></td></tr>
<tr class="separator:a89ef31b93cfa2a0e60caec1c53861be9 inherit pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af480283f813695310670d4d02427cca4 inherit pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#aec354f48f345b77b3177e8b4292cc051">operand_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#af480283f813695310670d4d02427cca4">operand_end</a> ()</td></tr>
<tr class="separator:af480283f813695310670d4d02427cca4 inherit pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6dd3c294a23d80b5315e90ae5f7230e inherit pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#a5b0c59db57bad8ce8bd0687f2527c4d3">operand_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#af6dd3c294a23d80b5315e90ae5f7230e">getOperands</a> ()</td></tr>
<tr class="separator:af6dd3c294a23d80b5315e90ae5f7230e inherit pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8e793527ea440121b18d70612f7f8a inherit pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#a3149b224fb36492b28735df58c6ebf9c">operand_type_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#a4f8e793527ea440121b18d70612f7f8a">operand_type_begin</a> ()</td></tr>
<tr class="memdesc:a4f8e793527ea440121b18d70612f7f8a inherit pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operand type access.  <a href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#a4f8e793527ea440121b18d70612f7f8a">More...</a><br /></td></tr>
<tr class="separator:a4f8e793527ea440121b18d70612f7f8a inherit pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4834e200c939a06818188582c6a6f3 inherit pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#a3149b224fb36492b28735df58c6ebf9c">operand_type_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#aad4834e200c939a06818188582c6a6f3">operand_type_end</a> ()</td></tr>
<tr class="separator:aad4834e200c939a06818188582c6a6f3 inherit pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c18f6cce42f8d8e4846f267a272581c inherit pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#a5e1584ddf6d1f7db90dafe734aebf86f">operand_type_range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#a4c18f6cce42f8d8e4846f267a272581c">getOperandTypes</a> ()</td></tr>
<tr class="separator:a4c18f6cce42f8d8e4846f267a272581c inherit pub_methods_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1FoldingHook"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1FoldingHook')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1FoldingHook.html">mlir::FoldingHook&lt; AffineDmaStartOp, llvm::is_one_of&lt; OpTrait::OneResult&lt; AffineDmaStartOp &gt;, OpTrait::VariadicOperands&lt; AffineDmaStartOp &gt;... &gt;::value &gt;</a></td></tr>
<tr class="memitem:af938ced93f6a45934750ed438228b3be inherit pub_methods_classmlir_1_1FoldingHook"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FoldingHook.html#af938ced93f6a45934750ed438228b3be">fold</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;results)</td></tr>
<tr class="memdesc:af938ced93f6a45934750ed438228b3be inherit pub_methods_classmlir_1_1FoldingHook"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook implements a generalized folder for this operation.  <a href="classmlir_1_1FoldingHook.html#af938ced93f6a45934750ed438228b3be">More...</a><br /></td></tr>
<tr class="separator:af938ced93f6a45934750ed438228b3be inherit pub_methods_classmlir_1_1FoldingHook"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a19883c4882629356846071044435680b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a19883c4882629356846071044435680b">build</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result, <a class="el" href="classmlir_1_1Value.html">Value</a> srcMemRef, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> srcMap, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> srcIndices, <a class="el" href="classmlir_1_1Value.html">Value</a> destMemRef, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> dstMap, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> destIndices, <a class="el" href="classmlir_1_1Value.html">Value</a> tagMemRef, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> tagMap, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> tagIndices, <a class="el" href="classmlir_1_1Value.html">Value</a> numElements, <a class="el" href="classmlir_1_1Value.html">Value</a> stride=nullptr, <a class="el" href="classmlir_1_1Value.html">Value</a> elementsPerStride=nullptr)</td></tr>
<tr class="separator:a19883c4882629356846071044435680b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa64aa7d1bb9b908ea4f836793179e4b"><td class="memItemLeft" align="right" valign="top">static StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#afa64aa7d1bb9b908ea4f836793179e4b">getSrcMapAttrName</a> ()</td></tr>
<tr class="separator:afa64aa7d1bb9b908ea4f836793179e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24bbc720694f4003299d4e478a31bb7"><td class="memItemLeft" align="right" valign="top">static StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#af24bbc720694f4003299d4e478a31bb7">getDstMapAttrName</a> ()</td></tr>
<tr class="separator:af24bbc720694f4003299d4e478a31bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e052a3fa4618b5f90afd332f86027aa"><td class="memItemLeft" align="right" valign="top">static StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a1e052a3fa4618b5f90afd332f86027aa">getTagMapAttrName</a> ()</td></tr>
<tr class="separator:a1e052a3fa4618b5f90afd332f86027aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3286959d4394136b2a8fd60efd3ad78e"><td class="memItemLeft" align="right" valign="top">static StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#a3286959d4394136b2a8fd60efd3ad78e">getOperationName</a> ()</td></tr>
<tr class="separator:a3286959d4394136b2a8fd60efd3ad78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb973563b8e0821187ad21c800bf595"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html#acbb973563b8e0821187ad21c800bf595">parse</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;<a class="el" href="classllvm_1_1cl_1_1parser.html">parser</a>, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result)</td></tr>
<tr class="separator:acbb973563b8e0821187ad21c800bf595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1Op"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmlir_1_1Op')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmlir_1_1Op.html">mlir::Op&lt; AffineDmaStartOp, OpTrait::VariadicOperands, OpTrait::ZeroResult &gt;</a></td></tr>
<tr class="memitem:ab0f28a9a8ea472061179fd53883ea589 inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#ab0f28a9a8ea472061179fd53883ea589">hasTrait</a> ()</td></tr>
<tr class="memdesc:ab0f28a9a8ea472061179fd53883ea589 inherit pub_static_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return if this operation contains the provided trait.  <a href="classmlir_1_1Op.html#ab0f28a9a8ea472061179fd53883ea589">More...</a><br /></td></tr>
<tr class="separator:ab0f28a9a8ea472061179fd53883ea589 inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1240be31ea922d33b1b2392e723a3b4e inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a1240be31ea922d33b1b2392e723a3b4e">classof</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a1240be31ea922d33b1b2392e723a3b4e inherit pub_static_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this "op class" can match against the specified operation.  <a href="classmlir_1_1Op.html#a1240be31ea922d33b1b2392e723a3b4e">More...</a><br /></td></tr>
<tr class="separator:a1240be31ea922d33b1b2392e723a3b4e inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d531e7cead5ce254711081dd928dcb3 inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a9d531e7cead5ce254711081dd928dcb3">parseAssembly</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;<a class="el" href="classllvm_1_1cl_1_1parser.html">parser</a>, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result)</td></tr>
<tr class="memdesc:a9d531e7cead5ce254711081dd928dcb3 inherit pub_static_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the hook used by the AsmParser to parse the custom form of this op from an .mlir file.  <a href="classmlir_1_1Op.html#a9d531e7cead5ce254711081dd928dcb3">More...</a><br /></td></tr>
<tr class="separator:a9d531e7cead5ce254711081dd928dcb3 inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25eec0f83831173fb40e58d16fedc4cf inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a25eec0f83831173fb40e58d16fedc4cf">printAssembly</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p)</td></tr>
<tr class="memdesc:a25eec0f83831173fb40e58d16fedc4cf inherit pub_static_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the hook used by the AsmPrinter to emit this to the .mlir file.  <a href="classmlir_1_1Op.html#a25eec0f83831173fb40e58d16fedc4cf">More...</a><br /></td></tr>
<tr class="separator:a25eec0f83831173fb40e58d16fedc4cf inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b9d3ca0e62afcf8aee0a047f6fd834 inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a81b9d3ca0e62afcf8aee0a047f6fd834">verifyInvariants</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a81b9d3ca0e62afcf8aee0a047f6fd834 inherit pub_static_methods_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the hook that checks whether or not this operation is well formed according to the invariants of its opcode.  <a href="classmlir_1_1Op.html#a81b9d3ca0e62afcf8aee0a047f6fd834">More...</a><br /></td></tr>
<tr class="separator:a81b9d3ca0e62afcf8aee0a047f6fd834 inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0222f1ce6e58f3142df4987396875f inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AbstractOperation.html#a57509b6bc9b3471f6a34ecadef4c4634">AbstractOperation::OperationProperties</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a8f0222f1ce6e58f3142df4987396875f">getOperationProperties</a> ()</td></tr>
<tr class="separator:a8f0222f1ce6e58f3142df4987396875f inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2c41a61d1531398c6bfc2f2ed1e4e8 inherit pub_static_methods_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Op.html#a63c65a9810b37ce3fa35ca27acdce394">ConcreteOpType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a2c2c41a61d1531398c6bfc2f2ed1e4e8">getFromOpaquePointer</a> (const void *pointer)</td></tr>
<tr class="separator:a2c2c41a61d1531398c6bfc2f2ed1e4e8 inherit pub_static_methods_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1OpState"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmlir_1_1OpState')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memitem:af8baadd6703443d0275f4839132eb44b inherit pub_static_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#af8baadd6703443d0275f4839132eb44b">getCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;results, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:af8baadd6703443d0275f4839132eb44b inherit pub_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook returns any canonicalization pattern rewrites that the operation supports, for use by the canonicalization pass.  <a href="classmlir_1_1OpState.html#af8baadd6703443d0275f4839132eb44b">More...</a><br /></td></tr>
<tr class="separator:af8baadd6703443d0275f4839132eb44b inherit pub_static_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1FoldingHook"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmlir_1_1FoldingHook')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmlir_1_1FoldingHook.html">mlir::FoldingHook&lt; AffineDmaStartOp, llvm::is_one_of&lt; OpTrait::OneResult&lt; AffineDmaStartOp &gt;, OpTrait::VariadicOperands&lt; AffineDmaStartOp &gt;... &gt;::value &gt;</a></td></tr>
<tr class="memitem:aad50a0fc7560458b00e8a1479aa47bea inherit pub_static_methods_classmlir_1_1FoldingHook"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FoldingHook.html#aad50a0fc7560458b00e8a1479aa47bea">foldHook</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;results)</td></tr>
<tr class="memdesc:aad50a0fc7560458b00e8a1479aa47bea inherit pub_static_methods_classmlir_1_1FoldingHook"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an implementation detail of the constant folder hook for AbstractOperation.  <a href="classmlir_1_1FoldingHook.html#aad50a0fc7560458b00e8a1479aa47bea">More...</a><br /></td></tr>
<tr class="separator:aad50a0fc7560458b00e8a1479aa47bea inherit pub_static_methods_classmlir_1_1FoldingHook"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classmlir_1_1Op"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmlir_1_1Op')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmlir_1_1Op.html">mlir::Op&lt; AffineDmaStartOp, OpTrait::VariadicOperands, OpTrait::ZeroResult &gt;</a></td></tr>
<tr class="memitem:a63c65a9810b37ce3fa35ca27acdce394 inherit pub_types_classmlir_1_1Op"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html#a63c65a9810b37ce3fa35ca27acdce394">ConcreteOpType</a> = <a class="el" href="classmlir_1_1AffineDmaStartOp.html">AffineDmaStartOp</a></td></tr>
<tr class="memdesc:a63c65a9810b37ce3fa35ca27acdce394 inherit pub_types_classmlir_1_1Op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expose the type we are instantiated on to template machinery that may want to introspect traits on this operation.  <a href="classmlir_1_1Op.html#a63c65a9810b37ce3fa35ca27acdce394">More...</a><br /></td></tr>
<tr class="separator:a63c65a9810b37ce3fa35ca27acdce394 inherit pub_types_classmlir_1_1Op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classmlir_1_1OpState"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmlir_1_1OpState')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memitem:a87cc746d9bbfe144144b1dd6735451dd inherit pub_types_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a87cc746d9bbfe144144b1dd6735451dd">dialect_attr_iterator</a> = <a class="el" href="classmlir_1_1Operation_1_1dialect__attr__iterator.html">Operation::dialect_attr_iterator</a></td></tr>
<tr class="memdesc:a87cc746d9bbfe144144b1dd6735451dd inherit pub_types_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility iterator that filters out non-dialect attributes.  <a href="classmlir_1_1OpState.html#a87cc746d9bbfe144144b1dd6735451dd">More...</a><br /></td></tr>
<tr class="separator:a87cc746d9bbfe144144b1dd6735451dd inherit pub_types_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12daf70ad798e71edf66e5464bc10404 inherit pub_types_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a12daf70ad798e71edf66e5464bc10404">dialect_attr_range</a> = <a class="el" href="classmlir_1_1Operation.html#a7eacb7f04d4808ff4b7da5479113d871">Operation::dialect_attr_range</a></td></tr>
<tr class="separator:a12daf70ad798e71edf66e5464bc10404 inherit pub_types_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html">mlir::OpTrait::detail::MultiOperandTraitBase&lt; AffineDmaStartOp, VariadicOperands &gt;</a></td></tr>
<tr class="memitem:aec354f48f345b77b3177e8b4292cc051 inherit pub_types_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#aec354f48f345b77b3177e8b4292cc051">operand_iterator</a> = <a class="el" href="classmlir_1_1Operation.html#ae9f435d73bdd799ad9f8ace519293a45">Operation::operand_iterator</a></td></tr>
<tr class="separator:aec354f48f345b77b3177e8b4292cc051 inherit pub_types_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0c59db57bad8ce8bd0687f2527c4d3 inherit pub_types_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#a5b0c59db57bad8ce8bd0687f2527c4d3">operand_range</a> = <a class="el" href="classmlir_1_1Operation.html#a8fc63f3d33e11994ab3330eb6e8990b9">Operation::operand_range</a></td></tr>
<tr class="separator:a5b0c59db57bad8ce8bd0687f2527c4d3 inherit pub_types_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3149b224fb36492b28735df58c6ebf9c inherit pub_types_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#a3149b224fb36492b28735df58c6ebf9c">operand_type_iterator</a> = <a class="el" href="classmlir_1_1Operation.html#a5e53beb4f1bb35758be804cf4deceb59">Operation::operand_type_iterator</a></td></tr>
<tr class="separator:a3149b224fb36492b28735df58c6ebf9c inherit pub_types_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1584ddf6d1f7db90dafe734aebf86f inherit pub_types_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#a5e1584ddf6d1f7db90dafe734aebf86f">operand_type_range</a> = <a class="el" href="classmlir_1_1Operation.html#a2e8b3322a1d2e4f8b825badf209789a7">Operation::operand_type_range</a></td></tr>
<tr class="separator:a5e1584ddf6d1f7db90dafe734aebf86f inherit pub_types_structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmlir_1_1OpState"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmlir_1_1OpState')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memitem:a353c0e5088dbb6624b01221f62262f78 inherit pro_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#a353c0e5088dbb6624b01221f62262f78">verify</a> ()</td></tr>
<tr class="memdesc:a353c0e5088dbb6624b01221f62262f78 inherit pro_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the concrete type didn't implement a custom verifier hook, just fall back to this one which accepts everything.  <a href="classmlir_1_1OpState.html#a353c0e5088dbb6624b01221f62262f78">More...</a><br /></td></tr>
<tr class="separator:a353c0e5088dbb6624b01221f62262f78 inherit pro_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fa98061d57976a6cfb301d61c1d376 inherit pro_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#aa1fa98061d57976a6cfb301d61c1d376">print</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p)</td></tr>
<tr class="separator:aa1fa98061d57976a6cfb301d61c1d376 inherit pro_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cb0c062a04c9797e443d2ee1a4d9e7 inherit pro_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#ad2cb0c062a04c9797e443d2ee1a4d9e7">OpState</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *state)</td></tr>
<tr class="memdesc:ad2cb0c062a04c9797e443d2ee1a4d9e7 inherit pro_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutability management is handled by the OpWrapper/OpConstWrapper classes, so we can cast it away here.  <a href="classmlir_1_1OpState.html#ad2cb0c062a04c9797e443d2ee1a4d9e7">More...</a><br /></td></tr>
<tr class="separator:ad2cb0c062a04c9797e443d2ee1a4d9e7 inherit pro_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmlir_1_1OpTrait_1_1TraitBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmlir_1_1OpTrait_1_1TraitBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmlir_1_1OpTrait_1_1TraitBase.html">mlir::OpTrait::TraitBase&lt; AffineDmaStartOp, VariadicOperands &gt;</a></td></tr>
<tr class="memitem:aba6545e9c958929a57b6f37947fab14d inherit pro_methods_classmlir_1_1OpTrait_1_1TraitBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1TraitBase.html#aba6545e9c958929a57b6f37947fab14d">getOperation</a> ()</td></tr>
<tr class="memdesc:aba6545e9c958929a57b6f37947fab14d inherit pro_methods_classmlir_1_1OpTrait_1_1TraitBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ultimate Operation being worked on.  <a href="classmlir_1_1OpTrait_1_1TraitBase.html#aba6545e9c958929a57b6f37947fab14d">More...</a><br /></td></tr>
<tr class="separator:aba6545e9c958929a57b6f37947fab14d inherit pro_methods_classmlir_1_1OpTrait_1_1TraitBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classmlir_1_1OpState"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classmlir_1_1OpState')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memitem:abcfdfbc4f6158e19c5993549247132fb inherit pro_static_methods_classmlir_1_1OpState"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html#abcfdfbc4f6158e19c5993549247132fb">parse</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;<a class="el" href="classllvm_1_1cl_1_1parser.html">parser</a>, <a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;result)</td></tr>
<tr class="memdesc:abcfdfbc4f6158e19c5993549247132fb inherit pro_static_methods_classmlir_1_1OpState"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unless overridden, the custom assembly form of an op is always rejected.  <a href="classmlir_1_1OpState.html#abcfdfbc4f6158e19c5993549247132fb">More...</a><br /></td></tr>
<tr class="separator:abcfdfbc4f6158e19c5993549247132fb inherit pro_static_methods_classmlir_1_1OpState"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classmlir_1_1OpTrait_1_1TraitBase"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classmlir_1_1OpTrait_1_1TraitBase')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classmlir_1_1OpTrait_1_1TraitBase.html">mlir::OpTrait::TraitBase&lt; AffineDmaStartOp, VariadicOperands &gt;</a></td></tr>
<tr class="memitem:a9105d11a7b603c326049ba2760b60e8b inherit pro_static_methods_classmlir_1_1OpTrait_1_1TraitBase"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1TraitBase.html#a9105d11a7b603c326049ba2760b60e8b">verifyTrait</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a9105d11a7b603c326049ba2760b60e8b inherit pro_static_methods_classmlir_1_1OpTrait_1_1TraitBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide default implementations of trait hooks.  <a href="classmlir_1_1OpTrait_1_1TraitBase.html#a9105d11a7b603c326049ba2760b60e8b">More...</a><br /></td></tr>
<tr class="separator:a9105d11a7b603c326049ba2760b60e8b inherit pro_static_methods_classmlir_1_1OpTrait_1_1TraitBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2584d29be2078d57d5a33443e6f0d5c inherit pro_static_methods_classmlir_1_1OpTrait_1_1TraitBase"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AbstractOperation.html#a57509b6bc9b3471f6a34ecadef4c4634">AbstractOperation::OperationProperties</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1TraitBase.html#ae2584d29be2078d57d5a33443e6f0d5c">getTraitProperties</a> ()</td></tr>
<tr class="separator:ae2584d29be2078d57d5a33443e6f0d5c inherit pro_static_methods_classmlir_1_1OpTrait_1_1TraitBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classmlir_1_1AffineDmaStartOp.html" title="AffineDmaStartOp starts a non-blocking DMA operation that transfers data from a source memref to a de...">AffineDmaStartOp</a> starts a non-blocking DMA operation that transfers data from a source memref to a destination memref. </p>
<p>The source and destination memref need not be of the same dimensionality, but need to have the same elemental type. The operands include the source and destination memref's each followed by its indices, size of the data transfer in terms of the number of elements (of the elemental type of the memref), a tag memref with its indices, and optionally at the end, a stride and a number_of_elements_per_stride arguments. The tag location is used by an <a class="el" href="classmlir_1_1AffineDmaWaitOp.html" title="AffineDmaWaitOp blocks until the completion of a DMA operation associated with the tag element &#39;tag[i...">AffineDmaWaitOp</a> to check for completion. The indices of the source memref, destination memref, and the tag memref have the same restrictions as any affine.load/store. In particular, index for each memref dimension must be an affine expression of loop induction variables and symbols. The optional stride arguments should be of 'index' type, and specify a stride for the slower memory space (memory space with a lower memory space id), transferring chunks of number_of_elements_per_stride every stride until num_elements are transferred. Either both or no stride arguments should be specified. The value of 'num_elements' must be a multiple of 'number_of_elements_per_stride'. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00083">83</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a19883c4882629356846071044435680b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19883c4882629356846071044435680b">&#9670;&nbsp;</a></span>build()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AffineDmaStartOp::build </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>srcMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>srcMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>srcIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>destMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>dstMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>destIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>tagMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>tagMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>tagIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>stride</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>elementsPerStride</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00931">931</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00386">mlir::OperationState::addAttribute()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00185">mlir::OperationState::addOperands()</a>, and <a class="el" href="Attributes_8cpp_source.html#l00058">mlir::AffineMapAttr::get()</a>.</p>

</div>
</div>
<a id="af0550bb3a330b3f291f20deade5b58d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0550bb3a330b3f291f20deade5b58d1">&#9670;&nbsp;</a></span>fold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> AffineDmaStartOp::fold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>cstOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>dma_start(memrefcast) -&gt; dma_start </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01090">1090</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00914">foldMemRefCast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00230">getOperationName()</a>, and <a class="el" href="AffineOps_8h_source.html#l00314">mlir::AffineDmaWaitOp::getTagMapAttrName()</a>.</p>

</div>
</div>
<a id="a6d0032ca693e04d266e33693352f7cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0032ca693e04d266e33693352f7cb7">&#9670;&nbsp;</a></span>getAffineMapAttrForMemRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a2bd440a077557b4421b2cfd06d48956a">NamedAttribute</a> mlir::AffineDmaStartOp::getAffineMapAttrForMemRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>memref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classmlir_1_1AffineMapAttr.html">AffineMapAttr</a> associated with 'memref'. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00194">194</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00631">mlir::Identifier::get()</a>, <a class="el" href="OpDefinition_8h_source.html#l00123">mlir::OpState::getContext()</a>, <a class="el" href="AffineOps_8h_source.html#l00147">getDstMapAttr()</a>, <a class="el" href="AffineOps_8h_source.html#l00227">getDstMapAttrName()</a>, <a class="el" href="AffineOps_8h_source.html#l00130">getDstMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00108">getSrcMapAttr()</a>, <a class="el" href="AffineOps_8h_source.html#l00226">getSrcMapAttrName()</a>, <a class="el" href="AffineOps_8h_source.html#l00098">getSrcMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00176">getTagMapAttr()</a>, <a class="el" href="AffineOps_8h_source.html#l00228">getTagMapAttrName()</a>, and <a class="el" href="AffineOps_8h_source.html#l00164">getTagMemRef()</a>.</p>

</div>
</div>
<a id="a87dbb4d8b9952f3020ba83c3a1e6ef30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87dbb4d8b9952f3020ba83c3a1e6ef30">&#9670;&nbsp;</a></span>getDstIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#a5b0c59db57bad8ce8bd0687f2527c4d3">operand_range</a> mlir::AffineDmaStartOp::getDstIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the destination memref indices for this DMA operation. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00152">152</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00146">getDstMap()</a>, <a class="el" href="AffineOps_8h_source.html#l00125">getDstMemRefOperandIndex()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00215">mlir::AffineMap::getNumInputs()</a>, and <a class="el" href="OpDefinition_8h_source.html#l00456">mlir::OpTrait::detail::MultiOperandTraitBase&lt; AffineDmaStartOp, VariadicOperands &gt;::operand_begin()</a>.</p>

</div>
</div>
<a id="ad1071dcc7323a4600ba6632a8da6e568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1071dcc7323a4600ba6632a8da6e568">&#9670;&nbsp;</a></span>getDstMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::AffineDmaStartOp::getDstMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the affine map used to access the dst memref. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00146">146</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00147">getDstMapAttr()</a>, and <a class="el" href="Attributes_8cpp_source.html#l00062">mlir::AffineMapAttr::getValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00152">getDstIndices()</a>, <a class="el" href="AffineOps_8h_source.html#l00159">getTagMemRefOperandIndex()</a>, and <a class="el" href="AffineToStandard_8cpp_source.html#l00292">mlir::lowerAffineLowerBound()</a>.</p>

</div>
</div>
<a id="ae3f4727e1b39839f61634fd76a18ba45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f4727e1b39839f61634fd76a18ba45">&#9670;&nbsp;</a></span>getDstMapAttr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMapAttr.html">AffineMapAttr</a> mlir::AffineDmaStartOp::getDstMapAttr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00147">147</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l01624">mlir::Attribute::cast()</a>, <a class="el" href="OpDefinition_8h_source.html#l00156">mlir::OpState::getAttr()</a>, and <a class="el" href="AffineOps_8h_source.html#l00227">getDstMapAttrName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00194">getAffineMapAttrForMemRef()</a>, and <a class="el" href="AffineOps_8h_source.html#l00146">getDstMap()</a>.</p>

</div>
</div>
<a id="af24bbc720694f4003299d4e478a31bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24bbc720694f4003299d4e478a31bb7">&#9670;&nbsp;</a></span>getDstMapAttrName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static StringRef mlir::AffineDmaStartOp::getDstMapAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00227">227</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00194">getAffineMapAttrForMemRef()</a>, and <a class="el" href="AffineOps_8h_source.html#l00147">getDstMapAttr()</a>.</p>

</div>
</div>
<a id="a343a3dd850208dec35b4b1b193562a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343a3dd850208dec35b4b1b193562a3d">&#9670;&nbsp;</a></span>getDstMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::AffineDmaStartOp::getDstMemorySpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the memory space of the src memref. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00141">141</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00328">mlir::Type::cast()</a>, <a class="el" href="AffineOps_8h_source.html#l00130">getDstMemRef()</a>, and <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00208">isDestMemorySpaceFaster()</a>, and <a class="el" href="AffineOps_8h_source.html#l00213">isSrcMemorySpaceFaster()</a>.</p>

</div>
</div>
<a id="a780f50de5bdcfa29a131e941050fdcd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780f50de5bdcfa29a131e941050fdcd1">&#9670;&nbsp;</a></span>getDstMemRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::AffineDmaStartOp::getDstMemRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the destination <a class="el" href="classmlir_1_1MemRefType.html" title="MemRef types represent a region of memory that have a shape with a fixed number of dimensions...">MemRefType</a> for this DMA operations. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00130">130</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00125">getDstMemRefOperandIndex()</a>, and <a class="el" href="OpDefinition_8h_source.html#l00448">mlir::OpTrait::detail::MultiOperandTraitBase&lt; AffineDmaStartOp, VariadicOperands &gt;::getOperand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00194">getAffineMapAttrForMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00141">getDstMemorySpace()</a>, <a class="el" href="AffineOps_8h_source.html#l00136">getDstMemRefRank()</a>, and <a class="el" href="AffineOps_8h_source.html#l00131">getDstMemRefType()</a>.</p>

</div>
</div>
<a id="ac8405ebd5893de7ec19d347074057295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8405ebd5893de7ec19d347074057295">&#9670;&nbsp;</a></span>getDstMemRefOperandIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::AffineDmaStartOp::getDstMemRefOperandIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the operand index of the dst memref. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00125">125</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineMap_8cpp_source.html#l00215">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="AffineOps_8h_source.html#l00107">getSrcMap()</a>, and <a class="el" href="AffineOps_8h_source.html#l00095">getSrcMemRefOperandIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00152">getDstIndices()</a>, <a class="el" href="AffineOps_8h_source.html#l00130">getDstMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00221">getFasterMemPos()</a>, <a class="el" href="AffineOps_8h_source.html#l00159">getTagMemRefOperandIndex()</a>, and <a class="el" href="AffineToStandard_8cpp_source.html#l00292">mlir::lowerAffineLowerBound()</a>.</p>

</div>
</div>
<a id="a1479ef9963ac09985141a38ea5939946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1479ef9963ac09985141a38ea5939946">&#9670;&nbsp;</a></span>getDstMemRefRank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::AffineDmaStartOp::getDstMemRefRank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rank (number of indices) of the destination <a class="el" href="classmlir_1_1MemRefType.html" title="MemRef types represent a region of memory that have a shape with a fixed number of dimensions...">MemRefType</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00136">136</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00328">mlir::Type::cast()</a>, <a class="el" href="AffineOps_8h_source.html#l00130">getDstMemRef()</a>, and <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="af1763308691b432116b413ea27d890bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1763308691b432116b413ea27d890bf">&#9670;&nbsp;</a></span>getDstMemRefType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a> mlir::AffineDmaStartOp::getDstMemRefType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00131">131</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00328">mlir::Type::cast()</a>, <a class="el" href="AffineOps_8h_source.html#l00130">getDstMemRef()</a>, and <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a3c816ecef9218bae44396d375ae2755e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c816ecef9218bae44396d375ae2755e">&#9670;&nbsp;</a></span>getFasterMemPos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::AffineDmaStartOp::getFasterMemPos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a DMA start operation, returns the operand position of either the source or destination memref depending on the one that is at the higher level of the memory hierarchy. </p>
<p>Asserts failure if neither is true. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00221">221</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00125">getDstMemRefOperandIndex()</a>, <a class="el" href="AffineOps_8h_source.html#l00208">isDestMemorySpaceFaster()</a>, and <a class="el" href="AffineOps_8h_source.html#l00213">isSrcMemorySpaceFaster()</a>.</p>

</div>
</div>
<a id="a202053be4264f6904749c574c62e66f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202053be4264f6904749c574c62e66f8">&#9670;&nbsp;</a></span>getNumElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::AffineDmaStartOp::getNumElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements being transferred by this DMA operation. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00188">188</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00448">mlir::OpTrait::detail::MultiOperandTraitBase&lt; AffineDmaStartOp, VariadicOperands &gt;::getOperand()</a>, <a class="el" href="AffineOps_8h_source.html#l00175">getTagMap()</a>, and <a class="el" href="AffineOps_8h_source.html#l00159">getTagMemRefOperandIndex()</a>.</p>

</div>
</div>
<a id="ae9ef6994b499ac19c668537866452ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ef6994b499ac19c668537866452ef0">&#9670;&nbsp;</a></span>getNumElementsPerStride()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::AffineDmaStartOp::getNumElementsPerStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements to transfer per stride for this DMA op. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00251">251</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00445">mlir::OpTrait::detail::MultiOperandTraitBase&lt; AffineDmaStartOp, VariadicOperands &gt;::getNumOperands()</a>, <a class="el" href="OpDefinition_8h_source.html#l00448">mlir::OpTrait::detail::MultiOperandTraitBase&lt; AffineDmaStartOp, VariadicOperands &gt;::getOperand()</a>, and <a class="el" href="AffineOps_8h_source.html#l00238">isStrided()</a>.</p>

</div>
</div>
<a id="a3286959d4394136b2a8fd60efd3ad78e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3286959d4394136b2a8fd60efd3ad78e">&#9670;&nbsp;</a></span>getOperationName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static StringRef mlir::AffineDmaStartOp::getOperationName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00230">230</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01090">fold()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00975">parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00953">print()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01048">verify()</a>.</p>

</div>
</div>
<a id="afdd0116c02294ad87dd632b855f8112a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd0116c02294ad87dd632b855f8112a">&#9670;&nbsp;</a></span>getSrcIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#a5b0c59db57bad8ce8bd0687f2527c4d3">operand_range</a> mlir::AffineDmaStartOp::getSrcIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the source memref affine map indices for this DMA operation. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00113">113</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineMap_8cpp_source.html#l00215">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="AffineOps_8h_source.html#l00107">getSrcMap()</a>, <a class="el" href="AffineOps_8h_source.html#l00095">getSrcMemRefOperandIndex()</a>, and <a class="el" href="OpDefinition_8h_source.html#l00456">mlir::OpTrait::detail::MultiOperandTraitBase&lt; AffineDmaStartOp, VariadicOperands &gt;::operand_begin()</a>.</p>

</div>
</div>
<a id="acd808c35b1a94571b9afb7cc6d8400b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd808c35b1a94571b9afb7cc6d8400b0">&#9670;&nbsp;</a></span>getSrcMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::AffineDmaStartOp::getSrcMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the affine map used to access the src memref. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00107">107</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00108">getSrcMapAttr()</a>, and <a class="el" href="Attributes_8cpp_source.html#l00062">mlir::AffineMapAttr::getValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00125">getDstMemRefOperandIndex()</a>, <a class="el" href="AffineOps_8h_source.html#l00113">getSrcIndices()</a>, and <a class="el" href="AffineToStandard_8cpp_source.html#l00292">mlir::lowerAffineLowerBound()</a>.</p>

</div>
</div>
<a id="af916c2797cb31cc32c209039862dafec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af916c2797cb31cc32c209039862dafec">&#9670;&nbsp;</a></span>getSrcMapAttr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMapAttr.html">AffineMapAttr</a> mlir::AffineDmaStartOp::getSrcMapAttr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00108">108</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l01624">mlir::Attribute::cast()</a>, <a class="el" href="OpDefinition_8h_source.html#l00156">mlir::OpState::getAttr()</a>, and <a class="el" href="AffineOps_8h_source.html#l00226">getSrcMapAttrName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00194">getAffineMapAttrForMemRef()</a>, and <a class="el" href="AffineOps_8h_source.html#l00107">getSrcMap()</a>.</p>

</div>
</div>
<a id="afa64aa7d1bb9b908ea4f836793179e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa64aa7d1bb9b908ea4f836793179e4b">&#9670;&nbsp;</a></span>getSrcMapAttrName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static StringRef mlir::AffineDmaStartOp::getSrcMapAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00226">226</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00194">getAffineMapAttrForMemRef()</a>, and <a class="el" href="AffineOps_8h_source.html#l00108">getSrcMapAttr()</a>.</p>

</div>
</div>
<a id="aca580bc4d944e79bef3b27e9cd4bb064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca580bc4d944e79bef3b27e9cd4bb064">&#9670;&nbsp;</a></span>getSrcMemorySpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::AffineDmaStartOp::getSrcMemorySpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the memory space of the src memref. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00120">120</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00328">mlir::Type::cast()</a>, <a class="el" href="AffineOps_8h_source.html#l00098">getSrcMemRef()</a>, and <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00208">isDestMemorySpaceFaster()</a>, and <a class="el" href="AffineOps_8h_source.html#l00213">isSrcMemorySpaceFaster()</a>.</p>

</div>
</div>
<a id="a8df5461067827388e19a459177ea8027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df5461067827388e19a459177ea8027">&#9670;&nbsp;</a></span>getSrcMemRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::AffineDmaStartOp::getSrcMemRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the source <a class="el" href="classmlir_1_1MemRefType.html" title="MemRef types represent a region of memory that have a shape with a fixed number of dimensions...">MemRefType</a> for this DMA operation. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00098">98</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00448">mlir::OpTrait::detail::MultiOperandTraitBase&lt; AffineDmaStartOp, VariadicOperands &gt;::getOperand()</a>, and <a class="el" href="AffineOps_8h_source.html#l00095">getSrcMemRefOperandIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00194">getAffineMapAttrForMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00120">getSrcMemorySpace()</a>, and <a class="el" href="AffineOps_8h_source.html#l00099">getSrcMemRefType()</a>.</p>

</div>
</div>
<a id="a20647412938b7c5ac6c7d126e46aa0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20647412938b7c5ac6c7d126e46aa0b0">&#9670;&nbsp;</a></span>getSrcMemRefOperandIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::AffineDmaStartOp::getSrcMemRefOperandIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the operand index of the src memref. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00095">95</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00125">getDstMemRefOperandIndex()</a>, <a class="el" href="AffineOps_8h_source.html#l00113">getSrcIndices()</a>, <a class="el" href="AffineOps_8h_source.html#l00098">getSrcMemRef()</a>, and <a class="el" href="AffineToStandard_8cpp_source.html#l00292">mlir::lowerAffineLowerBound()</a>.</p>

</div>
</div>
<a id="a7668f3b3e876c6cfedf29822a71859a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7668f3b3e876c6cfedf29822a71859a3">&#9670;&nbsp;</a></span>getSrcMemRefRank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::AffineDmaStartOp::getSrcMemRefRank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rank (number of indices) of the source <a class="el" href="classmlir_1_1MemRefType.html" title="MemRef types represent a region of memory that have a shape with a fixed number of dimensions...">MemRefType</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00104">104</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00099">getSrcMemRefType()</a>.</p>

</div>
</div>
<a id="a3651e5d95c9fe31d470e4d7b4952481b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3651e5d95c9fe31d470e4d7b4952481b">&#9670;&nbsp;</a></span>getSrcMemRefType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a> mlir::AffineDmaStartOp::getSrcMemRefType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00099">99</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00328">mlir::Type::cast()</a>, <a class="el" href="AffineOps_8h_source.html#l00098">getSrcMemRef()</a>, and <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00104">getSrcMemRefRank()</a>.</p>

</div>
</div>
<a id="a50e74d1c1e2a656c1c2ddc221d198987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e74d1c1e2a656c1c2ddc221d198987">&#9670;&nbsp;</a></span>getStride()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::AffineDmaStartOp::getStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the stride value for this DMA operation. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00244">244</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00445">mlir::OpTrait::detail::MultiOperandTraitBase&lt; AffineDmaStartOp, VariadicOperands &gt;::getNumOperands()</a>, <a class="el" href="OpDefinition_8h_source.html#l00448">mlir::OpTrait::detail::MultiOperandTraitBase&lt; AffineDmaStartOp, VariadicOperands &gt;::getOperand()</a>, and <a class="el" href="AffineOps_8h_source.html#l00238">isStrided()</a>.</p>

</div>
</div>
<a id="aa583874531e254538cac4f0af7cbdffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa583874531e254538cac4f0af7cbdffd">&#9670;&nbsp;</a></span>getTagIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#a5b0c59db57bad8ce8bd0687f2527c4d3">operand_range</a> mlir::AffineDmaStartOp::getTagIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tag memref indices for this DMA operation. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00181">181</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineMap_8cpp_source.html#l00215">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="AffineOps_8h_source.html#l00175">getTagMap()</a>, <a class="el" href="AffineOps_8h_source.html#l00159">getTagMemRefOperandIndex()</a>, and <a class="el" href="OpDefinition_8h_source.html#l00456">mlir::OpTrait::detail::MultiOperandTraitBase&lt; AffineDmaStartOp, VariadicOperands &gt;::operand_begin()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00141">checkTagMatch()</a>.</p>

</div>
</div>
<a id="a5f8fc80d81f721e96e2403a32e776b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8fc80d81f721e96e2403a32e776b2b">&#9670;&nbsp;</a></span>getTagMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::AffineDmaStartOp::getTagMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the affine map used to access the tag memref. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00175">175</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00176">getTagMapAttr()</a>, and <a class="el" href="Attributes_8cpp_source.html#l00062">mlir::AffineMapAttr::getValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00188">getNumElements()</a>, <a class="el" href="AffineOps_8h_source.html#l00312">mlir::AffineDmaWaitOp::getNumElements()</a>, <a class="el" href="AffineOps_8h_source.html#l00181">getTagIndices()</a>, <a class="el" href="AffineOps_8h_source.html#l00294">mlir::AffineDmaWaitOp::getTagIndices()</a>, <a class="el" href="AffineOps_8h_source.html#l00238">isStrided()</a>, and <a class="el" href="AffineToStandard_8cpp_source.html#l00292">mlir::lowerAffineLowerBound()</a>.</p>

</div>
</div>
<a id="a305b5739572b65da83f894e4fab37cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305b5739572b65da83f894e4fab37cbf">&#9670;&nbsp;</a></span>getTagMapAttr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMapAttr.html">AffineMapAttr</a> mlir::AffineDmaStartOp::getTagMapAttr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00176">176</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l01624">mlir::Attribute::cast()</a>, <a class="el" href="OpDefinition_8h_source.html#l00156">mlir::OpState::getAttr()</a>, and <a class="el" href="AffineOps_8h_source.html#l00228">getTagMapAttrName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00194">getAffineMapAttrForMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00305">mlir::AffineDmaWaitOp::getAffineMapAttrForMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00175">getTagMap()</a>, and <a class="el" href="AffineOps_8h_source.html#l00288">mlir::AffineDmaWaitOp::getTagMap()</a>.</p>

</div>
</div>
<a id="a1e052a3fa4618b5f90afd332f86027aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e052a3fa4618b5f90afd332f86027aa">&#9670;&nbsp;</a></span>getTagMapAttrName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static StringRef mlir::AffineDmaStartOp::getTagMapAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00228">228</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00194">getAffineMapAttrForMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00305">mlir::AffineDmaWaitOp::getAffineMapAttrForMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00176">getTagMapAttr()</a>, and <a class="el" href="AffineOps_8h_source.html#l00289">mlir::AffineDmaWaitOp::getTagMapAttr()</a>.</p>

</div>
</div>
<a id="a58573e225acd3779ffcbce9c0f221b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58573e225acd3779ffcbce9c0f221b62">&#9670;&nbsp;</a></span>getTagMemRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::AffineDmaStartOp::getTagMemRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Tag MemRef for this DMA operation. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00164">164</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00448">mlir::OpTrait::detail::MultiOperandTraitBase&lt; AffineDmaStartOp, VariadicOperands &gt;::getOperand()</a>, and <a class="el" href="AffineOps_8h_source.html#l00159">getTagMemRefOperandIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00141">checkTagMatch()</a>, <a class="el" href="AffineOps_8h_source.html#l00194">getAffineMapAttrForMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00305">mlir::AffineDmaWaitOp::getAffineMapAttrForMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00170">getTagMemRefRank()</a>, <a class="el" href="AffineOps_8h_source.html#l00300">mlir::AffineDmaWaitOp::getTagMemRefRank()</a>, <a class="el" href="AffineOps_8h_source.html#l00165">getTagMemRefType()</a>, and <a class="el" href="AffineOps_8h_source.html#l00283">mlir::AffineDmaWaitOp::getTagMemRefType()</a>.</p>

</div>
</div>
<a id="a24197fa6a7763cbe95231f94440a1d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24197fa6a7763cbe95231f94440a1d6f">&#9670;&nbsp;</a></span>getTagMemRefOperandIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::AffineDmaStartOp::getTagMemRefOperandIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the operand index of the tag memref. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00159">159</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00146">getDstMap()</a>, <a class="el" href="AffineOps_8h_source.html#l00125">getDstMemRefOperandIndex()</a>, and <a class="el" href="AffineMap_8cpp_source.html#l00215">mlir::AffineMap::getNumInputs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00188">getNumElements()</a>, <a class="el" href="AffineOps_8h_source.html#l00181">getTagIndices()</a>, <a class="el" href="AffineOps_8h_source.html#l00164">getTagMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00238">isStrided()</a>, and <a class="el" href="AffineToStandard_8cpp_source.html#l00292">mlir::lowerAffineLowerBound()</a>.</p>

</div>
</div>
<a id="a53d6292747dc7158fa1f89cdd7421e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d6292747dc7158fa1f89cdd7421e27">&#9670;&nbsp;</a></span>getTagMemRefRank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::AffineDmaStartOp::getTagMemRefRank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rank (number of indices) of the tag <a class="el" href="classmlir_1_1MemRefType.html" title="MemRef types represent a region of memory that have a shape with a fixed number of dimensions...">MemRefType</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00170">170</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00328">mlir::Type::cast()</a>, <a class="el" href="AffineOps_8h_source.html#l00164">getTagMemRef()</a>, and <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a46c1413eb6cf07334af04f2444e24524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c1413eb6cf07334af04f2444e24524">&#9670;&nbsp;</a></span>getTagMemRefType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a> mlir::AffineDmaStartOp::getTagMemRefType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00165">165</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00328">mlir::Type::cast()</a>, <a class="el" href="AffineOps_8h_source.html#l00164">getTagMemRef()</a>, and <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a214228a73e969cbb97bf52b9fb0004da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214228a73e969cbb97bf52b9fb0004da">&#9670;&nbsp;</a></span>isDestMemorySpaceFaster()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::AffineDmaStartOp::isDestMemorySpaceFaster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this is a DMA from a faster memory space to a slower one. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00208">208</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00141">getDstMemorySpace()</a>, and <a class="el" href="AffineOps_8h_source.html#l00120">getSrcMemorySpace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00221">getFasterMemPos()</a>.</p>

</div>
</div>
<a id="a6a401c930cc6f0c0eb393f85e38b0586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a401c930cc6f0c0eb393f85e38b0586">&#9670;&nbsp;</a></span>isSrcMemorySpaceFaster()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::AffineDmaStartOp::isSrcMemorySpaceFaster </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this is a DMA from a slower memory space to a faster one. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00213">213</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8h_source.html#l00141">getDstMemorySpace()</a>, and <a class="el" href="AffineOps_8h_source.html#l00120">getSrcMemorySpace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00221">getFasterMemPos()</a>.</p>

</div>
</div>
<a id="a3c8e973a7baf40d04164ba7f16e2652c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c8e973a7baf40d04164ba7f16e2652c">&#9670;&nbsp;</a></span>isStrided()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::AffineDmaStartOp::isStrided </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if this DMA operation is strided, returns false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8h_source.html#l00238">238</a> of file <a class="el" href="AffineOps_8h_source.html">AffineOps.h</a>.</p>

<p class="reference">References <a class="el" href="AffineMap_8cpp_source.html#l00215">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="OpDefinition_8h_source.html#l00445">mlir::OpTrait::detail::MultiOperandTraitBase&lt; AffineDmaStartOp, VariadicOperands &gt;::getNumOperands()</a>, <a class="el" href="AffineOps_8h_source.html#l00175">getTagMap()</a>, and <a class="el" href="AffineOps_8h_source.html#l00159">getTagMemRefOperandIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00251">getNumElementsPerStride()</a>, and <a class="el" href="AffineOps_8h_source.html#l00244">getStride()</a>.</p>

</div>
</div>
<a id="acbb973563b8e0821187ad21c800bf595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb973563b8e0821187ad21c800bf595">&#9670;&nbsp;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> AffineDmaStartOp::parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00975">975</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00358">mlir::OperationState::attributes</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#ac3a2f1a3a2d17f965d1d88ec6e61d47e">mlir::OpAsmParser::emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a06b1d7cb826bcceb3ce2fe325faff660">mlir::OpAsmParser::getBuilder()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00053">mlir::Builder::getIndexType()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a781e419cb942473f4525713e0dcf96c7">mlir::OpAsmParser::getNameLoc()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00215">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="Attributes_8cpp_source.html#l00062">mlir::AffineMapAttr::getValue()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00789">mlir::isStrided()</a>, <a class="el" href="OperationSupport_8h_source.html#l00355">mlir::OperationState::operands</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a437b92f6707df30e9777badc67a0ac5e">mlir::OpAsmParser::parseAffineMapOfSSAIds()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a94fd19ea651787f7c026423255f019db">mlir::OpAsmParser::parseColonTypeList()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a8351a971b77eaf6084069ee613635c21">mlir::OpAsmParser::parseComma()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a831b824383364f6f9e2de455a5b3ad13">mlir::OpAsmParser::parseOperand()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#aa24c2037cb83360163d7b7a209f986f4">mlir::OpAsmParser::parseTrailingOperandList()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a14acb0e25d0d6adcc98b99467b479bcc">mlir::OpAsmParser::resolveOperand()</a>, <a class="el" href="OpImplementation_8h_source.html#l00514">mlir::OpAsmParser::resolveOperands()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00230">getOperationName()</a>, and <a class="el" href="AffineOps_8h_source.html#l00314">mlir::AffineDmaWaitOp::getTagMapAttrName()</a>.</p>

</div>
</div>
<a id="a4a378a1f108aa52ebda32f5df80c4e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a378a1f108aa52ebda32f5df80c4e3e">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AffineDmaStartOp::print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00953">953</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardTypes_8cpp_source.html#l00789">mlir::isStrided()</a>, and <a class="el" href="classmlir_1_1OpAsmPrinter.html#aa04de9fec0531cddf28646b119a770af">mlir::OpAsmPrinter::printAffineMapOfSSAIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00230">getOperationName()</a>, and <a class="el" href="AffineOps_8h_source.html#l00314">mlir::AffineDmaWaitOp::getTagMapAttrName()</a>.</p>

</div>
</div>
<a id="a3f3f59c96b14a93dd1f124c385b3d876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3f59c96b14a93dd1f124c385b3d876">&#9670;&nbsp;</a></span>verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> AffineDmaStartOp::verify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01048">1048</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00117">getAffineScope()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00291">isValidAffineIndexOperand()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00230">getOperationName()</a>, and <a class="el" href="AffineOps_8h_source.html#l00314">mlir::AffineDmaWaitOp::getTagMapAttrName()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Dialect/Affine/IR/<a class="el" href="AffineOps_8h_source.html">AffineOps.h</a></li>
<li>lib/Dialect/Affine/IR/<a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Aug 8 2020 16:27:19 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
