<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::detail::Parser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">12.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1detail.html">detail</a></li><li class="navelem"><a class="el" href="classmlir_1_1detail_1_1Parser.html">Parser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classmlir_1_1detail_1_1Parser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::detail::Parser Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class implement support for parsing global entities like attributes and types.  
 <a href="classmlir_1_1detail_1_1Parser.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="lib_2Parser_2Parser_8h_source.html">Parser/Parser.h</a>&quot;</code></p>
<div class="dynheader">
Collaboration diagram for mlir::detail::Parser:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1detail_1_1Parser__coll__graph.png" border="0" usemap="#mlir_1_1detail_1_1Parser_coll__map" alt="Collaboration graph"/></div>
<map name="mlir_1_1detail_1_1Parser_coll__map" id="mlir_1_1detail_1_1Parser_coll__map">
<area shape="rect" id="node2" href="classmlir_1_1Builder.html" title="This class is a general helper class for creating context&#45;global objects like types, attributes, and affine expressions. " alt="" coords="25,95,115,121"/>
<area shape="rect" id="node3" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top&#45;level object for a collection of MLIR modules. " alt="" coords="5,5,135,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5956970a704f868a930be61951ba9710"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a5956970a704f868a930be61951ba9710">Parser</a> (<a class="el" href="structmlir_1_1detail_1_1ParserState.html">ParserState</a> &amp;state)</td></tr>
<tr class="separator:a5956970a704f868a930be61951ba9710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd4eb140e419a0e8d64b78fdbebdaaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1ParserState.html">ParserState</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a4dd4eb140e419a0e8d64b78fdbebdaaa">getState</a> () const</td></tr>
<tr class="separator:a4dd4eb140e419a0e8d64b78fdbebdaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96157aff6e827c2f6003aff6d5af90ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a96157aff6e827c2f6003aff6d5af90ed">getContext</a> () const</td></tr>
<tr class="separator:a96157aff6e827c2f6003aff6d5af90ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722f6aa4103090f70a04c73e239f9cb2"><td class="memItemLeft" align="right" valign="top">const llvm::SourceMgr &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a722f6aa4103090f70a04c73e239f9cb2">getSourceMgr</a> ()</td></tr>
<tr class="separator:a722f6aa4103090f70a04c73e239f9cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057926af5c61e02aa1467435c0bbd074"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a057926af5c61e02aa1467435c0bbd074">parseCommaSeparatedListUntil</a> (<a class="el" href="classmlir_1_1Token.html#aa7e0ab69e7e455be057896d495926095">Token::Kind</a> rightToken, const std::function&lt; <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>()&gt; &amp;parseElement, bool allowEmptyList=true)</td></tr>
<tr class="memdesc:a057926af5c61e02aa1467435c0bbd074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a comma-separated list of elements up until the specified end token.  <a href="#a057926af5c61e02aa1467435c0bbd074">More...</a><br /></td></tr>
<tr class="separator:a057926af5c61e02aa1467435c0bbd074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83066366f54e02f756345743f18c127a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a83066366f54e02f756345743f18c127a">parseCommaSeparatedList</a> (const std::function&lt; <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>()&gt; &amp;parseElement)</td></tr>
<tr class="memdesc:a83066366f54e02f756345743f18c127a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a comma separated list of elements that must have at least one entry in it.  <a href="#a83066366f54e02f756345743f18c127a">More...</a><br /></td></tr>
<tr class="separator:a83066366f54e02f756345743f18c127a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9f03156204f3f62722bb638811a906"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a4c9f03156204f3f62722bb638811a906">parsePrettyDialectSymbolName</a> (StringRef &amp;prettyName)</td></tr>
<tr class="memdesc:a4c9f03156204f3f62722bb638811a906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the body of a pretty dialect symbol, which starts and ends with &lt;&gt;'s, and may be recursive.  <a href="#a4c9f03156204f3f62722bb638811a906">More...</a><br /></td></tr>
<tr class="separator:a4c9f03156204f3f62722bb638811a906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b13251c2a69035e6573fde72c96e42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#ac3b13251c2a69035e6573fde72c96e42">emitError</a> (const Twine &amp;message={})</td></tr>
<tr class="memdesc:ac3b13251c2a69035e6573fde72c96e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit an error and return failure.  <a href="#ac3b13251c2a69035e6573fde72c96e42">More...</a><br /></td></tr>
<tr class="separator:ac3b13251c2a69035e6573fde72c96e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6777c85c6ee28bf3b1607eccc9822ea9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a6777c85c6ee28bf3b1607eccc9822ea9">emitError</a> (llvm::SMLoc loc, const Twine &amp;message={})</td></tr>
<tr class="separator:a6777c85c6ee28bf3b1607eccc9822ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81495c0f563d7a04175ae1aea2d1d463"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a81495c0f563d7a04175ae1aea2d1d463">getEncodedSourceLocation</a> (llvm::SMLoc loc)</td></tr>
<tr class="memdesc:a81495c0f563d7a04175ae1aea2d1d463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the specified source location information into an attribute for attachment to the IR.  <a href="#a81495c0f563d7a04175ae1aea2d1d463">More...</a><br /></td></tr>
<tr class="separator:a81495c0f563d7a04175ae1aea2d1d463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ea59f2fb250d4223778fcf4120d639"><td class="memItemLeft" align="right" valign="top">llvm::SMLoc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a36ea59f2fb250d4223778fcf4120d639">remapLocationToTopLevelBuffer</a> (llvm::SMLoc loc)</td></tr>
<tr class="memdesc:a36ea59f2fb250d4223778fcf4120d639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remaps the given SMLoc to the top level lexer of the parser.  <a href="#a36ea59f2fb250d4223778fcf4120d639">More...</a><br /></td></tr>
<tr class="separator:a36ea59f2fb250d4223778fcf4120d639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6efebbf44670db0ab8fe779d75f4d3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlir_1_1Token.html">Token</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#aea6efebbf44670db0ab8fe779d75f4d3">getToken</a> () const</td></tr>
<tr class="memdesc:aea6efebbf44670db0ab8fe779d75f4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current token the parser is inspecting.  <a href="#aea6efebbf44670db0ab8fe779d75f4d3">More...</a><br /></td></tr>
<tr class="separator:aea6efebbf44670db0ab8fe779d75f4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7230d60dea7e3db646eef23187fe801d"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a7230d60dea7e3db646eef23187fe801d">getTokenSpelling</a> () const</td></tr>
<tr class="separator:a7230d60dea7e3db646eef23187fe801d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1e99972ee5311fda958fed05606b67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#afd1e99972ee5311fda958fed05606b67">consumeIf</a> (<a class="el" href="classmlir_1_1Token.html#aa7e0ab69e7e455be057896d495926095">Token::Kind</a> kind)</td></tr>
<tr class="memdesc:afd1e99972ee5311fda958fed05606b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the current token has the specified kind, consume it and return true.  <a href="#afd1e99972ee5311fda958fed05606b67">More...</a><br /></td></tr>
<tr class="separator:afd1e99972ee5311fda958fed05606b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a2fb7dc766393b5d09a7787c502a7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a78a2fb7dc766393b5d09a7787c502a7f">consumeToken</a> ()</td></tr>
<tr class="memdesc:a78a2fb7dc766393b5d09a7787c502a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the current lexer onto the next token.  <a href="#a78a2fb7dc766393b5d09a7787c502a7f">More...</a><br /></td></tr>
<tr class="separator:a78a2fb7dc766393b5d09a7787c502a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b15304e22e99498592bfe311a44bddc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a4b15304e22e99498592bfe311a44bddc">consumeToken</a> (<a class="el" href="classmlir_1_1Token.html#aa7e0ab69e7e455be057896d495926095">Token::Kind</a> kind)</td></tr>
<tr class="memdesc:a4b15304e22e99498592bfe311a44bddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the current lexer onto the next token, asserting what the expected current token is.  <a href="#a4b15304e22e99498592bfe311a44bddc">More...</a><br /></td></tr>
<tr class="separator:a4b15304e22e99498592bfe311a44bddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248e39ef883f96502a179273c2acc82d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a248e39ef883f96502a179273c2acc82d">parseToken</a> (<a class="el" href="classmlir_1_1Token.html#aa7e0ab69e7e455be057896d495926095">Token::Kind</a> expectedToken, const Twine &amp;message)</td></tr>
<tr class="memdesc:a248e39ef883f96502a179273c2acc82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consume the specified token if present and return success.  <a href="#a248e39ef883f96502a179273c2acc82d">More...</a><br /></td></tr>
<tr class="separator:a248e39ef883f96502a179273c2acc82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a19fd41d1799954e884f1d1e09103a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a90a19fd41d1799954e884f1d1e09103a">parseFunctionResultTypes</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;elements)</td></tr>
<tr class="memdesc:a90a19fd41d1799954e884f1d1e09103a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a function result type.  <a href="#a90a19fd41d1799954e884f1d1e09103a">More...</a><br /></td></tr>
<tr class="separator:a90a19fd41d1799954e884f1d1e09103a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08124cef82f51196eca2f88ea6cf967"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#ae08124cef82f51196eca2f88ea6cf967">parseTypeListNoParens</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;elements)</td></tr>
<tr class="memdesc:ae08124cef82f51196eca2f88ea6cf967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a list of types without an enclosing parenthesis.  <a href="#ae08124cef82f51196eca2f88ea6cf967">More...</a><br /></td></tr>
<tr class="separator:ae08124cef82f51196eca2f88ea6cf967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c12fb5b201435c6ac2b43174df2d153"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a4c12fb5b201435c6ac2b43174df2d153">parseTypeListParens</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;elements)</td></tr>
<tr class="memdesc:a4c12fb5b201435c6ac2b43174df2d153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a parenthesized list of types.  <a href="#a4c12fb5b201435c6ac2b43174df2d153">More...</a><br /></td></tr>
<tr class="separator:a4c12fb5b201435c6ac2b43174df2d153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2227c605d7956d7f33c21d071d56cc0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a2227c605d7956d7f33c21d071d56cc0a">parseOptionalType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> &amp;type)</td></tr>
<tr class="memdesc:a2227c605d7956d7f33c21d071d56cc0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optionally parse a type.  <a href="#a2227c605d7956d7f33c21d071d56cc0a">More...</a><br /></td></tr>
<tr class="separator:a2227c605d7956d7f33c21d071d56cc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a15e0b925f74a53f28af9b5c4a6700a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a3a15e0b925f74a53f28af9b5c4a6700a">parseType</a> ()</td></tr>
<tr class="memdesc:a3a15e0b925f74a53f28af9b5c4a6700a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an arbitrary type.  <a href="#a3a15e0b925f74a53f28af9b5c4a6700a">More...</a><br /></td></tr>
<tr class="separator:a3a15e0b925f74a53f28af9b5c4a6700a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb0660397245d20b572d46eb7f71ffd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a8fb0660397245d20b572d46eb7f71ffd">parseComplexType</a> ()</td></tr>
<tr class="memdesc:a8fb0660397245d20b572d46eb7f71ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a complex type.  <a href="#a8fb0660397245d20b572d46eb7f71ffd">More...</a><br /></td></tr>
<tr class="separator:a8fb0660397245d20b572d46eb7f71ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c71c6000da70678841612f9164a21b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a62c71c6000da70678841612f9164a21b">parseExtendedType</a> ()</td></tr>
<tr class="memdesc:a62c71c6000da70678841612f9164a21b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an extended type.  <a href="#a62c71c6000da70678841612f9164a21b">More...</a><br /></td></tr>
<tr class="separator:a62c71c6000da70678841612f9164a21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85e5ad2a4968203049c89bb6ee87c9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#aa85e5ad2a4968203049c89bb6ee87c9c">parseFunctionType</a> ()</td></tr>
<tr class="memdesc:aa85e5ad2a4968203049c89bb6ee87c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a function type.  <a href="#aa85e5ad2a4968203049c89bb6ee87c9c">More...</a><br /></td></tr>
<tr class="separator:aa85e5ad2a4968203049c89bb6ee87c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092f374d9bb8ca0264dc0a499a5dbe2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a092f374d9bb8ca0264dc0a499a5dbe2b">parseMemRefType</a> ()</td></tr>
<tr class="memdesc:a092f374d9bb8ca0264dc0a499a5dbe2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a memref type.  <a href="#a092f374d9bb8ca0264dc0a499a5dbe2b">More...</a><br /></td></tr>
<tr class="separator:a092f374d9bb8ca0264dc0a499a5dbe2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567fdfd174f5a4e1cf5ddad304bc05d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a567fdfd174f5a4e1cf5ddad304bc05d6">parseNonFunctionType</a> ()</td></tr>
<tr class="memdesc:a567fdfd174f5a4e1cf5ddad304bc05d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a non function type.  <a href="#a567fdfd174f5a4e1cf5ddad304bc05d6">More...</a><br /></td></tr>
<tr class="separator:a567fdfd174f5a4e1cf5ddad304bc05d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb86c6d4cbbf1f86907bbf0cb1f69a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#afbb86c6d4cbbf1f86907bbf0cb1f69a4">parseTensorType</a> ()</td></tr>
<tr class="memdesc:afbb86c6d4cbbf1f86907bbf0cb1f69a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a tensor type.  <a href="#afbb86c6d4cbbf1f86907bbf0cb1f69a4">More...</a><br /></td></tr>
<tr class="separator:afbb86c6d4cbbf1f86907bbf0cb1f69a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cb429899024e4b9e77f77e85c2bf29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a63cb429899024e4b9e77f77e85c2bf29">parseTupleType</a> ()</td></tr>
<tr class="memdesc:a63cb429899024e4b9e77f77e85c2bf29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a tuple type.  <a href="#a63cb429899024e4b9e77f77e85c2bf29">More...</a><br /></td></tr>
<tr class="separator:a63cb429899024e4b9e77f77e85c2bf29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa099de69a347073f8ff8665ca9afc46e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1VectorType.html">VectorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#aa099de69a347073f8ff8665ca9afc46e">parseVectorType</a> ()</td></tr>
<tr class="memdesc:aa099de69a347073f8ff8665ca9afc46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a vector type.  <a href="#aa099de69a347073f8ff8665ca9afc46e">More...</a><br /></td></tr>
<tr class="separator:aa099de69a347073f8ff8665ca9afc46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6dfabceedb80b085943824e19eb9bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a8d6dfabceedb80b085943824e19eb9bf">parseDimensionListRanked</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;dimensions, bool allowDynamic=true)</td></tr>
<tr class="memdesc:a8d6dfabceedb80b085943824e19eb9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a dimension list of a tensor or memref type.  <a href="#a8d6dfabceedb80b085943824e19eb9bf">More...</a><br /></td></tr>
<tr class="separator:a8d6dfabceedb80b085943824e19eb9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f02a4067ccb0b7c56b59d04838e923c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a1f02a4067ccb0b7c56b59d04838e923c">parseXInDimensionList</a> ()</td></tr>
<tr class="memdesc:a1f02a4067ccb0b7c56b59d04838e923c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an 'x' token in a dimension list, handling the case where the x is juxtaposed with an element type, as in "xf32", leaving the "f32" as the next token.  <a href="#a1f02a4067ccb0b7c56b59d04838e923c">More...</a><br /></td></tr>
<tr class="separator:a1f02a4067ccb0b7c56b59d04838e923c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90e481023ad158179256bc3aab0cf19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#ab90e481023ad158179256bc3aab0cf19">parseStridedLayout</a> (int64_t &amp;offset, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;strides)</td></tr>
<tr class="memdesc:ab90e481023ad158179256bc3aab0cf19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse strided layout specification.  <a href="#ab90e481023ad158179256bc3aab0cf19">More...</a><br /></td></tr>
<tr class="separator:ab90e481023ad158179256bc3aab0cf19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3903a4aa0d7b1a9d10fd084e514b740"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#ae3903a4aa0d7b1a9d10fd084e514b740">parseStrideList</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;dimensions)</td></tr>
<tr class="separator:ae3903a4aa0d7b1a9d10fd084e514b740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71240c1fd3c0e2621f3a64fb2385006f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a71240c1fd3c0e2621f3a64fb2385006f">parseAttribute</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type={})</td></tr>
<tr class="memdesc:a71240c1fd3c0e2621f3a64fb2385006f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an arbitrary attribute with an optional type.  <a href="#a71240c1fd3c0e2621f3a64fb2385006f">More...</a><br /></td></tr>
<tr class="separator:a71240c1fd3c0e2621f3a64fb2385006f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17ed8b9823cc3afeede212d776c9348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#ab17ed8b9823cc3afeede212d776c9348">parseOptionalAttribute</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;attribute, <a class="el" href="classmlir_1_1Type.html">Type</a> type={})</td></tr>
<tr class="memdesc:ab17ed8b9823cc3afeede212d776c9348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an optional attribute with the provided type.  <a href="#ab17ed8b9823cc3afeede212d776c9348">More...</a><br /></td></tr>
<tr class="separator:ab17ed8b9823cc3afeede212d776c9348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82348546f3b932833e4a511eeb7d751c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a82348546f3b932833e4a511eeb7d751c">parseAttributeDict</a> (<a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a> &amp;attributes)</td></tr>
<tr class="memdesc:a82348546f3b932833e4a511eeb7d751c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an attribute dictionary.  <a href="#a82348546f3b932833e4a511eeb7d751c">More...</a><br /></td></tr>
<tr class="separator:a82348546f3b932833e4a511eeb7d751c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6de673c0209f87f97ffda3eb5fae60e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#ae6de673c0209f87f97ffda3eb5fae60e">parseExtendedAttr</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="memdesc:ae6de673c0209f87f97ffda3eb5fae60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an extended attribute.  <a href="#ae6de673c0209f87f97ffda3eb5fae60e">More...</a><br /></td></tr>
<tr class="separator:ae6de673c0209f87f97ffda3eb5fae60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81212ccd3dfeb0d6b6c70034b8fc7b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#ac81212ccd3dfeb0d6b6c70034b8fc7b8">parseFloatAttr</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, bool isNegative)</td></tr>
<tr class="memdesc:ac81212ccd3dfeb0d6b6c70034b8fc7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a float attribute.  <a href="#ac81212ccd3dfeb0d6b6c70034b8fc7b8">More...</a><br /></td></tr>
<tr class="separator:ac81212ccd3dfeb0d6b6c70034b8fc7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a57c411441135b385823f035ab6ac9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a19a57c411441135b385823f035ab6ac9">parseDecOrHexAttr</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, bool isNegative)</td></tr>
<tr class="memdesc:a19a57c411441135b385823f035ab6ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a decimal or a hexadecimal literal, which can be either an integer or a float attribute.  <a href="#a19a57c411441135b385823f035ab6ac9">More...</a><br /></td></tr>
<tr class="separator:a19a57c411441135b385823f035ab6ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9602168a86e4795712bd18506661747a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a9602168a86e4795712bd18506661747a">parseOpaqueElementsAttr</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> attrType)</td></tr>
<tr class="memdesc:a9602168a86e4795712bd18506661747a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an opaque elements attribute.  <a href="#a9602168a86e4795712bd18506661747a">More...</a><br /></td></tr>
<tr class="separator:a9602168a86e4795712bd18506661747a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fae4d8f4a2eb7348ffef0f161c2c023"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a3fae4d8f4a2eb7348ffef0f161c2c023">parseDenseElementsAttr</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> attrType)</td></tr>
<tr class="memdesc:a3fae4d8f4a2eb7348ffef0f161c2c023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a dense elements attribute.  <a href="#a3fae4d8f4a2eb7348ffef0f161c2c023">More...</a><br /></td></tr>
<tr class="separator:a3fae4d8f4a2eb7348ffef0f161c2c023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b1ec0e356dd6647852fe58a9663f07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a88b1ec0e356dd6647852fe58a9663f07">parseElementsLiteralType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="memdesc:a88b1ec0e356dd6647852fe58a9663f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shaped type for elements attribute.  <a href="#a88b1ec0e356dd6647852fe58a9663f07">More...</a><br /></td></tr>
<tr class="separator:a88b1ec0e356dd6647852fe58a9663f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99a023e952f3b5a959cdb38f9fa9255"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#aa99a023e952f3b5a959cdb38f9fa9255">parseSparseElementsAttr</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> attrType)</td></tr>
<tr class="memdesc:aa99a023e952f3b5a959cdb38f9fa9255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a sparse elements attribute.  <a href="#aa99a023e952f3b5a959cdb38f9fa9255">More...</a><br /></td></tr>
<tr class="separator:aa99a023e952f3b5a959cdb38f9fa9255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74bb0c95ab2c9ae6bd4060938a81fce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#ac74bb0c95ab2c9ae6bd4060938a81fce">parseLocation</a> (<a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> &amp;loc)</td></tr>
<tr class="memdesc:ac74bb0c95ab2c9ae6bd4060938a81fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an inline location.  <a href="#ac74bb0c95ab2c9ae6bd4060938a81fce">More...</a><br /></td></tr>
<tr class="separator:ac74bb0c95ab2c9ae6bd4060938a81fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f25754ab72a1e217786c5af31abd58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a75f25754ab72a1e217786c5af31abd58">parseLocationInstance</a> (<a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> &amp;loc)</td></tr>
<tr class="memdesc:a75f25754ab72a1e217786c5af31abd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a raw location instance.  <a href="#a75f25754ab72a1e217786c5af31abd58">More...</a><br /></td></tr>
<tr class="separator:a75f25754ab72a1e217786c5af31abd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac978be0e105fb32d6736ffc4ecdd2325"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#ac978be0e105fb32d6736ffc4ecdd2325">parseCallSiteLocation</a> (<a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> &amp;loc)</td></tr>
<tr class="memdesc:ac978be0e105fb32d6736ffc4ecdd2325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a callsite location instance.  <a href="#ac978be0e105fb32d6736ffc4ecdd2325">More...</a><br /></td></tr>
<tr class="separator:ac978be0e105fb32d6736ffc4ecdd2325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8250388ee98fecf5ab85ed55675f14d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#aa8250388ee98fecf5ab85ed55675f14d">parseFusedLocation</a> (<a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> &amp;loc)</td></tr>
<tr class="memdesc:aa8250388ee98fecf5ab85ed55675f14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a fused location instance.  <a href="#aa8250388ee98fecf5ab85ed55675f14d">More...</a><br /></td></tr>
<tr class="separator:aa8250388ee98fecf5ab85ed55675f14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73ca5eabcb2e4e30deff990f8c3959d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#ad73ca5eabcb2e4e30deff990f8c3959d">parseNameOrFileLineColLocation</a> (<a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> &amp;loc)</td></tr>
<tr class="memdesc:ad73ca5eabcb2e4e30deff990f8c3959d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a name or FileLineCol location instance.  <a href="#ad73ca5eabcb2e4e30deff990f8c3959d">More...</a><br /></td></tr>
<tr class="separator:ad73ca5eabcb2e4e30deff990f8c3959d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b9d3cb872a229f0dfdcca0622bd2ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a62b9d3cb872a229f0dfdcca0622bd2ce">parseOptionalTrailingLocation</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> &amp;loc)</td></tr>
<tr class="memdesc:a62b9d3cb872a229f0dfdcca0622bd2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an optional trailing location.  <a href="#a62b9d3cb872a229f0dfdcca0622bd2ce">More...</a><br /></td></tr>
<tr class="separator:a62b9d3cb872a229f0dfdcca0622bd2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2ebfe1c7878d799b1876161c84e675"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#aaf2ebfe1c7878d799b1876161c84e675">parseAffineMapOrIntegerSetReference</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;map, <a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> &amp;set)</td></tr>
<tr class="memdesc:aaf2ebfe1c7878d799b1876161c84e675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a reference to either an affine map, or an integer set.  <a href="#aaf2ebfe1c7878d799b1876161c84e675">More...</a><br /></td></tr>
<tr class="separator:aaf2ebfe1c7878d799b1876161c84e675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db1e9bbc78a9aaea96ef0a9232f3fbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a5db1e9bbc78a9aaea96ef0a9232f3fbe">parseAffineMapReference</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;map)</td></tr>
<tr class="separator:a5db1e9bbc78a9aaea96ef0a9232f3fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff9f259111c9192a4add33efc3ee467"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#acff9f259111c9192a4add33efc3ee467">parseIntegerSetReference</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> &amp;set)</td></tr>
<tr class="separator:acff9f259111c9192a4add33efc3ee467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a303e7150996a39de47cf5283499eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a49a303e7150996a39de47cf5283499eb">parseAffineMapOfSSAIds</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;map, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>(bool)&gt; parseElement, <a class="el" href="classmlir_1_1OpAsmParser.html#acabba33fbd8180d7ad2c752821696f92">OpAsmParser::Delimiter</a> delimiter)</td></tr>
<tr class="memdesc:a49a303e7150996a39de47cf5283499eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> where the dim and symbol identifiers are SSA ids.  <a href="#a49a303e7150996a39de47cf5283499eb">More...</a><br /></td></tr>
<tr class="separator:a49a303e7150996a39de47cf5283499eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a32a5dd9790fcfbe5f7776977cf86d3e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Builder.html">Builder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1detail_1_1Parser.html#a32a5dd9790fcfbe5f7776977cf86d3e8">builder</a></td></tr>
<tr class="separator:a32a5dd9790fcfbe5f7776977cf86d3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implement support for parsing global entities like attributes and types. </p>
<p>It is intended to be subclassed by specialized subparsers that include state. </p>

<p class="definition">Definition at line <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00025">25</a> of file <a class="el" href="lib_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5956970a704f868a930be61951ba9710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5956970a704f868a930be61951ba9710">&#9670;&nbsp;</a></span>Parser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::detail::Parser::Parser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1detail_1_1ParserState.html">ParserState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00029">29</a> of file <a class="el" href="lib_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afd1e99972ee5311fda958fed05606b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd1e99972ee5311fda958fed05606b67">&#9670;&nbsp;</a></span>consumeIf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::detail::Parser::consumeIf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Token.html#aa7e0ab69e7e455be057896d495926095">Token::Kind</a>&#160;</td>
          <td class="paramname"><em>kind</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the current token has the specified kind, consume it and return true. </p>
<p>If not, return false. </p>

<p class="definition">Definition at line <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00105">105</a> of file <a class="el" href="lib_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="ParserState_8h_source.html#l00073">mlir::detail::ParserState::curToken</a>, and <a class="el" href="Token_8h_source.html#l00049">mlir::Token::isNot()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00230">parseAttributeDict()</a>, <a class="el" href="Parser_8cpp_source.html#l00037">parseCommaSeparatedList()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00344">parseDecOrHexAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00790">parseDenseElementsAttr()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00485">parseDimensionListRanked()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00270">parseFloatAttr()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00079">parseFusedLocation()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00192">parseMemRefType()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00113">parseNameOrFileLineColLocation()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00873">parseSparseElementsAttr()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00149">parseStridedLayout()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00542">parseStrideList()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00380">parseTensorType()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00419">parseTupleType()</a>.</p>

</div>
</div>
<a id="a78a2fb7dc766393b5d09a7787c502a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a2fb7dc766393b5d09a7787c502a7f">&#9670;&nbsp;</a></span>consumeToken() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::Parser::consumeToken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance the current lexer onto the next token. </p>

<p class="definition">Definition at line <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">113</a> of file <a class="el" href="lib_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="ParserState_8h_source.html#l00073">mlir::detail::ParserState::curToken</a>, <a class="el" href="Token_8h_source.html#l00049">mlir::Token::isNot()</a>, <a class="el" href="ParserState_8h_source.html#l00070">mlir::detail::ParserState::lex</a>, and <a class="el" href="Lexer_8cpp_source.html#l00058">mlir::Lexer::lexToken()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00105">consumeIf()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00230">parseAttributeDict()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00047">parseCallSiteLocation()</a>, <a class="el" href="Parser_8cpp_source.html#l00057">parseCommaSeparatedListUntil()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00110">parseComplexType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00344">parseDecOrHexAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00790">parseDenseElementsAttr()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00485">parseDimensionListRanked()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00404">parseExtendedSymbol()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00270">parseFloatAttr()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00079">parseFusedLocation()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00172">parseLocationInstance()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00192">parseMemRefType()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00113">parseNameOrFileLineColLocation()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00311">parseNonFunctionType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00811">parseOpaqueElementsAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00873">parseSparseElementsAttr()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00149">parseStridedLayout()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00542">parseStrideList()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00380">parseTensorType()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00419">parseTupleType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00092">parseTypeListParens()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00446">parseVectorType()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00526">parseXInDimensionList()</a>.</p>

</div>
</div>
<a id="a4b15304e22e99498592bfe311a44bddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b15304e22e99498592bfe311a44bddc">&#9670;&nbsp;</a></span>consumeToken() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::detail::Parser::consumeToken </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Token.html#aa7e0ab69e7e455be057896d495926095">Token::Kind</a>&#160;</td>
          <td class="paramname"><em>kind</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance the current lexer onto the next token, asserting what the expected current token is. </p>
<p>This is preferred to the above method because it leads to more self-documenting code with better checking. </p>

<p class="definition">Definition at line <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">122</a> of file <a class="el" href="lib_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="ParserState_8h_source.html#l00073">mlir::detail::ParserState::curToken</a>, <a class="el" href="Token_8h_source.html#l00037">mlir::Token::is()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00230">parseAttributeDict()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00047">parseCallSiteLocation()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00110">parseComplexType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00344">parseDecOrHexAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00790">parseDenseElementsAttr()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00485">parseDimensionListRanked()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00851">parseElementsLiteralType()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00518">parseExtendedAttr()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00560">parseExtendedType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00270">parseFloatAttr()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00061">parseFunctionResultTypes()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00133">parseFunctionType()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00079">parseFusedLocation()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00019">parseLocation()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00172">parseLocationInstance()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00192">parseMemRefType()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00113">parseNameOrFileLineColLocation()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00311">parseNonFunctionType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00811">parseOpaqueElementsAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00191">parseOptionalAttribute()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00021">parseOptionalType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00873">parseSparseElementsAttr()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00149">parseStridedLayout()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00542">parseStrideList()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00380">parseTensorType()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00419">parseTupleType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00050">parseType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00077">parseTypeListNoParens()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00092">parseTypeListParens()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00446">parseVectorType()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00526">parseXInDimensionList()</a>.</p>

</div>
</div>
<a id="ac3b13251c2a69035e6573fde72c96e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b13251c2a69035e6573fde72c96e42">&#9670;&nbsp;</a></span>emitError() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::detail::Parser::emitError </td>
          <td>(</td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit an error and return failure. </p>

<p class="definition">Definition at line <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">59</a> of file <a class="el" href="lib_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="ParserState_8h_source.html#l00073">mlir::detail::ParserState::curToken</a>, and <a class="el" href="Token_8cpp_source.html#l00019">mlir::Token::getLoc()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeParser_8cpp_source.html#l00289">buildHexadecimalFloatLiteral()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00230">parseAttributeDict()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00047">parseCallSiteLocation()</a>, <a class="el" href="Parser_8cpp_source.html#l00057">parseCommaSeparatedListUntil()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00110">parseComplexType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00344">parseDecOrHexAttr()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00485">parseDimensionListRanked()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00405">parseElementAttrHexValues()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00851">parseElementsLiteralType()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00404">parseExtendedSymbol()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00270">parseFloatAttr()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00079">parseFusedLocation()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00019">parseLocation()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00172">parseLocationInstance()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00192">parseMemRefType()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00113">parseNameOrFileLineColLocation()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00311">parseNonFunctionType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00811">parseOpaqueElementsAttr()</a>, <a class="el" href="Parser_8cpp_source.html#l01860">mlir::parseSourceFile()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00873">parseSparseElementsAttr()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00149">parseStridedLayout()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00542">parseStrideList()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00481">parseSymbol()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00380">parseTensorType()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00446">parseVectorType()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00526">parseXInDimensionList()</a>.</p>

</div>
</div>
<a id="a6777c85c6ee28bf3b1607eccc9822ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6777c85c6ee28bf3b1607eccc9822ea9">&#9670;&nbsp;</a></span>emitError() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::detail::Parser::emitError </td>
          <td>(</td>
          <td class="paramtype">llvm::SMLoc&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96157aff6e827c2f6003aff6d5af90ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96157aff6e827c2f6003aff6d5af90ed">&#9670;&nbsp;</a></span>getContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a>* mlir::detail::Parser::getContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00033">33</a> of file <a class="el" href="lib_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="ParserState_8h_source.html#l00067">mlir::detail::ParserState::context</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00079">parseFusedLocation()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00172">parseLocationInstance()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00113">parseNameOrFileLineColLocation()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00419">parseTupleType()</a>.</p>

</div>
</div>
<a id="a81495c0f563d7a04175ae1aea2d1d463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81495c0f563d7a04175ae1aea2d1d463">&#9670;&nbsp;</a></span>getEncodedSourceLocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Location.html">Location</a> mlir::detail::Parser::getEncodedSourceLocation </td>
          <td>(</td>
          <td class="paramtype">llvm::SMLoc&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode the specified source location information into an attribute for attachment to the IR. </p>

<p class="definition">Definition at line <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00066">66</a> of file <a class="el" href="lib_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="Lexer_8cpp_source.html#l00041">mlir::Lexer::getEncodedSourceLocation()</a>, <a class="el" href="ParserState_8h_source.html#l00070">mlir::detail::ParserState::lex</a>, <a class="el" href="ParserState_8h_source.html#l00079">mlir::detail::ParserState::parserDepth</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00079">remapLocationToTopLevelBuffer()</a>, <a class="el" href="ParserState_8h_source.html#l00076">mlir::detail::ParserState::symbols</a>, and <a class="el" href="ParserState_8h_source.html#l00040">mlir::detail::SymbolState::topLevelLexer</a>.</p>

<p class="reference">Referenced by <a class="el" href="Parser_8cpp_source.html#l00057">parseCommaSeparatedListUntil()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00311">parseNonFunctionType()</a>, and <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>.</p>

</div>
</div>
<a id="a722f6aa4103090f70a04c73e239f9cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722f6aa4103090f70a04c73e239f9cb2">&#9670;&nbsp;</a></span>getSourceMgr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const llvm::SourceMgr&amp; mlir::detail::Parser::getSourceMgr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00034">34</a> of file <a class="el" href="lib_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="Lexer_8h_source.html#l00027">mlir::Lexer::getSourceMgr()</a>, <a class="el" href="ParserState_8h_source.html#l00070">mlir::detail::ParserState::lex</a>, <a class="el" href="Parser_8cpp_source.html#l00037">parseCommaSeparatedList()</a>, <a class="el" href="Parser_8cpp_source.html#l00057">parseCommaSeparatedListUntil()</a>, and <a class="el" href="DialectSymbolParser_8cpp_source.html#l00338">parsePrettyDialectSymbolName()</a>.</p>

</div>
</div>
<a id="a4dd4eb140e419a0e8d64b78fdbebdaaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd4eb140e419a0e8d64b78fdbebdaaa">&#9670;&nbsp;</a></span>getState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1ParserState.html">ParserState</a>&amp; mlir::detail::Parser::getState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00032">32</a> of file <a class="el" href="lib_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectSymbolParser_8cpp_source.html#l00404">parseExtendedSymbol()</a>, and <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>.</p>

</div>
</div>
<a id="aea6efebbf44670db0ab8fe779d75f4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6efebbf44670db0ab8fe779d75f4d3">&#9670;&nbsp;</a></span>getToken()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlir_1_1Token.html">Token</a>&amp; mlir::detail::Parser::getToken </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current token the parser is inspecting. </p>

<p class="definition">Definition at line <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">100</a> of file <a class="el" href="lib_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="ParserState_8h_source.html#l00073">mlir::detail::ParserState::curToken</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00230">parseAttributeDict()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00047">parseCallSiteLocation()</a>, <a class="el" href="Parser_8cpp_source.html#l00057">parseCommaSeparatedListUntil()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00110">parseComplexType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00344">parseDecOrHexAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00790">parseDenseElementsAttr()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00485">parseDimensionListRanked()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00404">parseExtendedSymbol()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00270">parseFloatAttr()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00061">parseFunctionResultTypes()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00133">parseFunctionType()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00172">parseLocationInstance()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00192">parseMemRefType()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00113">parseNameOrFileLineColLocation()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00311">parseNonFunctionType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00811">parseOpaqueElementsAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00191">parseOptionalAttribute()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00237">parseOptionalTrailingLocation()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00021">parseOptionalType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00873">parseSparseElementsAttr()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00149">parseStridedLayout()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00542">parseStrideList()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00481">parseSymbol()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00380">parseTensorType()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00050">parseType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00092">parseTypeListParens()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00446">parseVectorType()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00526">parseXInDimensionList()</a>.</p>

</div>
</div>
<a id="a7230d60dea7e3db646eef23187fe801d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7230d60dea7e3db646eef23187fe801d">&#9670;&nbsp;</a></span>getTokenSpelling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringRef mlir::detail::Parser::getTokenSpelling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00101">101</a> of file <a class="el" href="lib_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="ParserState_8h_source.html#l00073">mlir::detail::ParserState::curToken</a>, and <a class="el" href="Token_8h_source.html#l00033">mlir::Token::getSpelling()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeParser_8cpp_source.html#l00230">parseAttributeDict()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00485">parseDimensionListRanked()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00404">parseExtendedSymbol()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00526">parseXInDimensionList()</a>.</p>

</div>
</div>
<a id="a49a303e7150996a39de47cf5283499eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a303e7150996a39de47cf5283499eb">&#9670;&nbsp;</a></span>parseAffineMapOfSSAIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> Parser::parseAffineMapOfSSAIds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>(bool)&gt;&#160;</td>
          <td class="paramname"><em>parseElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html#acabba33fbd8180d7ad2c752821696f92">OpAsmParser::Delimiter</a>&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> where the dim and symbol identifiers are SSA ids. </p>
<p>Parse an <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> of SSA ids.</p>
<p>The callback 'parseElement' is used to parse SSA value uses encountered while parsing affine expressions. </p>

<p class="definition">Definition at line <a class="el" href="AffineParser_8cpp_source.html#l00721">721</a> of file <a class="el" href="AffineParser_8cpp_source.html">AffineParser.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00237">parseOptionalTrailingLocation()</a>, and <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>.</p>

</div>
</div>
<a id="aaf2ebfe1c7878d799b1876161c84e675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2ebfe1c7878d799b1876161c84e675">&#9670;&nbsp;</a></span>parseAffineMapOrIntegerSetReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> Parser::parseAffineMapOrIntegerSetReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a reference to either an affine map, or an integer set. </p>
<p>Parse an ambiguous reference to either and affine map or an integer set. </p>

<p class="definition">Definition at line <a class="el" href="AffineParser_8cpp_source.html#l00695">695</a> of file <a class="el" href="AffineParser_8cpp_source.html">AffineParser.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00237">parseOptionalTrailingLocation()</a>.</p>

</div>
</div>
<a id="a5db1e9bbc78a9aaea96ef0a9232f3fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db1e9bbc78a9aaea96ef0a9232f3fbe">&#9670;&nbsp;</a></span>parseAffineMapReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> Parser::parseAffineMapReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineParser_8cpp_source.html#l00699">699</a> of file <a class="el" href="AffineParser_8cpp_source.html">AffineParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="Diagnostics_8cpp_source.html#l00301">mlir::emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>, and <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00237">parseOptionalTrailingLocation()</a>.</p>

</div>
</div>
<a id="a71240c1fd3c0e2621f3a64fb2385006f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71240c1fd3c0e2621f3a64fb2385006f">&#9670;&nbsp;</a></span>parseAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> Parser::parseAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an arbitrary attribute with an optional type. </p>
<p>Parse an arbitrary attribute.</p>
<p>attribute-value ::= <code>unit</code> | bool-literal | integer-literal (<code>:</code> (index-type | integer-type))? | float-literal (<code>:</code> float-type)? | string-literal (<code>:</code> type)? | type | <code>[</code> (attribute-value (<code>,</code> attribute-value)*)? <code>]</code> | <code>{</code> (attribute-entry (<code>,</code> attribute-entry)*)? <code>}</code> | symbol-ref-id (<code>::</code> symbol-ref-id)* | <code>dense</code> <code>&lt;</code> attribute-value <code>&gt;</code> <code>:</code> (tensor-type | vector-type) | <code>sparse</code> <code>&lt;</code> attribute-value <code>,</code> attribute-value <code>&gt;</code> <code>:</code> (tensor-type | vector-type) | <code>opaque</code> <code>&lt;</code> dialect-namespace <code>,</code> hex-string-literal <code>&gt;</code> <code>:</code> (tensor-type | vector-type) | extended-attribute </p>

<p class="definition">Definition at line <a class="el" href="AttributeParser_8cpp_source.html#l00041">41</a> of file <a class="el" href="AttributeParser_8cpp_source.html">AttributeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00027">builder</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00105">consumeIf()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="Attributes_8cpp_source.html#l00058">mlir::AffineMapAttr::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l00381">mlir::IntegerSetAttr::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l00426">mlir::StringAttr::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l00280">mlir::SymbolRefAttr::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l00441">mlir::TypeAttr::get()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00202">mlir::Builder::getArrayAttr()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00090">mlir::Builder::getBoolAttr()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00033">getContext()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00035">mlir::NamedAttrList::getDictionary()</a>, <a class="el" href="Token_8cpp_source.html#l00019">mlir::Token::getLoc()</a>, <a class="el" href="Token_8cpp_source.html#l00083">mlir::Token::getStringValue()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00206">mlir::Builder::getSymbolRefAttr()</a>, <a class="el" href="Token_8cpp_source.html#l00129">mlir::Token::getSymbolReference()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00088">mlir::Builder::getUnitAttr()</a>, <a class="el" href="ParserState_8h_source.html#l00070">mlir::detail::ParserState::lex</a>, <a class="el" href="AffineParser_8cpp_source.html#l00699">parseAffineMapReference()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00230">parseAttributeDict()</a>, <a class="el" href="Parser_8cpp_source.html#l00057">parseCommaSeparatedListUntil()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00344">parseDecOrHexAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00790">parseDenseElementsAttr()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00518">parseExtendedAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00270">parseFloatAttr()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00708">parseIntegerSetReference()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00019">parseLocation()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00811">parseOpaqueElementsAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00873">parseSparseElementsAttr()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00050">parseType()</a>, <a class="el" href="Lexer_8h_source.html#l00037">mlir::Lexer::resetPointer()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00230">parseAttributeDict()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00079">parseFusedLocation()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00192">parseMemRefType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00191">parseOptionalAttribute()</a>, and <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>.</p>

</div>
</div>
<a id="a82348546f3b932833e4a511eeb7d751c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82348546f3b932833e4a511eeb7d751c">&#9670;&nbsp;</a></span>parseAttributeDict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> Parser::parseAttributeDict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1NamedAttrList.html">NamedAttrList</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an attribute dictionary. </p>
<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations and functions. ">Attribute</a> dictionary.</p>
<p>attribute-dict ::= <code>{</code> <code>}</code> | <code>{</code> attribute-entry (<code>,</code> attribute-entry)* <code>}</code> attribute-entry ::= (bare-id | string-literal) <code>=</code> attribute-value </p>

<p class="definition">Definition at line <a class="el" href="AttributeParser_8cpp_source.html#l00230">230</a> of file <a class="el" href="AttributeParser_8cpp_source.html">AttributeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00027">builder</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00105">consumeIf()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00022">mlir::Builder::getIdentifier()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00101">getTokenSpelling()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00088">mlir::Builder::getUnitAttr()</a>, <a class="el" href="Token_8h_source.html#l00037">mlir::Token::is()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>, <a class="el" href="Parser_8cpp_source.html#l00057">parseCommaSeparatedListUntil()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00080">mlir::NamedAttrList::push_back()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>, and <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>.</p>

</div>
</div>
<a id="ac978be0e105fb32d6736ffc4ecdd2325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac978be0e105fb32d6736ffc4ecdd2325">&#9670;&nbsp;</a></span>parseCallSiteLocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> Parser::parseCallSiteLocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a callsite location instance. </p>
<p>Specific location instances.</p>
<p>location-inst ::= filelinecol-location | name-location | callsite-location | fused-location | unknown-location filelinecol-location ::= string-literal ':' integer-literal ':' integer-literal name-location ::= string-literal callsite-location ::= 'callsite' '(' location-inst 'at' location-inst ')' fused-location ::= fused ('&lt;' attribute-value '&gt;')? '[' location-inst (location-inst ',')* ']' unknown-location ::= 'unknown' </p>

<p class="definition">Definition at line <a class="el" href="LocationParser_8cpp_source.html#l00047">47</a> of file <a class="el" href="LocationParser_8cpp_source.html">LocationParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="Location_8cpp_source.html#l00030">mlir::CallSiteLoc::get()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00172">parseLocationInstance()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, and <a class="el" href="LocationParser_8cpp_source.html#l00172">parseLocationInstance()</a>.</p>

</div>
</div>
<a id="a83066366f54e02f756345743f18c127a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83066366f54e02f756345743f18c127a">&#9670;&nbsp;</a></span>parseCommaSeparatedList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> Parser::parseCommaSeparatedList </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>()&gt; &amp;&#160;</td>
          <td class="paramname"><em>parseElement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a comma separated list of elements that must have at least one entry in it. </p>

<p class="definition">Definition at line <a class="el" href="Parser_8cpp_source.html#l00037">37</a> of file <a class="el" href="Parser_8cpp_source.html">Parser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00105">consumeIf()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00034">getSourceMgr()</a>, <a class="el" href="Parser_8cpp_source.html#l00057">parseCommaSeparatedListUntil()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00405">parseElementAttrHexValues()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00079">parseFusedLocation()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00077">parseTypeListNoParens()</a>.</p>

</div>
</div>
<a id="a057926af5c61e02aa1467435c0bbd074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057926af5c61e02aa1467435c0bbd074">&#9670;&nbsp;</a></span>parseCommaSeparatedListUntil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> Parser::parseCommaSeparatedListUntil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Token.html#aa7e0ab69e7e455be057896d495926095">Token::Kind</a>&#160;</td>
          <td class="paramname"><em>rightToken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>()&gt; &amp;&#160;</td>
          <td class="paramname"><em>parseElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowEmptyList</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a comma-separated list of elements up until the specified end token. </p>
<p>Parse a comma-separated list of elements, terminated with an arbitrary token.</p>
<p>This allows empty lists if allowEmptyList is true.</p>
<p>abstract-list ::= rightToken // if allowEmptyList == true abstract-list ::= element (',' element)* rightToken </p>

<p class="definition">Definition at line <a class="el" href="Parser_8cpp_source.html#l00057">57</a> of file <a class="el" href="Parser_8cpp_source.html">Parser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00039">diag()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">emitError()</a>, <a class="el" href="Diagnostics_8cpp_source.html#l00301">mlir::emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00066">getEncodedSourceLocation()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="Token_8cpp_source.html#l00153">mlir::Token::getTokenSpelling()</a>, <a class="el" href="Parser_8cpp_source.html#l00037">parseCommaSeparatedList()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00034">getSourceMgr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00230">parseAttributeDict()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00192">parseMemRefType()</a>, and <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>.</p>

</div>
</div>
<a id="a8fb0660397245d20b572d46eb7f71ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb0660397245d20b572d46eb7f71ffd">&#9670;&nbsp;</a></span>parseComplexType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> Parser::parseComplexType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a complex type. </p>
<p>complex-type ::= <code>complex</code> <code>&lt;</code> type <code>&gt;</code> </p>

<p class="definition">Definition at line <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00110">110</a> of file <a class="el" href="Parser_2TypeParser_8cpp_source.html">TypeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">emitError()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00097">mlir::ComplexType::get()</a>, <a class="el" href="Token_8cpp_source.html#l00019">mlir::Token::getLoc()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00050">parseType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00311">parseNonFunctionType()</a>.</p>

</div>
</div>
<a id="a19a57c411441135b385823f035ab6ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a57c411441135b385823f035ab6ac9">&#9670;&nbsp;</a></span>parseDecOrHexAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> Parser::parseDecOrHexAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isNegative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a decimal or a hexadecimal literal, which can be either an integer or a float attribute. </p>

<p class="definition">Definition at line <a class="el" href="AttributeParser_8cpp_source.html#l00344">344</a> of file <a class="el" href="AttributeParser_8cpp_source.html">AttributeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="Diagnostics_8h_source.html#l00343">mlir::InFlightDiagnostic::attachNote()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00304">buildAttributeAPInt()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00027">builder</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00289">buildHexadecimalFloatLiteral()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00105">consumeIf()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="ParserState_8h_source.html#l00073">mlir::detail::ParserState::curToken</a>, <a class="el" href="Types_8h_source.html#l00322">mlir::Type::dyn_cast()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">emitError()</a>, <a class="el" href="Attributes_8cpp_source.html#l00220">mlir::FloatAttr::get()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00167">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00061">mlir::Builder::getIntegerType()</a>, <a class="el" href="Token_8cpp_source.html#l00019">mlir::Token::getLoc()</a>, <a class="el" href="Token_8h_source.html#l00033">mlir::Token::getSpelling()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="Token_8h_source.html#l00069">mlir::Token::getUInt64IntegerValue()</a>, <a class="el" href="Types_8h_source.html#l00312">mlir::Type::isa()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00063">mlir::Type::isUnsignedInteger()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00050">parseType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, and <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>.</p>

</div>
</div>
<a id="a3fae4d8f4a2eb7348ffef0f161c2c023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fae4d8f4a2eb7348ffef0f161c2c023">&#9670;&nbsp;</a></span>parseDenseElementsAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> Parser::parseDenseElementsAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>attrType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a dense elements attribute. </p>

<p class="definition">Definition at line <a class="el" href="AttributeParser_8cpp_source.html#l00790">790</a> of file <a class="el" href="AttributeParser_8cpp_source.html">AttributeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00105">consumeIf()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="Token_8cpp_source.html#l00019">mlir::Token::getLoc()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00851">parseElementsLiteralType()</a>, and <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, and <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>.</p>

</div>
</div>
<a id="a8d6dfabceedb80b085943824e19eb9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6dfabceedb80b085943824e19eb9bf">&#9670;&nbsp;</a></span>parseDimensionListRanked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> Parser::parseDimensionListRanked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDynamic</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a dimension list of a tensor or memref type. </p>
<p>This populates the dimension list, using -1 for the <code>?</code> dimensions if <code>allowDynamic</code> is set and errors out on <code>?</code> otherwise.</p>
<p>dimension-list-ranked ::= (dimension <code>x</code>)* dimension ::= <code>?</code> | decimal-literal</p>
<p>When <code>allowDynamic</code> is not set, this is used to parse:</p>
<p>static-dimension-list ::= (decimal-literal <code>x</code>)* </p>

<p class="definition">Definition at line <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00485">485</a> of file <a class="el" href="Parser_2TypeParser_8cpp_source.html">TypeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00105">consumeIf()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00101">getTokenSpelling()</a>, <a class="el" href="Token_8cpp_source.html#l00029">mlir::Token::getUnsignedIntegerValue()</a>, <a class="el" href="ParserState_8h_source.html#l00070">mlir::detail::ParserState::lex</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00526">parseXInDimensionList()</a>, <a class="el" href="Lexer_8h_source.html#l00037">mlir::Lexer::resetPointer()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00192">parseMemRefType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00380">parseTensorType()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00446">parseVectorType()</a>.</p>

</div>
</div>
<a id="a88b1ec0e356dd6647852fe58a9663f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b1ec0e356dd6647852fe58a9663f07">&#9670;&nbsp;</a></span>parseElementsLiteralType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a> Parser::parseElementsLiteralType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shaped type for elements attribute. </p>
<p>elements-literal-type ::= vector-type | ranked-tensor-type</p>
<p>This method also checks the type has static shape. </p>

<p class="definition">Definition at line <a class="el" href="AttributeParser_8cpp_source.html#l00851">851</a> of file <a class="el" href="AttributeParser_8cpp_source.html">AttributeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00328">mlir::Type::cast()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">emitError()</a>, <a class="el" href="Types_8h_source.html#l00312">mlir::Type::isa()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00050">parseType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00790">parseDenseElementsAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00811">parseOpaqueElementsAttr()</a>, and <a class="el" href="AttributeParser_8cpp_source.html#l00873">parseSparseElementsAttr()</a>.</p>

</div>
</div>
<a id="ae6de673c0209f87f97ffda3eb5fae60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6de673c0209f87f97ffda3eb5fae60e">&#9670;&nbsp;</a></span>parseExtendedAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> Parser::parseExtendedAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an extended attribute. </p>
<p>extended-attribute ::= (dialect-attribute | attribute-alias) dialect-attribute ::= <code>#</code> dialect-namespace <code>&lt;</code> <code>"&lt;/tt&gt; attr-data &lt;tt&gt;"</code> <code>&gt;</code> dialect-attribute ::= <code>#</code> alias-name pretty-dialect-sym-body? attribute-alias ::= <code>#</code> alias-name </p>

<p class="definition">Definition at line <a class="el" href="DialectSymbolParser_8cpp_source.html#l00518">518</a> of file <a class="el" href="DialectSymbolParser_8cpp_source.html">DialectSymbolParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="Diagnostics_8cpp_source.html#l00301">mlir::emitError()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00631">mlir::Identifier::get()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00736">mlir::NoneType::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l00398">mlir::OpaqueAttr::getChecked()</a>, <a class="el" href="Attributes_8cpp_source.html#l00044">mlir::Attribute::getType()</a>, and <a class="el" href="namespacemlir.html#ac5ffe10560be9caf3b9e8de592c20e93">mlir::parseType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, and <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>.</p>

</div>
</div>
<a id="a62c71c6000da70678841612f9164a21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c71c6000da70678841612f9164a21b">&#9670;&nbsp;</a></span>parseExtendedType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> Parser::parseExtendedType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an extended type. </p>
<p>extended-type ::= (dialect-type | type-alias) dialect-type ::= <code>!</code> dialect-namespace <code>&lt;</code> <code>"&lt;/tt&gt; type-data &lt;tt&gt;"</code> <code>&gt;</code> dialect-type ::= <code>!</code> alias-name pretty-dialect-attribute-body? type-alias ::= <code>!</code> alias-name </p>

<p class="definition">Definition at line <a class="el" href="DialectSymbolParser_8cpp_source.html#l00560">560</a> of file <a class="el" href="DialectSymbolParser_8cpp_source.html">DialectSymbolParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00631">mlir::Identifier::get()</a>, and <a class="el" href="Types_8cpp_source.html#l00060">mlir::OpaqueType::getChecked()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00311">parseNonFunctionType()</a>.</p>

</div>
</div>
<a id="ac81212ccd3dfeb0d6b6c70034b8fc7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81212ccd3dfeb0d6b6c70034b8fc7b8">&#9670;&nbsp;</a></span>parseFloatAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> Parser::parseFloatAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isNegative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a float attribute. </p>

<p class="definition">Definition at line <a class="el" href="AttributeParser_8cpp_source.html#l00270">270</a> of file <a class="el" href="AttributeParser_8cpp_source.html">AttributeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00027">builder</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00105">consumeIf()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">emitError()</a>, <a class="el" href="Attributes_8cpp_source.html#l00220">mlir::FloatAttr::get()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00051">mlir::Builder::getF64Type()</a>, <a class="el" href="Token_8cpp_source.html#l00051">mlir::Token::getFloatingPointValue()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="Types_8h_source.html#l00312">mlir::Type::isa()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00050">parseType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, and <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>.</p>

</div>
</div>
<a id="a90a19fd41d1799954e884f1d1e09103a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a19fd41d1799954e884f1d1e09103a">&#9670;&nbsp;</a></span>parseFunctionResultTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> Parser::parseFunctionResultTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a function result type. </p>
<p>function-result-type ::= type-list-parens | non-function-type </p>

<p class="definition">Definition at line <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00061">61</a> of file <a class="el" href="Parser_2TypeParser_8cpp_source.html">TypeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00311">parseNonFunctionType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00092">parseTypeListParens()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00133">parseFunctionType()</a>.</p>

</div>
</div>
<a id="aa85e5ad2a4968203049c89bb6ee87c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85e5ad2a4968203049c89bb6ee87c9c">&#9670;&nbsp;</a></span>parseFunctionType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> Parser::parseFunctionType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a function type. </p>
<p>function-type ::= type-list-parens <code>-&gt;</code> function-result-type </p>

<p class="definition">Definition at line <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00133">133</a> of file <a class="el" href="Parser_2TypeParser_8cpp_source.html">TypeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00027">builder</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00070">mlir::Builder::getFunctionType()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00061">parseFunctionResultTypes()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00092">parseTypeListParens()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00050">parseType()</a>.</p>

</div>
</div>
<a id="aa8250388ee98fecf5ab85ed55675f14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8250388ee98fecf5ab85ed55675f14d">&#9670;&nbsp;</a></span>parseFusedLocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> Parser::parseFusedLocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a fused location instance. </p>

<p class="definition">Definition at line <a class="el" href="LocationParser_8cpp_source.html#l00079">79</a> of file <a class="el" href="LocationParser_8cpp_source.html">LocationParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00105">consumeIf()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="Location_8cpp_source.html#l00071">mlir::FusedLoc::get()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00033">getContext()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>, <a class="el" href="Parser_8cpp_source.html#l00037">parseCommaSeparatedList()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00172">parseLocationInstance()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, and <a class="el" href="LocationParser_8cpp_source.html#l00172">parseLocationInstance()</a>.</p>

</div>
</div>
<a id="acff9f259111c9192a4add33efc3ee467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff9f259111c9192a4add33efc3ee467">&#9670;&nbsp;</a></span>parseIntegerSetReference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> Parser::parseIntegerSetReference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineParser_8cpp_source.html#l00708">708</a> of file <a class="el" href="AffineParser_8cpp_source.html">AffineParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="Diagnostics_8cpp_source.html#l00301">mlir::emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>, and <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00237">parseOptionalTrailingLocation()</a>.</p>

</div>
</div>
<a id="ac74bb0c95ab2c9ae6bd4060938a81fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74bb0c95ab2c9ae6bd4060938a81fce">&#9670;&nbsp;</a></span>parseLocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> Parser::parseLocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an inline location. </p>
<p>Parse a location.</p>
<p>location ::= <code>loc</code> inline-location inline-location ::= '(' location-inst ')' </p>

<p class="definition">Definition at line <a class="el" href="LocationParser_8cpp_source.html#l00019">19</a> of file <a class="el" href="LocationParser_8cpp_source.html">LocationParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00172">parseLocationInstance()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>, and <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00237">parseOptionalTrailingLocation()</a>.</p>

</div>
</div>
<a id="a75f25754ab72a1e217786c5af31abd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f25754ab72a1e217786c5af31abd58">&#9670;&nbsp;</a></span>parseLocationInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> Parser::parseLocationInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a raw location instance. </p>

<p class="definition">Definition at line <a class="el" href="LocationParser_8cpp_source.html#l00172">172</a> of file <a class="el" href="LocationParser_8cpp_source.html">LocationParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">emitError()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00769">mlir::UnknownLoc::get()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00033">getContext()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00047">parseCallSiteLocation()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00079">parseFusedLocation()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00113">parseNameOrFileLineColLocation()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00047">parseCallSiteLocation()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00079">parseFusedLocation()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00019">parseLocation()</a>, and <a class="el" href="LocationParser_8cpp_source.html#l00113">parseNameOrFileLineColLocation()</a>.</p>

</div>
</div>
<a id="a092f374d9bb8ca0264dc0a499a5dbe2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a092f374d9bb8ca0264dc0a499a5dbe2b">&#9670;&nbsp;</a></span>parseMemRefType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">**<a class="el" href="classmlir_1_1Type.html">Type</a> Parser::parseMemRefType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a memref type. </p>
<p>memref-type ::= ranked-memref-type | unranked-memref-type</p>
<p>ranked-memref-type ::= <code>memref</code> <code>&lt;</code> dimension-list-ranked type (<code>,</code> semi-affine-map-composition)? (<code>,</code> memory-space)? <code>&gt;</code></p>
<p>unranked-memref-type ::= <code>memref</code> <code>&lt;*x</code> type (<code>,</code> memory-space)? <code>&gt;</code></p>
<p>semi-affine-map-composition ::= (semi-affine-map <code>,</code> )* semi-affine-map memory-space ::= integer-literal /* | TODO: address-space-id </p>

<p class="definition">Definition at line <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00192">192</a> of file <a class="el" href="Parser_2TypeParser_8cpp_source.html">TypeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00105">consumeIf()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="ParserState_8h_source.html#l00067">mlir::detail::ParserState::context</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00379">mlir::MemRefType::get()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00467">mlir::UnrankedMemRefType::get()</a>, <a class="el" href="Token_8cpp_source.html#l00019">mlir::Token::getLoc()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00203">mlir::AffineMap::getNumDims()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00211">mlir::AffineMap::getNumResults()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="Token_8cpp_source.html#l00029">mlir::Token::getUnsignedIntegerValue()</a>, <a class="el" href="Token_8h_source.html#l00037">mlir::Token::is()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00674">mlir::makeStridedLinearLayoutMap()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>, <a class="el" href="Parser_8cpp_source.html#l00057">parseCommaSeparatedListUntil()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00485">parseDimensionListRanked()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00149">parseStridedLayout()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00050">parseType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00526">parseXInDimensionList()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00311">parseNonFunctionType()</a>.</p>

</div>
</div>
<a id="ad73ca5eabcb2e4e30deff990f8c3959d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73ca5eabcb2e4e30deff990f8c3959d">&#9670;&nbsp;</a></span>parseNameOrFileLineColLocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> Parser::parseNameOrFileLineColLocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a name or FileLineCol location instance. </p>

<p class="definition">Definition at line <a class="el" href="LocationParser_8cpp_source.html#l00113">113</a> of file <a class="el" href="LocationParser_8cpp_source.html">LocationParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00105">consumeIf()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00631">mlir::Identifier::get()</a>, <a class="el" href="Location_8cpp_source.html#l00051">mlir::FileLineColLoc::get()</a>, <a class="el" href="Location_8cpp_source.html#l00111">mlir::NameLoc::get()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00033">getContext()</a>, <a class="el" href="Token_8cpp_source.html#l00019">mlir::Token::getLoc()</a>, <a class="el" href="Token_8cpp_source.html#l00083">mlir::Token::getStringValue()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="Token_8cpp_source.html#l00029">mlir::Token::getUnsignedIntegerValue()</a>, <a class="el" href="Attributes_8h_source.html#l01608">mlir::Attribute::isa()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00172">parseLocationInstance()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, and <a class="el" href="LocationParser_8cpp_source.html#l00172">parseLocationInstance()</a>.</p>

</div>
</div>
<a id="a567fdfd174f5a4e1cf5ddad304bc05d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567fdfd174f5a4e1cf5ddad304bc05d6">&#9670;&nbsp;</a></span>parseNonFunctionType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> Parser::parseNonFunctionType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a non function type. </p>
<p>Parse any type except the function type.</p>
<p>non-function-type ::= integer-type | index-type | float-type | extended-type | vector-type | tensor-type | memref-type | complex-type | tuple-type | none-type</p>
<p>index-type ::= <code>index</code> float-type ::= <code>f16</code> | <code>bf16</code> | <code>f32</code> | <code>f64</code> none-type ::= <code>none</code> </p>

<p class="definition">Definition at line <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00311">311</a> of file <a class="el" href="Parser_2TypeParser_8cpp_source.html">TypeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00027">builder</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">emitError()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00045">mlir::Builder::getBF16Type()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00722">mlir::IntegerType::getChecked()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00066">getEncodedSourceLocation()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00047">mlir::Builder::getF16Type()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00049">mlir::Builder::getF32Type()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00051">mlir::Builder::getF64Type()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00053">mlir::Builder::getIndexType()</a>, <a class="el" href="Token_8cpp_source.html#l00059">mlir::Token::getIntTypeBitwidth()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00078">mlir::Builder::getNoneType()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="StandardTypes_8h_source.html#l00176">mlir::IntegerType::kMaxWidth</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00110">parseComplexType()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00560">parseExtendedType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00192">parseMemRefType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00380">parseTensorType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00419">parseTupleType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00446">parseVectorType()</a>, <a class="el" href="StandardTypes_8h_source.html#l00127">mlir::IntegerType::Signed</a>, <a class="el" href="StandardTypes_8h_source.html#l00126">mlir::IntegerType::Signless</a>, and <a class="el" href="StandardTypes_8h_source.html#l00128">mlir::IntegerType::Unsigned</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00061">parseFunctionResultTypes()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00050">parseType()</a>.</p>

</div>
</div>
<a id="a9602168a86e4795712bd18506661747a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9602168a86e4795712bd18506661747a">&#9670;&nbsp;</a></span>parseOpaqueElementsAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> Parser::parseOpaqueElementsAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>attrType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an opaque elements attribute. </p>

<p class="definition">Definition at line <a class="el" href="AttributeParser_8cpp_source.html#l00811">811</a> of file <a class="el" href="AttributeParser_8cpp_source.html">AttributeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00027">builder</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">emitError()</a>, <a class="el" href="Attributes_8cpp_source.html#l01216">mlir::OpaqueElementsAttr::get()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00052">mlir::Builder::getContext()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00448">mlir::MLIRContext::getRegisteredDialect()</a>, <a class="el" href="Token_8cpp_source.html#l00083">mlir::Token::getStringValue()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00405">parseElementAttrHexValues()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00851">parseElementsLiteralType()</a>, and <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, and <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>.</p>

</div>
</div>
<a id="ab17ed8b9823cc3afeede212d776c9348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17ed8b9823cc3afeede212d776c9348">&#9670;&nbsp;</a></span>parseOptionalAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a> Parser::parseOptionalAttribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an optional attribute with the provided type. </p>

<p class="definition">Definition at line <a class="el" href="AttributeParser_8cpp_source.html#l00191">191</a> of file <a class="el" href="AttributeParser_8cpp_source.html">AttributeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8cpp_source.html#l00441">mlir::TypeAttr::get()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="OpDefinition_8h_source.html#l00064">mlir::OptionalParseResult::hasValue()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00021">parseOptionalType()</a>, <a class="el" href="LogicalResult_8h_source.html#l00040">mlir::succeeded()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, and <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>.</p>

</div>
</div>
<a id="a62b9d3cb872a229f0dfdcca0622bd2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b9d3cb872a229f0dfdcca0622bd2ce">&#9670;&nbsp;</a></span>parseOptionalTrailingLocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> mlir::detail::Parser::parseOptionalTrailingLocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse an optional trailing location. </p>
<p>trailing-location ::= (<code>loc</code> <code>(</code> location <code>)</code>)? </p>

<p class="definition">Definition at line <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00237">237</a> of file <a class="el" href="lib_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00721">parseAffineMapOfSSAIds()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00695">parseAffineMapOrIntegerSetReference()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00699">parseAffineMapReference()</a>, <a class="el" href="AffineParser_8cpp_source.html#l00708">parseIntegerSetReference()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00019">parseLocation()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>.</p>

</div>
</div>
<a id="a2227c605d7956d7f33c21d071d56cc0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2227c605d7956d7f33c21d071d56cc0a">&#9670;&nbsp;</a></span>parseOptionalType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a> Parser::parseOptionalType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optionally parse a type. </p>

<p class="definition">Definition at line <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00021">21</a> of file <a class="el" href="Parser_2TypeParser_8cpp_source.html">TypeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00050">parseType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00191">parseOptionalAttribute()</a>, and <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>.</p>

</div>
</div>
<a id="a4c9f03156204f3f62722bb638811a906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c9f03156204f3f62722bb638811a906">&#9670;&nbsp;</a></span>parsePrettyDialectSymbolName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> Parser::parsePrettyDialectSymbolName </td>
          <td>(</td>
          <td class="paramtype">StringRef &amp;&#160;</td>
          <td class="paramname"><em>prettyName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the body of a pretty dialect symbol, which starts and ends with &lt;&gt;'s, and may be recursive. </p>
<p>Return with the 'prettyName' StringRef encompassing the entire pretty name.</p>
<p>pretty-dialect-sym-body ::= '&lt;' pretty-dialect-sym-contents+ '&gt;' pretty-dialect-sym-contents ::= pretty-dialect-sym-body | '(' pretty-dialect-sym-contents+ ')' | '[' pretty-dialect-sym-contents+ ']' | '{' pretty-dialect-sym-contents+ '}' | '[^[&lt;({&gt;])}\0]+' </p>

<p class="definition">Definition at line <a class="el" href="DialectSymbolParser_8cpp_source.html#l00338">338</a> of file <a class="el" href="DialectSymbolParser_8cpp_source.html">DialectSymbolParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="Diagnostics_8cpp_source.html#l00301">mlir::emitError()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00034">getSourceMgr()</a>, and <a class="el" href="DialectSymbolParser_8cpp_source.html#l00404">parseExtendedSymbol()</a>.</p>

</div>
</div>
<a id="aa99a023e952f3b5a959cdb38f9fa9255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99a023e952f3b5a959cdb38f9fa9255">&#9670;&nbsp;</a></span>parseSparseElementsAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> Parser::parseSparseElementsAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>attrType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a sparse elements attribute. </p>
<p>Parse the indices. We don't allow hex values here as we may need to use the inferred shape.</p>
<p>Parse the values.</p>
<p>Sanity check. </p>

<p class="definition">Definition at line <a class="el" href="AttributeParser_8cpp_source.html#l00873">873</a> of file <a class="el" href="AttributeParser_8cpp_source.html">AttributeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00027">builder</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00105">consumeIf()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">emitError()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00325">mlir::RankedTensorType::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l00721">mlir::DenseElementsAttr::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l01247">mlir::SparseElementsAttr::get()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00207">mlir::ShapedType::getDimSize()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00184">mlir::ShapedType::getElementType()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00061">mlir::Builder::getIntegerType()</a>, <a class="el" href="Token_8cpp_source.html#l00019">mlir::Token::getLoc()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00201">mlir::ShapedType::getRank()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00247">mlir::ShapedType::getShape()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00851">parseElementsLiteralType()</a>, and <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, and <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>.</p>

</div>
</div>
<a id="ab90e481023ad158179256bc3aab0cf19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90e481023ad158179256bc3aab0cf19">&#9670;&nbsp;</a></span>parseStridedLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> Parser::parseStridedLayout </td>
          <td>(</td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>strides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse strided layout specification. </p>
<p>Parse the offset and strides from a strided layout specification.</p>
<p>strided-layout ::= <code>offset:</code> dimension <code>,</code> <code>strides:</code> stride-list </p>

<p class="definition">Definition at line <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00149">149</a> of file <a class="el" href="Parser_2TypeParser_8cpp_source.html">TypeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00105">consumeIf()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">mlir::failed()</a>, <a class="el" href="StandardTypes_8h_source.html#l00526">mlir::MemRefType::getDynamicStrideOrOffset()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="Token_8cpp_source.html#l00029">mlir::Token::getUnsignedIntegerValue()</a>, <a class="el" href="Token_8h_source.html#l00037">mlir::Token::is()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00542">parseStrideList()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00192">parseMemRefType()</a>.</p>

</div>
</div>
<a id="ae3903a4aa0d7b1a9d10fd084e514b740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3903a4aa0d7b1a9d10fd084e514b740">&#9670;&nbsp;</a></span>parseStrideList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> Parser::parseStrideList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00542">542</a> of file <a class="el" href="Parser_2TypeParser_8cpp_source.html">TypeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00105">consumeIf()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="StandardTypes_8h_source.html#l00526">mlir::MemRefType::getDynamicStrideOrOffset()</a>, <a class="el" href="Token_8h_source.html#l00033">mlir::Token::getSpelling()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="StandardTypes_8h_source.html#l00300">mlir::ShapedType::isDynamic()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00149">parseStridedLayout()</a>.</p>

</div>
</div>
<a id="afbb86c6d4cbbf1f86907bbf0cb1f69a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb86c6d4cbbf1f86907bbf0cb1f69a4">&#9670;&nbsp;</a></span>parseTensorType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> Parser::parseTensorType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a tensor type. </p>
<p>tensor-type ::= <code>tensor</code> <code>&lt;</code> dimension-list type <code>&gt;</code> dimension-list ::= dimension-list-ranked | <code>*x</code> </p>

<p class="definition">Definition at line <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00380">380</a> of file <a class="el" href="Parser_2TypeParser_8cpp_source.html">TypeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00105">consumeIf()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">emitError()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00325">mlir::RankedTensorType::get()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00355">mlir::UnrankedTensorType::get()</a>, <a class="el" href="Token_8cpp_source.html#l00019">mlir::Token::getLoc()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00312">mlir::TensorType::isValidElementType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00485">parseDimensionListRanked()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00050">parseType()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00526">parseXInDimensionList()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00311">parseNonFunctionType()</a>.</p>

</div>
</div>
<a id="a248e39ef883f96502a179273c2acc82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a248e39ef883f96502a179273c2acc82d">&#9670;&nbsp;</a></span>parseToken()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> Parser::parseToken </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Token.html#aa7e0ab69e7e455be057896d495926095">Token::Kind</a>&#160;</td>
          <td class="paramname"><em>expectedToken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consume the specified token if present and return success. </p>
<p>On failure, output a diagnostic and return failure. </p>

<p class="definition">Definition at line <a class="el" href="Parser_8cpp_source.html#l00088">88</a> of file <a class="el" href="Parser_8cpp_source.html">Parser.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8cpp_source.html#l00151">mlir::Block::addArgument()</a>, <a class="el" href="OperationSupport_8h_source.html#l00401">mlir::OperationState::addSuccessors()</a>, <a class="el" href="OperationSupport_8h_source.html#l00376">mlir::OperationState::addTypes()</a>, <a class="el" href="Diagnostics_8h_source.html#l00241">mlir::Diagnostic::append()</a>, <a class="el" href="Diagnostics_8h_source.html#l00332">mlir::InFlightDiagnostic::append()</a>, <a class="el" href="Diagnostics_8h_source.html#l00343">mlir::InFlightDiagnostic::attachNote()</a>, <a class="el" href="ParserState_8h_source.html#l00026">mlir::detail::SymbolState::attributeAliasDefinitions</a>, <a class="el" href="OperationSupport_8h_source.html#l00358">mlir::OperationState::attributes</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00105">consumeIf()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="Operation_8cpp_source.html#l00067">mlir::Operation::create()</a>, <a class="el" href="Types_8h_source.html#l00322">mlir::Type::dyn_cast()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="Attributes_8cpp_source.html#l00058">mlir::AffineMapAttr::get()</a>, <a class="el" href="Operation_8cpp_source.html#l00054">mlir::OperationName::getAbstractOperation()</a>, <a class="el" href="Block_8h_source.html#l00103">mlir::Block::getArgument()</a>, <a class="el" href="IR_2Region_8h_source.html#l00045">mlir::Region::getBlocks()</a>, <a class="el" href="Module_8cpp_source.html#l00096">mlir::ModuleOp::getBodyRegion()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00033">getContext()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00066">getEncodedSourceLocation()</a>, <a class="el" href="Token_8cpp_source.html#l00019">mlir::Token::getLoc()</a>, <a class="el" href="Block_8h_source.html#l00102">mlir::Block::getNumArguments()</a>, <a class="el" href="Operation_8cpp_source.html#l00540">mlir::Operation::getNumResults()</a>, <a class="el" href="Operation_8h_source.html#l00275">mlir::Operation::getResult()</a>, <a class="el" href="Token_8h_source.html#l00033">mlir::Token::getSpelling()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00032">getState()</a>, <a class="el" href="Token_8cpp_source.html#l00083">mlir::Token::getStringValue()</a>, <a class="el" href="Token_8cpp_source.html#l00129">mlir::Token::getSymbolReference()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00101">getTokenSpelling()</a>, <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>, <a class="el" href="Token_8cpp_source.html#l00040">mlir::Token::getUInt64IntegerValue()</a>, <a class="el" href="OperationSupport_8h_source.html#l00132">mlir::AbstractOperation::hasProperty()</a>, <a class="el" href="OpDefinition_8h_source.html#l00064">mlir::OptionalParseResult::hasValue()</a>, <a class="el" href="Token_8h_source.html#l00037">mlir::Token::is()</a>, <a class="el" href="Token_8h_source.html#l00049">mlir::Token::isNot()</a>, <a class="el" href="namespacemlir.html#a583774594e92d8af2d0884e3262d7e24aee504cc3a721fbb8c7898dcc0798d273">mlir::IsolatedFromAbove</a>, <a class="el" href="OperationSupport_8h_source.html#l00353">mlir::OperationState::location</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00607">mlir::AbstractOperation::lookup()</a>, <a class="el" href="OperationSupport_8h_source.html#l00085">mlir::AbstractOperation::name</a>, <a class="el" href="OperationSupport_8h_source.html#l00354">mlir::OperationState::name</a>, <a class="el" href="StandardTypes_8h_source.html#l00063">mlir::StandardTypes::None</a>, <a class="el" href="OperationSupport_8h_source.html#l00355">mlir::OperationState::operands</a>, <a class="el" href="AffineParser_8cpp_source.html#l00721">parseAffineMapOfSSAIds()</a>, <a class="el" href="OperationSupport_8h_source.html#l00094">mlir::AbstractOperation::parseAssembly</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00230">parseAttributeDict()</a>, <a class="el" href="Parser_8cpp_source.html#l00037">parseCommaSeparatedList()</a>, <a class="el" href="Parser_8cpp_source.html#l00057">parseCommaSeparatedListUntil()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00191">parseOptionalAttribute()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00237">parseOptionalTrailingLocation()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00021">parseOptionalType()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00029">Parser()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00050">parseType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00077">parseTypeListNoParens()</a>, <a class="el" href="IR_2Region_8h_source.html#l00057">mlir::Region::push_back()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00080">mlir::NamedAttrList::push_back()</a>, <a class="el" href="OperationSupport_8h_source.html#l00362">mlir::OperationState::regions</a>, <a class="el" href="OpDefinition_8h_source.html#l00173">mlir::OpState::setAttrs()</a>, <a class="el" href="OpDefinition_8h_source.html#l00139">mlir::OpState::setLoc()</a>, <a class="el" href="LogicalResult_8h_source.html#l00040">mlir::succeeded()</a>, <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>, <a class="el" href="ParserState_8h_source.html#l00076">mlir::detail::ParserState::symbols</a>, <a class="el" href="namespacemlir.html#a583774594e92d8af2d0884e3262d7e24ab420c1d31e69a823fbc30a434907c9c0">mlir::Terminator</a>, and <a class="el" href="ParserState_8h_source.html#l00029">mlir::detail::SymbolState::typeAliasDefinitions</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00230">parseAttributeDict()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00047">parseCallSiteLocation()</a>, <a class="el" href="Parser_8cpp_source.html#l00057">parseCommaSeparatedListUntil()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00110">parseComplexType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00790">parseDenseElementsAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00851">parseElementsLiteralType()</a>, <a class="el" href="DialectSymbolParser_8cpp_source.html#l00404">parseExtendedSymbol()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00133">parseFunctionType()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00079">parseFusedLocation()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00019">parseLocation()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00192">parseMemRefType()</a>, <a class="el" href="LocationParser_8cpp_source.html#l00113">parseNameOrFileLineColLocation()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00811">parseOpaqueElementsAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00873">parseSparseElementsAttr()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00380">parseTensorType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00419">parseTupleType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00092">parseTypeListParens()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00446">parseVectorType()</a>.</p>

</div>
</div>
<a id="a63cb429899024e4b9e77f77e85c2bf29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63cb429899024e4b9e77f77e85c2bf29">&#9670;&nbsp;</a></span>parseTupleType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> Parser::parseTupleType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a tuple type. </p>
<p>tuple-type ::= <code>tuple</code> <code>&lt;</code> (type (<code>,</code> type)*)? <code>&gt;</code> </p>

<p class="definition">Definition at line <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00419">419</a> of file <a class="el" href="Parser_2TypeParser_8cpp_source.html">TypeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00105">consumeIf()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00648">mlir::TupleType::get()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00033">getContext()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00077">parseTypeListNoParens()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00311">parseNonFunctionType()</a>.</p>

</div>
</div>
<a id="a3a15e0b925f74a53f28af9b5c4a6700a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a15e0b925f74a53f28af9b5c4a6700a">&#9670;&nbsp;</a></span>parseType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> Parser::parseType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an arbitrary type. </p>
<p>type ::= function-type | non-function-type </p>

<p class="definition">Definition at line <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00050">50</a> of file <a class="el" href="Parser_2TypeParser_8cpp_source.html">TypeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00133">parseFunctionType()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00311">parseNonFunctionType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00110">parseComplexType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00344">parseDecOrHexAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00851">parseElementsLiteralType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00270">parseFloatAttr()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00192">parseMemRefType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00021">parseOptionalType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00380">parseTensorType()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00077">parseTypeListNoParens()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00446">parseVectorType()</a>.</p>

</div>
</div>
<a id="ae08124cef82f51196eca2f88ea6cf967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08124cef82f51196eca2f88ea6cf967">&#9670;&nbsp;</a></span>parseTypeListNoParens()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> Parser::parseTypeListNoParens </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a list of types without an enclosing parenthesis. </p>
<p>The list must have at least one member.</p>
<p>type-list-no-parens ::= type (<code>,</code> type)* </p>

<p class="definition">Definition at line <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00077">77</a> of file <a class="el" href="Parser_2TypeParser_8cpp_source.html">TypeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="Parser_8cpp_source.html#l00037">parseCommaSeparatedList()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00050">parseType()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00419">parseTupleType()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00092">parseTypeListParens()</a>.</p>

</div>
</div>
<a id="a4c12fb5b201435c6ac2b43174df2d153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c12fb5b201435c6ac2b43174df2d153">&#9670;&nbsp;</a></span>parseTypeListParens()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> Parser::parseTypeListParens </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a parenthesized list of types. </p>
<p>type-list-parens ::= <code>(</code> <code>)</code> | <code>(</code> type-list-no-parens <code>)</code> </p>

<p class="definition">Definition at line <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00092">92</a> of file <a class="el" href="Parser_2TypeParser_8cpp_source.html">TypeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00077">parseTypeListNoParens()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00061">parseFunctionResultTypes()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00133">parseFunctionType()</a>.</p>

</div>
</div>
<a id="aa099de69a347073f8ff8665ca9afc46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa099de69a347073f8ff8665ca9afc46e">&#9670;&nbsp;</a></span>parseVectorType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1VectorType.html">VectorType</a> Parser::parseVectorType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a vector type. </p>
<p>vector-type ::= <code>vector</code> <code>&lt;</code> non-empty-static-dimension-list type <code>&gt;</code> non-empty-static-dimension-list ::= decimal-literal <code>x</code> static-dimension-list static-dimension-list ::= (decimal-literal <code>x</code>)* </p>

<p class="definition">Definition at line <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00446">446</a> of file <a class="el" href="Parser_2TypeParser_8cpp_source.html">TypeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">emitError()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00271">mlir::VectorType::get()</a>, <a class="el" href="Token_8cpp_source.html#l00019">mlir::Token::getLoc()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="StandardTypes_8h_source.html#l00337">mlir::VectorType::isValidElementType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00485">parseDimensionListRanked()</a>, <a class="el" href="Parser_8cpp_source.html#l00088">parseToken()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00050">parseType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00311">parseNonFunctionType()</a>.</p>

</div>
</div>
<a id="a1f02a4067ccb0b7c56b59d04838e923c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f02a4067ccb0b7c56b59d04838e923c">&#9670;&nbsp;</a></span>parseXInDimensionList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> Parser::parseXInDimensionList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an 'x' token in a dimension list, handling the case where the x is juxtaposed with an element type, as in "xf32", leaving the "f32" as the next token. </p>

<p class="definition">Definition at line <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00526">526</a> of file <a class="el" href="Parser_2TypeParser_8cpp_source.html">TypeParser.cpp</a>.</p>

<p class="reference">References <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00113">consumeToken()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00059">emitError()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00100">getToken()</a>, <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00101">getTokenSpelling()</a>, <a class="el" href="ParserState_8h_source.html#l00070">mlir::detail::ParserState::lex</a>, <a class="el" href="Lexer_8h_source.html#l00037">mlir::Lexer::resetPointer()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00122">consumeToken()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00485">parseDimensionListRanked()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00192">parseMemRefType()</a>, and <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00380">parseTensorType()</a>.</p>

</div>
</div>
<a id="a36ea59f2fb250d4223778fcf4120d639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ea59f2fb250d4223778fcf4120d639">&#9670;&nbsp;</a></span>remapLocationToTopLevelBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SMLoc mlir::detail::Parser::remapLocationToTopLevelBuffer </td>
          <td>(</td>
          <td class="paramtype">llvm::SMLoc&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remaps the given SMLoc to the top level lexer of the parser. </p>
<p>This is used to adjust locations of potentially nested parsers to ensure that they can be emitted properly as diagnostics. </p>

<p class="definition">Definition at line <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00079">79</a> of file <a class="el" href="lib_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">References <a class="el" href="Lexer_8h_source.html#l00040">mlir::Lexer::getBufferBegin()</a>, <a class="el" href="ParserState_8h_source.html#l00070">mlir::detail::ParserState::lex</a>, <a class="el" href="ParserState_8h_source.html#l00035">mlir::detail::SymbolState::nestedParserLocs</a>, <a class="el" href="ParserState_8h_source.html#l00079">mlir::detail::ParserState::parserDepth</a>, <a class="el" href="ParserState_8h_source.html#l00076">mlir::detail::ParserState::symbols</a>, and <a class="el" href="ParserState_8h_source.html#l00040">mlir::detail::SymbolState::topLevelLexer</a>.</p>

<p class="reference">Referenced by <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00066">getEncodedSourceLocation()</a>, and <a class="el" href="DialectSymbolParser_8cpp_source.html#l00404">parseExtendedSymbol()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a32a5dd9790fcfbe5f7776977cf86d3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a5dd9790fcfbe5f7776977cf86d3e8">&#9670;&nbsp;</a></span>builder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Builder.html">Builder</a> mlir::detail::Parser::builder</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="lib_2Parser_2Parser_8h_source.html#l00027">27</a> of file <a class="el" href="lib_2Parser_2Parser_8h_source.html">Parser.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeParser_8cpp_source.html#l00041">parseAttribute()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00230">parseAttributeDict()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00344">parseDecOrHexAttr()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00270">parseFloatAttr()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00133">parseFunctionType()</a>, <a class="el" href="Parser_2TypeParser_8cpp_source.html#l00311">parseNonFunctionType()</a>, <a class="el" href="AttributeParser_8cpp_source.html#l00811">parseOpaqueElementsAttr()</a>, and <a class="el" href="AttributeParser_8cpp_source.html#l00873">parseSparseElementsAttr()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>lib/Parser/<a class="el" href="lib_2Parser_2Parser_8h_source.html">Parser.h</a></li>
<li>lib/Parser/<a class="el" href="AffineParser_8cpp_source.html">AffineParser.cpp</a></li>
<li>lib/Parser/<a class="el" href="AttributeParser_8cpp_source.html">AttributeParser.cpp</a></li>
<li>lib/Parser/<a class="el" href="DialectSymbolParser_8cpp_source.html">DialectSymbolParser.cpp</a></li>
<li>lib/Parser/<a class="el" href="LocationParser_8cpp_source.html">LocationParser.cpp</a></li>
<li>lib/Parser/<a class="el" href="Parser_8cpp_source.html">Parser.cpp</a></li>
<li>lib/Parser/<a class="el" href="Parser_2TypeParser_8cpp_source.html">TypeParser.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Aug 8 2020 16:27:20 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
