<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::scf Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">12.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1scf.html">scf</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::scf Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a82927bf8dc031e20dbe7f1437c1fa7da"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">ValueVector</a> = std::vector&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td></tr>
<tr class="memdesc:a82927bf8dc031e20dbe7f1437c1fa7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">An owning vector of values, handy to return from functions.  <a href="#a82927bf8dc031e20dbe7f1437c1fa7da">More...</a><br /></td></tr>
<tr class="separator:a82927bf8dc031e20dbe7f1437c1fa7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a601f846f06f5959b1a052e975eae8ec1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a601f846f06f5959b1a052e975eae8ec1">buildTerminatedBody</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a601f846f06f5959b1a052e975eae8ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default callback for IfOp builders. Inserts a yield without arguments.  <a href="#a601f846f06f5959b1a052e975eae8ec1">More...</a><br /></td></tr>
<tr class="separator:a601f846f06f5959b1a052e975eae8ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888e692b007039a6d2172e34bb0bc429"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a888e692b007039a6d2172e34bb0bc429">ensureLoopTerminator</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="separator:a888e692b007039a6d2172e34bb0bc429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e4957ac11a0c4d95f6a1494c808b392"><td class="memItemLeft" align="right" valign="top">ForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a7e4957ac11a0c4d95f6a1494c808b392">getForInductionVarOwner</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a7e4957ac11a0c4d95f6a1494c808b392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the loop parent of an induction variable.  <a href="#a7e4957ac11a0c4d95f6a1494c808b392">More...</a><br /></td></tr>
<tr class="separator:a7e4957ac11a0c4d95f6a1494c808b392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13caec83d2c9665221580ea507c6e68b"><td class="memItemLeft" align="right" valign="top">ParallelOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a13caec83d2c9665221580ea507c6e68b">getParallelForInductionVarOwner</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a13caec83d2c9665221580ea507c6e68b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parallel loop parent of an induction variable.  <a href="#a13caec83d2c9665221580ea507c6e68b">More...</a><br /></td></tr>
<tr class="separator:a13caec83d2c9665221580ea507c6e68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e857e851c7fc8a8c7cb7318e8d45ee4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">ValueVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#a1e857e851c7fc8a8c7cb7318e8d45ee4">buildLoopNest</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> steps, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> iterArgs, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">ValueVector</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilder=nullptr)</td></tr>
<tr class="memdesc:a1e857e851c7fc8a8c7cb7318e8d45ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a perfect nest of "for" loops, i.e.  <a href="#a1e857e851c7fc8a8c7cb7318e8d45ee4">More...</a><br /></td></tr>
<tr class="separator:a1e857e851c7fc8a8c7cb7318e8d45ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecda447d337504eff50669757c36f5d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">ValueVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#aecda447d337504eff50669757c36f5d3">buildLoopNest</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> steps, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilder=nullptr)</td></tr>
<tr class="memdesc:aecda447d337504eff50669757c36f5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience version for building loop nests without iteration arguments (like for reductions).  <a href="#aecda447d337504eff50669757c36f5d3">More...</a><br /></td></tr>
<tr class="separator:aecda447d337504eff50669757c36f5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac316a00289a9c7b41712aa0a0de2ea0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#ac316a00289a9c7b41712aa0a0de2ea0c">naivelyFuseParallelOps</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memdesc:ac316a00289a9c7b41712aa0a0de2ea0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuses all adjacent scf.parallel operations with identical bounds and step into one scf.parallel operations.  <a href="#ac316a00289a9c7b41712aa0a0de2ea0c">More...</a><br /></td></tr>
<tr class="separator:ac316a00289a9c7b41712aa0a0de2ea0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc49ed84bb5951dd6eb0d09ada172b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1scf.html#aedc49ed84bb5951dd6eb0d09ada172b4">tileParallelLoop</a> (ParallelOp op, <a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; int64_t &gt; tileSizes)</td></tr>
<tr class="memdesc:aedc49ed84bb5951dd6eb0d09ada172b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile a parallel loop of the form scf.parallel (i0, i1) = (arg0, arg1) to (arg2, arg3) step (arg4, arg5)  <a href="#aedc49ed84bb5951dd6eb0d09ada172b4">More...</a><br /></td></tr>
<tr class="separator:aedc49ed84bb5951dd6eb0d09ada172b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a82927bf8dc031e20dbe7f1437c1fa7da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82927bf8dc031e20dbe7f1437c1fa7da">&#9670;&nbsp;</a></span>ValueVector</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">mlir::scf::ValueVector</a> = typedef std::vector&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An owning vector of values, handy to return from functions. </p>

<p class="definition">Definition at line <a class="el" href="SCF_8h_source.html#l00049">49</a> of file <a class="el" href="SCF_8h_source.html">SCF.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a1e857e851c7fc8a8c7cb7318e8d45ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e857e851c7fc8a8c7cb7318e8d45ee4">&#9670;&nbsp;</a></span>buildLoopNest() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">ValueVector</a> mlir::scf::buildLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>iterArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">ValueVector</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilder</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a perfect nest of "for" loops, i.e. </p>
<p>all loops but the innermost contain only another loop and a terminator. The lower, upper bounds and steps are provided as <code>lbs</code>, <code>ubs</code> and <code>steps</code>, which are expected to be of the same size. <code>iterArgs</code> points to the initial values of the loop iteration arguments, which will be forwarded through the nest to the innermost loop. The body of the loop is populated using <code>bodyBuilder</code>, which accepts an ordered list of induction variables of all loops, followed by a list of iteration arguments of the innermost loop, in the same order as provided to <code>iterArgs</code>. This function is expected to return as many values as <code>iterArgs</code>, of the same type and in the same order, that will be treated as yielded from the loop body and forwarded back through the loop nest. If the function is not provided, the loop nest is not expected to have iteration arguments, the body of the innermost loop will be left empty, containing only the zero-operand terminator. Returns the values yielded by the outermost loop. If bound arrays are empty, the body builder will be called once to construct the IR outside of the loop with an empty list of induction variables. </p>

<p class="definition">Definition at line <a class="el" href="SCF_8cpp_source.html#l00276">276</a> of file <a class="el" href="SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00376">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00336">mlir::OpBuilder::setInsertionPointToEnd()</a>, and <a class="el" href="IR_2Builders_8h_source.html#l00331">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SCF_8cpp_source.html#l00347">buildLoopNest()</a>, and <a class="el" href="Dialect_2SCF_2EDSC_2Builders_8cpp_source.html#l00018">mlir::edsc::loopNestBuilder()</a>.</p>

</div>
</div>
<a id="aecda447d337504eff50669757c36f5d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecda447d337504eff50669757c36f5d3">&#9670;&nbsp;</a></span>buildLoopNest() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir_1_1scf.html#a82927bf8dc031e20dbe7f1437c1fa7da">ValueVector</a> mlir::scf::buildLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilder</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience version for building loop nests without iteration arguments (like for reductions). </p>
<p>Does not take the initial value of reductions or expect the body building functions to return their current value. </p>

<p class="definition">Definition at line <a class="el" href="SCF_8cpp_source.html#l00347">347</a> of file <a class="el" href="SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8cpp_source.html#l00185">mlir::OperationState::addOperands()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00193">mlir::OperationState::addRegion()</a>, <a class="el" href="OperationSupport_8h_source.html#l00376">mlir::OperationState::addTypes()</a>, <a class="el" href="SCF_8cpp_source.html#l00276">buildLoopNest()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00368">mlir::OpBuilder::createBlock()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00342">mlir::OpBuilder::getInsertionBlock()</a>, <a class="el" href="Block_8cpp_source.html#l00036">mlir::Block::getParent()</a>, and <a class="el" href="OperationSupport_8h_source.html#l00353">mlir::OperationState::location</a>.</p>

</div>
</div>
<a id="a601f846f06f5959b1a052e975eae8ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601f846f06f5959b1a052e975eae8ec1">&#9670;&nbsp;</a></span>buildTerminatedBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::buildTerminatedBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default callback for IfOp builders. Inserts a yield without arguments. </p>

<p class="definition">Definition at line <a class="el" href="SCF_8cpp_source.html#l00065">65</a> of file <a class="el" href="SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8cpp_source.html#l00151">mlir::Block::addArgument()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00185">mlir::OperationState::addOperands()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00193">mlir::OperationState::addRegion()</a>, <a class="el" href="OperationSupport_8h_source.html#l00376">mlir::OperationState::addTypes()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00376">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Region_8h_source.html#l00061">mlir::Region::front()</a>, <a class="el" href="Block_8h_source.html#l00103">mlir::Block::getArgument()</a>, <a class="el" href="Block_8h_source.html#l00071">mlir::Block::getArguments()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00053">mlir::Builder::getIndexType()</a>, <a class="el" href="OperationSupport_8h_source.html#l00353">mlir::OperationState::location</a>, <a class="el" href="IR_2Region_8h_source.html#l00057">mlir::Region::push_back()</a>, and <a class="el" href="IR_2Builders_8h_source.html#l00331">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

</div>
</div>
<a id="a888e692b007039a6d2172e34bb0bc429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888e692b007039a6d2172e34bb0bc429">&#9670;&nbsp;</a></span>ensureLoopTerminator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::ensureLoopTerminator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e4957ac11a0c4d95f6a1494c808b392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e4957ac11a0c4d95f6a1494c808b392">&#9670;&nbsp;</a></span>getForInductionVarOwner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ForOp mlir::scf::getForInductionVarOwner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the loop parent of an induction variable. </p>
<p>If the provided value is not an induction variable, then return nullptr. </p>

<p class="reference">Referenced by <a class="el" href="SliceAnalysis_8cpp_source.html#l00081">getBackwardSliceImpl()</a>, <a class="el" href="SCF_8cpp_source.html#l00166">parseForOp()</a>, and <a class="el" href="Transforms_8cpp_source.html#l00299">substitute()</a>.</p>

</div>
</div>
<a id="a13caec83d2c9665221580ea507c6e68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13caec83d2c9665221580ea507c6e68b">&#9670;&nbsp;</a></span>getParallelForInductionVarOwner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParallelOp mlir::scf::getParallelForInductionVarOwner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the parallel loop parent of an induction variable. </p>
<p>If the provided value is not an induction variable, then return nullptr. </p>

<p class="definition">Definition at line <a class="el" href="SCF_8cpp_source.html#l00723">723</a> of file <a class="el" href="SCF_8cpp_source.html">SCF.cpp</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8cpp_source.html#l00185">mlir::OperationState::addOperands()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00193">mlir::OperationState::addRegion()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00164">mlir::PatternRewriter::cloneRegionBefore()</a>, <a class="el" href="PatternMatch_8h_source.html#l00253">mlir::PatternRewriter::create()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00368">mlir::OpBuilder::createBlock()</a>, <a class="el" href="Value_8h_source.html#l00090">mlir::Value::dyn_cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="Block_8h_source.html#l00103">mlir::Block::getArgument()</a>, <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>, <a class="el" href="PatternMatch_8h_source.html#l00454">mlir::OwningRewritePatternList::insert()</a>, <a class="el" href="OperationSupport_8h_source.html#l00353">mlir::OperationState::location</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00030">mlir::BlockAndValueMapping::map()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00080">mlir::PatternRewriter::replaceOp()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Transforms_8cpp_source.html#l00299">substitute()</a>.</p>

</div>
</div>
<a id="ac316a00289a9c7b41712aa0a0de2ea0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac316a00289a9c7b41712aa0a0de2ea0c">&#9670;&nbsp;</a></span>naivelyFuseParallelOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::naivelyFuseParallelOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fuses all adjacent scf.parallel operations with identical bounds and step into one scf.parallel operations. </p>
<p>Uses a naive aliasing and dependency analysis. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00131">131</a> of file <a class="el" href="ParallelLoopFusion_8cpp_source.html">ParallelLoopFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00116">fuseIfLegal()</a>, and <a class="el" href="Operation_8h_source.html#l00400">mlir::Operation::getRegions()</a>.</p>

</div>
</div>
<a id="aedc49ed84bb5951dd6eb0d09ada172b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc49ed84bb5951dd6eb0d09ada172b4">&#9670;&nbsp;</a></span>tileParallelLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::tileParallelLoop </td>
          <td>(</td>
          <td class="paramtype">ParallelOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile a parallel loop of the form scf.parallel (i0, i1) = (arg0, arg1) to (arg2, arg3) step (arg4, arg5) </p>
<p>into scf.parallel (i0, i1) = (arg0, arg1) to (arg2, arg3) step (arg4*tileSize[0], arg5*tileSize[1]) scf.parallel (j0, j1) = (0, 0) to (min(tileSize[0], arg2-j0) min(tileSize[1], arg3-j1)) step (arg4, arg5) The old loop is replaced with the new one.</p>
<p>into scf.parallel (i0, i1) = (arg0, arg1) to (arg2, arg3) step (arg4*tileSize[0], arg5*tileSize[1]) scf.parallel (j0, j1) = (0, 0) to (min(arg4*tileSize[0], arg2-i0) min(arg5*tileSize[1], arg3-i1)) step (arg4, arg5)</p>
<p>where the uses of i0 and i1 in the loop body are replaced by i0 + j0 and i1 + j1. The old loop is replaced with the new one. </p>

<p class="definition">Definition at line <a class="el" href="ParallelLoopTiling_8cpp_source.html#l00039">39</a> of file <a class="el" href="ParallelLoopTiling_8cpp_source.html">ParallelLoopTiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00376">mlir::OpBuilder::create()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00807">mlir::AffineMap::get()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00456">mlir::getAffineDimExpr()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00052">mlir::Builder::getContext()</a>, <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00053">mlir::Builder::getIndexType()</a>, <a class="el" href="Value_8cpp_source.html#l00131">mlir::Value::replaceAllUsesExcept()</a>, and <a class="el" href="IR_2Builders_8h_source.html#l00331">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ParallelLoopTiling_8cpp_source.html#l00131">getInnermostNestedLoops()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Aug 8 2020 16:27:20 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
