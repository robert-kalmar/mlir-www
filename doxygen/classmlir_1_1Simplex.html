<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::Simplex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">12.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1Simplex.html">Simplex</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmlir_1_1Simplex-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::Simplex Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class implements a version of the <a class="el" href="classmlir_1_1Simplex.html" title="This class implements a version of the Simplex and Generalized Basis Reduction algorithms, which can perform analysis of integer sets with affine inequalities and equalities. ">Simplex</a> and Generalized Basis Reduction algorithms, which can perform analysis of integer sets with affine inequalities and equalities.  
 <a href="classmlir_1_1Simplex.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="Simplex_8h_source.html">mlir/Analysis/Presburger/Simplex.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6175b9ad18f1d01d5e680b48f1e02c12"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Simplex.html#a6175b9ad18f1d01d5e680b48f1e02c12">Direction</a> { <a class="el" href="classmlir_1_1Simplex.html#a6175b9ad18f1d01d5e680b48f1e02c12a258f49887ef8d14ac268c92b02503aaa">Direction::Up</a>, 
<a class="el" href="classmlir_1_1Simplex.html#a6175b9ad18f1d01d5e680b48f1e02c12a08a38277b0309070706f6652eeae9a53">Direction::Down</a>
 }</td></tr>
<tr class="separator:a6175b9ad18f1d01d5e680b48f1e02c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a783e09831e97f63f9536b83ff6e65fa9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Simplex.html#a783e09831e97f63f9536b83ff6e65fa9">Simplex</a> ()=delete</td></tr>
<tr class="separator:a783e09831e97f63f9536b83ff6e65fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc961839522a19b6dce1374ee35a4f88"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Simplex.html#acc961839522a19b6dce1374ee35a4f88">Simplex</a> (unsigned nVar)</td></tr>
<tr class="memdesc:acc961839522a19b6dce1374ee35a4f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classmlir_1_1Simplex.html" title="This class implements a version of the Simplex and Generalized Basis Reduction algorithms, which can perform analysis of integer sets with affine inequalities and equalities. ">Simplex</a> object with <code>nVar</code> variables.  <a href="#acc961839522a19b6dce1374ee35a4f88">More...</a><br /></td></tr>
<tr class="separator:acc961839522a19b6dce1374ee35a4f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac932622385b3130d5889f9fd288f729f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Simplex.html#ac932622385b3130d5889f9fd288f729f">Simplex</a> (const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;constraints)</td></tr>
<tr class="separator:ac932622385b3130d5889f9fd288f729f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2291075c73f3bd3b22884ab883676654"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Simplex.html#a2291075c73f3bd3b22884ab883676654">isEmpty</a> () const</td></tr>
<tr class="memdesc:a2291075c73f3bd3b22884ab883676654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the tableau is empty (has conflicting constraints), false otherwise.  <a href="#a2291075c73f3bd3b22884ab883676654">More...</a><br /></td></tr>
<tr class="separator:a2291075c73f3bd3b22884ab883676654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33c57f6e20e28a0b0eae1391ad0f47f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Simplex.html#ac33c57f6e20e28a0b0eae1391ad0f47f">addInequality</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; coeffs)</td></tr>
<tr class="memdesc:ac33c57f6e20e28a0b0eae1391ad0f47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an inequality to the tableau.  <a href="#ac33c57f6e20e28a0b0eae1391ad0f47f">More...</a><br /></td></tr>
<tr class="separator:ac33c57f6e20e28a0b0eae1391ad0f47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5093db596f6f1fe2b5b334eb071bf5d"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Simplex.html#ac5093db596f6f1fe2b5b334eb071bf5d">numVariables</a> () const</td></tr>
<tr class="memdesc:ac5093db596f6f1fe2b5b334eb071bf5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of variables in the tableau.  <a href="#ac5093db596f6f1fe2b5b334eb071bf5d">More...</a><br /></td></tr>
<tr class="separator:ac5093db596f6f1fe2b5b334eb071bf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f019a5ef3385eb50b8695672c88b09"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Simplex.html#a79f019a5ef3385eb50b8695672c88b09">numConstraints</a> () const</td></tr>
<tr class="memdesc:a79f019a5ef3385eb50b8695672c88b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of constraints in the tableau.  <a href="#a79f019a5ef3385eb50b8695672c88b09">More...</a><br /></td></tr>
<tr class="separator:a79f019a5ef3385eb50b8695672c88b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4716aa34002745216bee944eec19791b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Simplex.html#a4716aa34002745216bee944eec19791b">addEquality</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; coeffs)</td></tr>
<tr class="memdesc:a4716aa34002745216bee944eec19791b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an equality to the tableau.  <a href="#a4716aa34002745216bee944eec19791b">More...</a><br /></td></tr>
<tr class="separator:a4716aa34002745216bee944eec19791b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73176a14b8a77a48f126657c3040aed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Simplex.html#aa73176a14b8a77a48f126657c3040aed">markEmpty</a> ()</td></tr>
<tr class="memdesc:aa73176a14b8a77a48f126657c3040aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the tableau as being empty.  <a href="#aa73176a14b8a77a48f126657c3040aed">More...</a><br /></td></tr>
<tr class="separator:aa73176a14b8a77a48f126657c3040aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae951ff3f8f99806c71523783d5cc9334"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Simplex.html#ae951ff3f8f99806c71523783d5cc9334">getSnapshot</a> () const</td></tr>
<tr class="memdesc:ae951ff3f8f99806c71523783d5cc9334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a snapshot of the current state. This is used for rolling back.  <a href="#ae951ff3f8f99806c71523783d5cc9334">More...</a><br /></td></tr>
<tr class="separator:ae951ff3f8f99806c71523783d5cc9334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac6124cee1747dfc662d1923447e3a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Simplex.html#adac6124cee1747dfc662d1923447e3a8">rollback</a> (unsigned snapshot)</td></tr>
<tr class="memdesc:adac6124cee1747dfc662d1923447e3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rollback to a snapshot. This invalidates all later snapshots.  <a href="#adac6124cee1747dfc662d1923447e3a8">More...</a><br /></td></tr>
<tr class="separator:adac6124cee1747dfc662d1923447e3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7fe661073f1f913b4482ebeea34515"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1Fraction.html">Fraction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Simplex.html#afe7fe661073f1f913b4482ebeea34515">computeRowOptimum</a> (<a class="el" href="classmlir_1_1Simplex.html#a6175b9ad18f1d01d5e680b48f1e02c12">Direction</a> direction, unsigned row)</td></tr>
<tr class="memdesc:afe7fe661073f1f913b4482ebeea34515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum or minimum value of the given row, depending on direction.  <a href="#afe7fe661073f1f913b4482ebeea34515">More...</a><br /></td></tr>
<tr class="separator:afe7fe661073f1f913b4482ebeea34515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cff705e75d79fc07fd6c6cef399bd09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1Fraction.html">Fraction</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Simplex.html#a7cff705e75d79fc07fd6c6cef399bd09">computeOptimum</a> (<a class="el" href="classmlir_1_1Simplex.html#a6175b9ad18f1d01d5e680b48f1e02c12">Direction</a> direction, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; coeffs)</td></tr>
<tr class="memdesc:a7cff705e75d79fc07fd6c6cef399bd09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum or minimum value of the given expression, depending on direction.  <a href="#a7cff705e75d79fc07fd6c6cef399bd09">More...</a><br /></td></tr>
<tr class="separator:a7cff705e75d79fc07fd6c6cef399bd09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ea0056d4eab93b8d440eac6cd4f1b9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int64_t, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Simplex.html#a18ea0056d4eab93b8d440eac6cd4f1b9">computeIntegerBounds</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; coeffs)</td></tr>
<tr class="memdesc:a18ea0056d4eab93b8d440eac6cd4f1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a (min, max) pair denoting the minimum and maximum integer values of the given expression.  <a href="#a18ea0056d4eab93b8d440eac6cd4f1b9">More...</a><br /></td></tr>
<tr class="separator:a18ea0056d4eab93b8d440eac6cd4f1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0449d05f08c3cd8b363c90ab0d40903"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Simplex.html#ac0449d05f08c3cd8b363c90ab0d40903">isUnbounded</a> ()</td></tr>
<tr class="memdesc:ac0449d05f08c3cd8b363c90ab0d40903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the polytope is unbounded, i.e., extends to infinity in some direction.  <a href="#ac0449d05f08c3cd8b363c90ab0d40903">More...</a><br /></td></tr>
<tr class="separator:ac0449d05f08c3cd8b363c90ab0d40903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91e72df19168e6573ad932b228c8ea5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Simplex.html#ad91e72df19168e6573ad932b228c8ea5">getSamplePointIfIntegral</a> () const</td></tr>
<tr class="memdesc:ad91e72df19168e6573ad932b228c8ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current sample point if it is integral.  <a href="#ad91e72df19168e6573ad932b228c8ea5">More...</a><br /></td></tr>
<tr class="separator:ad91e72df19168e6573ad932b228c8ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabf1356f33010a66ebf64fa0a30390d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Simplex.html#aeabf1356f33010a66ebf64fa0a30390d">findIntegerSample</a> ()</td></tr>
<tr class="memdesc:aeabf1356f33010a66ebf64fa0a30390d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an integer sample point if one exists, or None otherwise.  <a href="#aeabf1356f33010a66ebf64fa0a30390d">More...</a><br /></td></tr>
<tr class="separator:aeabf1356f33010a66ebf64fa0a30390d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7399106a9637cf483e30dc6ef1363656"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Simplex.html#a7399106a9637cf483e30dc6ef1363656">print</a> (raw_ostream &amp;os) const</td></tr>
<tr class="memdesc:a7399106a9637cf483e30dc6ef1363656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the tableau's internal state.  <a href="#a7399106a9637cf483e30dc6ef1363656">More...</a><br /></td></tr>
<tr class="separator:a7399106a9637cf483e30dc6ef1363656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7d0631b7e7e01b1963804d9e504410"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Simplex.html#a9d7d0631b7e7e01b1963804d9e504410">dump</a> () const</td></tr>
<tr class="separator:a9d7d0631b7e7e01b1963804d9e504410"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aac3bf994f055577be5ac0efaacb9e7ef"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Simplex.html">Simplex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Simplex.html#aac3bf994f055577be5ac0efaacb9e7ef">makeProduct</a> (const <a class="el" href="classmlir_1_1Simplex.html">Simplex</a> &amp;a, const <a class="el" href="classmlir_1_1Simplex.html">Simplex</a> &amp;b)</td></tr>
<tr class="memdesc:aac3bf994f055577be5ac0efaacb9e7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a tableau to represent a pair of points in the given tableaus, one in tableau A and one in B.  <a href="#aac3bf994f055577be5ac0efaacb9e7ef">More...</a><br /></td></tr>
<tr class="separator:aac3bf994f055577be5ac0efaacb9e7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5bd6cf78411f5b949fa24d1a1932cc66"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Simplex.html#a5bd6cf78411f5b949fa24d1a1932cc66">GBRSimplex</a></td></tr>
<tr class="separator:a5bd6cf78411f5b949fa24d1a1932cc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements a version of the <a class="el" href="classmlir_1_1Simplex.html" title="This class implements a version of the Simplex and Generalized Basis Reduction algorithms, which can perform analysis of integer sets with affine inequalities and equalities. ">Simplex</a> and Generalized Basis Reduction algorithms, which can perform analysis of integer sets with affine inequalities and equalities. </p>
<p>A <a class="el" href="classmlir_1_1Simplex.html" title="This class implements a version of the Simplex and Generalized Basis Reduction algorithms, which can perform analysis of integer sets with affine inequalities and equalities. ">Simplex</a> can be constructed by specifying the dimensionality of the set. It supports adding affine inequalities and equalities, and can perform emptiness checks, i.e., it can find a solution to the set of constraints if one exists, or say that the set is empty if no solution exists. Currently, this only works for bounded sets. <a class="el" href="classmlir_1_1Simplex.html" title="This class implements a version of the Simplex and Generalized Basis Reduction algorithms, which can perform analysis of integer sets with affine inequalities and equalities. ">Simplex</a> can also be constructed from a <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a> object.</p>
<p>The implementation of this <a class="el" href="classmlir_1_1Simplex.html" title="This class implements a version of the Simplex and Generalized Basis Reduction algorithms, which can perform analysis of integer sets with affine inequalities and equalities. ">Simplex</a> class, other than the functionality for sampling, is based on the paper "Simplify: A Theorem Prover for Program Checking" by D. Detlefs, G. Nelson, J. B. Saxe.</p>
<p>We define variables, constraints, and unknowns. Consider the example of a two-dimensional set defined by 1 + 2x + 3y &gt;= 0 and 2x - 3y &gt;= 0. Here, x, y, are variables while 1 + 2x + 3y &gt;= 0, 2x - 3y &gt;= 0 are constraints. Unknowns are either variables or constraints, i.e., x, y, 1 + 2x + 3y &gt;= 0, 2x - 3y &gt;= 0 are all unknowns.</p>
<p>The implementation involves a matrix called a tableau, which can be thought of as a 2D matrix of rational numbers having number of rows equal to the number of constraints and number of columns equal to one plus the number of variables. In our implementation, instead of storing rational numbers, we store a common denominator for each row, so it is in fact a matrix of integers with number of rows equal to number of constraints and number of columns equal to <em>two</em> plus the number of variables. For example, instead of storing a row of three rationals [1/2, 2/3, 3], we would store [6, 3, 4, 18] since 3/6 = 1/2, 4/6 = 2/3, and 18/6 = 3.</p>
<p>Every row and column except the first and second columns is associated with an unknown and every unknown is associated with a row or column. The second column represents the constant, explained in more detail below. An unknown associated with a row or column is said to be in row or column position respectively.</p>
<p>The vectors var and con store information about the variables and constraints respectively, namely, whether they are in row or column position, which row or column they are associated with, and whether they correspond to a variable or a constraint.</p>
<p>An unknown is addressed by its index. If the index i is non-negative, then the variable var[i] is being addressed. If the index i is negative, then the constraint con[~i] is being addressed. Effectively this maps 0 -&gt; var[0], 1 -&gt; var[1], -1 -&gt; con[0], -2 -&gt; con[1], etc. rowUnknown[r] and colUnknown[c] are the indexes of the unknowns associated with row r and column c, respectively.</p>
<p>The unknowns in column position are together called the basis. Initially the basis is the set of variables &ndash; in our example above, the initial basis is x, y.</p>
<p>The unknowns in row position are represented in terms of the basis unknowns. If the basis unknowns are u_1, u_2, ... u_m, and a row in the tableau is d, c, a_1, a_2, ... a_m, this representats the unknown for that row as (c + a_1*u_1 + a_2*u_2 + ... + a_m*u_m)/d. In our running example, if the basis is the initial basis of x, y, then the constraint 1 + 2x + 3y &gt;= 0 would be represented by the row [1, 1, 2, 3].</p>
<p>The association of unknowns to rows and columns can be changed by a process called pivoting, where a row unknown and a column unknown exchange places and the remaining row variables' representation is changed accordingly by eliminating the old column unknown in favour of the new column unknown. If we had pivoted the column for x with the row for 2x - 3y &gt;= 0, the new row for x would be [2, 1, 3] since x = (1*(2x - 3y) + 3*y)/2. See the documentation for the pivot member function for details.</p>
<p>The association of unknowns to rows and columns is called the <em>tableau configuration</em>. The <em>sample value</em> of an unknown in a particular tableau configuration is its value if all the column unknowns were set to zero. Concretely, for unknowns in column position the sample value is zero and for unknowns in row position the sample value is the constant term divided by the common denominator.</p>
<p>The tableau configuration is called <em>consistent</em> if the sample value of all restricted unknowns is non-negative. Initially there are no constraints, and the tableau is consistent. When a new constraint is added, its sample value in the current tableau configuration may be negative. In that case, we try to find a series of pivots to bring us to a consistent tableau configuration, i.e. we try to make the new constraint's sample value non-negative without making that of any other constraints negative. (See findPivot and findPivotRow for details.) If this is not possible, then the set of constraints is mutually contradictory and the tableau is marked <em>empty</em>, which means the set of constraints has no solution.</p>
<p>This <a class="el" href="classmlir_1_1Simplex.html" title="This class implements a version of the Simplex and Generalized Basis Reduction algorithms, which can perform analysis of integer sets with affine inequalities and equalities. ">Simplex</a> class also supports taking snapshots of the current state and rolling back to prior snapshots. This works by maintaing an undo log of operations. Snapshots are just pointers to a particular location in the log, and rolling back to a snapshot is done by reverting each log entry's operation from the end until we reach the snapshot's location.</p>
<p>Finding an integer sample is done with the Generalized Basis Reduction algorithm. See the documentation for findIntegerSample and reduceBasis. </p>

<p class="definition">Definition at line <a class="el" href="Simplex_8h_source.html#l00123">123</a> of file <a class="el" href="Simplex_8h_source.html">Simplex.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a6175b9ad18f1d01d5e680b48f1e02c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6175b9ad18f1d01d5e680b48f1e02c12">&#9670;&nbsp;</a></span>Direction</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classmlir_1_1Simplex.html#a6175b9ad18f1d01d5e680b48f1e02c12">mlir::Simplex::Direction</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6175b9ad18f1d01d5e680b48f1e02c12a258f49887ef8d14ac268c92b02503aaa"></a>Up&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6175b9ad18f1d01d5e680b48f1e02c12a08a38277b0309070706f6652eeae9a53"></a>Down&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Simplex_8h_source.html#l00125">125</a> of file <a class="el" href="Simplex_8h_source.html">Simplex.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a783e09831e97f63f9536b83ff6e65fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783e09831e97f63f9536b83ff6e65fa9">&#9670;&nbsp;</a></span>Simplex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::Simplex::Simplex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acc961839522a19b6dce1374ee35a4f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc961839522a19b6dce1374ee35a4f88">&#9670;&nbsp;</a></span>Simplex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::Simplex::Simplex </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nVar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classmlir_1_1Simplex.html" title="This class implements a version of the Simplex and Generalized Basis Reduction algorithms, which can perform analysis of integer sets with affine inequalities and equalities. ">Simplex</a> object with <code>nVar</code> variables. </p>

<p class="definition">Definition at line <a class="el" href="Simplex_8cpp_source.html#l00019">19</a> of file <a class="el" href="Simplex_8cpp_source.html">Simplex.cpp</a>.</p>

</div>
</div>
<a id="ac932622385b3130d5889f9fd288f729f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac932622385b3130d5889f9fd288f729f">&#9670;&nbsp;</a></span>Simplex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::Simplex::Simplex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>constraints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Simplex_8cpp_source.html#l00030">30</a> of file <a class="el" href="Simplex_8cpp_source.html">Simplex.cpp</a>.</p>

<p class="reference">References <a class="el" href="Simplex_8cpp_source.html#l00375">addEquality()</a>, <a class="el" href="Simplex_8cpp_source.html#l00360">addInequality()</a>, <a class="el" href="classmlir_1_1Simplex.html#a6175b9ad18f1d01d5e680b48f1e02c12a08a38277b0309070706f6652eeae9a53">Down</a>, <a class="el" href="AffineStructures_8h_source.html#l00197">mlir::FlatAffineConstraints::getEquality()</a>, <a class="el" href="AffineStructures_8h_source.html#l00201">mlir::FlatAffineConstraints::getInequality()</a>, <a class="el" href="AffineStructures_8h_source.html#l00177">mlir::FlatAffineConstraints::getNumEqualities()</a>, <a class="el" href="AffineStructures_8h_source.html#l00183">mlir::FlatAffineConstraints::getNumInequalities()</a>, <a class="el" href="Matrix_8cpp_source.html#l00043">mlir::Matrix::getNumRows()</a>, <a class="el" href="MathExtras_8h_source.html#l00047">mlir::lcm()</a>, <a class="el" href="Matrix_8cpp_source.html#l00047">mlir::Matrix::resizeVertically()</a>, <a class="el" href="LogicalResult_8h_source.html#l00020">mlir::LogicalResult::Success</a>, <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>, and <a class="el" href="classmlir_1_1Simplex.html#a6175b9ad18f1d01d5e680b48f1e02c12a258f49887ef8d14ac268c92b02503aaa">Up</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4716aa34002745216bee944eec19791b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4716aa34002745216bee944eec19791b">&#9670;&nbsp;</a></span>addEquality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::Simplex::addEquality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>coeffs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an equality to the tableau. </p>
<p>If coeffs is c_0, c_1, ... c_n, where n is the current number of variables, then the corresponding equality is c_n + c_0*x_0 + c_1*x_1 + ... + c_{n-1}*x_{n-1} == 0.</p>
<p>If coeffs is c_0, c_1, ... c_n, where n is the curent number of variables, then the corresponding equality is c_n + c_0*x_0 + c_1*x_1 + ... + c_{n-1}*x_{n-1} == 0.</p>
<p>We simply add two opposing inequalities, which force the expression to be zero. </p>

<p class="definition">Definition at line <a class="el" href="Simplex_8cpp_source.html#l00375">375</a> of file <a class="el" href="Simplex_8cpp_source.html">Simplex.cpp</a>.</p>

<p class="reference">References <a class="el" href="Simplex_8cpp_source.html#l00360">addInequality()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Simplex_8cpp_source.html#l00931">findIntegerSample()</a>, and <a class="el" href="Simplex_8cpp_source.html#l00030">Simplex()</a>.</p>

</div>
</div>
<a id="ac33c57f6e20e28a0b0eae1391ad0f47f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33c57f6e20e28a0b0eae1391ad0f47f">&#9670;&nbsp;</a></span>addInequality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::Simplex::addInequality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>coeffs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an inequality to the tableau. </p>
<p>If coeffs is c_0, c_1, ... c_n, where n is the current number of variables, then the corresponding inequality is c_n + c_0*x_0 + c_1*x_1 + ... + c_{n-1}*x_{n-1} &gt;= 0.</p>
<p>If coeffs is c_0, c_1, ... c_n, where n is the curent number of variables, then the corresponding inequality is c_n + c_0*x_0 + c_1*x_1 + ... + c_{n-1}*x_{n-1} &gt;= 0.</p>
<p>We add the inequality and mark it as restricted. We then try to make its sample value non-negative. If this is not possible, the tableau has become empty and we mark it as such. </p>

<p class="definition">Definition at line <a class="el" href="Simplex_8cpp_source.html#l00360">360</a> of file <a class="el" href="Simplex_8cpp_source.html">Simplex.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00046">mlir::failed()</a>, and <a class="el" href="Simplex_8cpp_source.html#l00348">markEmpty()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Simplex_8cpp_source.html#l00375">addEquality()</a>, and <a class="el" href="Simplex_8cpp_source.html#l00030">Simplex()</a>.</p>

</div>
</div>
<a id="a18ea0056d4eab93b8d440eac6cd4f1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ea0056d4eab93b8d440eac6cd4f1b9">&#9670;&nbsp;</a></span>computeIntegerBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int64_t, int64_t &gt; mlir::Simplex::computeIntegerBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>coeffs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a (min, max) pair denoting the minimum and maximum integer values of the given expression. </p>
<p>Compute the minimum and maximum integer values the expression can take.</p>
<p>We compute each separately. </p>

<p class="definition">Definition at line <a class="el" href="Simplex_8cpp_source.html#l01026">1026</a> of file <a class="el" href="Simplex_8cpp_source.html">Simplex.cpp</a>.</p>

<p class="reference">References <a class="el" href="Fraction_8h_source.html#l00057">mlir::ceil()</a>, <a class="el" href="Simplex_8cpp_source.html#l00471">computeOptimum()</a>, <a class="el" href="classmlir_1_1Simplex.html#a6175b9ad18f1d01d5e680b48f1e02c12a08a38277b0309070706f6652eeae9a53">Down</a>, <a class="el" href="Fraction_8h_source.html#l00055">mlir::floor()</a>, and <a class="el" href="classmlir_1_1Simplex.html#a6175b9ad18f1d01d5e680b48f1e02c12a258f49887ef8d14ac268c92b02503aaa">Up</a>.</p>

<p class="reference">Referenced by <a class="el" href="Simplex_8cpp_source.html#l00931">findIntegerSample()</a>.</p>

</div>
</div>
<a id="a7cff705e75d79fc07fd6c6cef399bd09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cff705e75d79fc07fd6c6cef399bd09">&#9670;&nbsp;</a></span>computeOptimum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1Fraction.html">Fraction</a> &gt; mlir::Simplex::computeOptimum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Simplex.html#a6175b9ad18f1d01d5e680b48f1e02c12">Direction</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>coeffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the maximum or minimum value of the given expression, depending on direction. </p>
<p>Compute the optimum of the specified expression in the specified direction, or None if it is unbounded.</p>
<p>Returns a (num, den) pair denoting the optimum, or a null value if no optimum exists, i.e., if the expression is unbounded in this direction.</p>

<p class="definition">Definition at line <a class="el" href="Simplex_8cpp_source.html#l00471">471</a> of file <a class="el" href="Simplex_8cpp_source.html">Simplex.cpp</a>.</p>

<p class="reference">References <a class="el" href="Simplex_8cpp_source.html#l00452">computeRowOptimum()</a>, <a class="el" href="Simplex_8cpp_source.html#l00388">getSnapshot()</a>, and <a class="el" href="Simplex_8cpp_source.html#l00445">rollback()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Simplex_8cpp_source.html#l01026">computeIntegerBounds()</a>, and <a class="el" href="Simplex_8cpp_source.html#l00483">isUnbounded()</a>.</p>

</div>
</div>
<a id="afe7fe661073f1f913b4482ebeea34515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7fe661073f1f913b4482ebeea34515">&#9670;&nbsp;</a></span>computeRowOptimum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="structmlir_1_1Fraction.html">Fraction</a> &gt; mlir::Simplex::computeRowOptimum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Simplex.html#a6175b9ad18f1d01d5e680b48f1e02c12">Direction</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the maximum or minimum value of the given row, depending on direction. </p>
<p>Returns a (num, den) pair denoting the optimum, or None if no optimum exists, i.e., if the expression is unbounded in this direction. </p>

<p class="definition">Definition at line <a class="el" href="Simplex_8cpp_source.html#l00452">452</a> of file <a class="el" href="Simplex_8cpp_source.html">Simplex.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Simplex_8cpp_source.html#l00471">computeOptimum()</a>.</p>

</div>
</div>
<a id="a9d7d0631b7e7e01b1963804d9e504410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7d0631b7e7e01b1963804d9e504410">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::Simplex::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Simplex_8cpp_source.html#l01079">1079</a> of file <a class="el" href="Simplex_8cpp_source.html">Simplex.cpp</a>.</p>

<p class="reference">References <a class="el" href="Simplex_8cpp_source.html#l01044">print()</a>.</p>

</div>
</div>
<a id="aeabf1356f33010a66ebf64fa0a30390d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeabf1356f33010a66ebf64fa0a30390d">&#9670;&nbsp;</a></span>findIntegerSample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt; &gt; mlir::Simplex::findIntegerSample </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an integer sample point if one exists, or None otherwise. </p>
<p>Search for an integer sample point using a branch and bound algorithm.</p>
<p>This should only be called for bounded sets.</p>
<p>Each row in the basis matrix is a vector, and the set of basis vectors should span the space. Initially this is the identity matrix, i.e., the basis vectors are just the variables.</p>
<p>In every level, a value is assigned to the level-th basis vector, as follows. Compute the minimum and maximum rational values of this direction. If only one integer point lies in this range, constrain the variable to have this value and recurse to the next variable.</p>
<p>If the range has multiple values, perform generalized basis reduction via reduceBasis and then compute the bounds again. Now we try constraining this direction in the first value in this range and "recurse" to the next level. If we fail to find a sample, we try assigning the direction the next value in this range, and so on.</p>
<p>If no integer sample is found from any of the assignments, or if the range contains no integer value, then of course the polytope is empty for the current assignment of the values in previous levels, so we return to the previous level.</p>
<p>If we reach the last level where all the variables have been assigned values already, then we simply return the current sample point if it is integral, and go back to the previous level otherwise.</p>
<p>To avoid potentially arbitrarily large recursion depths leading to stack overflows, this algorithm is implemented iteratively. </p>

<p class="definition">Definition at line <a class="el" href="Simplex_8cpp_source.html#l00931">931</a> of file <a class="el" href="Simplex_8cpp_source.html">Simplex.cpp</a>.</p>

<p class="reference">References <a class="el" href="Simplex_8cpp_source.html#l00375">addEquality()</a>, <a class="el" href="Simplex_8cpp_source.html#l01026">computeIntegerBounds()</a>, <a class="el" href="Matrix_8cpp_source.html#l00043">mlir::Matrix::getNumRows()</a>, <a class="el" href="Matrix_8cpp_source.html#l00070">mlir::Matrix::getRow()</a>, <a class="el" href="Simplex_8cpp_source.html#l00580">getSamplePointIfIntegral()</a>, <a class="el" href="Simplex_8cpp_source.html#l00388">getSnapshot()</a>, <a class="el" href="Matrix_8cpp_source.html#l00016">mlir::Matrix::identity()</a>, and <a class="el" href="Simplex_8cpp_source.html#l00445">rollback()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01057">mlir::FlatAffineConstraints::findIntegerSample()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l01046">mlir::FlatAffineConstraints::isIntegerEmpty()</a>.</p>

</div>
</div>
<a id="ad91e72df19168e6573ad932b228c8ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91e72df19168e6573ad932b228c8ea5">&#9670;&nbsp;</a></span>getSamplePointIfIntegral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt; &gt; mlir::Simplex::getSamplePointIfIntegral </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current sample point if it is integral. </p>
<p>Otherwise, returns an None. </p>

<p class="definition">Definition at line <a class="el" href="Simplex_8cpp_source.html#l00580">580</a> of file <a class="el" href="Simplex_8cpp_source.html">Simplex.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Simplex_8cpp_source.html#l00931">findIntegerSample()</a>.</p>

</div>
</div>
<a id="ae951ff3f8f99806c71523783d5cc9334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae951ff3f8f99806c71523783d5cc9334">&#9670;&nbsp;</a></span>getSnapshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::Simplex::getSnapshot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a snapshot of the current state. This is used for rolling back. </p>
<p>Return a snapshot of the curent state.</p>
<p>This is just the current size of the undo log. </p>

<p class="definition">Definition at line <a class="el" href="Simplex_8cpp_source.html#l00388">388</a> of file <a class="el" href="Simplex_8cpp_source.html">Simplex.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1Simplex.html#a6175b9ad18f1d01d5e680b48f1e02c12a08a38277b0309070706f6652eeae9a53">Down</a>, <a class="el" href="Matrix_8cpp_source.html#l00047">mlir::Matrix::resizeVertically()</a>, and <a class="el" href="classmlir_1_1Simplex.html#a6175b9ad18f1d01d5e680b48f1e02c12a258f49887ef8d14ac268c92b02503aaa">Up</a>.</p>

<p class="reference">Referenced by <a class="el" href="Simplex_8cpp_source.html#l00471">computeOptimum()</a>, and <a class="el" href="Simplex_8cpp_source.html#l00931">findIntegerSample()</a>.</p>

</div>
</div>
<a id="a2291075c73f3bd3b22884ab883676654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2291075c73f3bd3b22884ab883676654">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::Simplex::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the tableau is empty (has conflicting constraints), false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="Simplex_8cpp_source.html#l00336">336</a> of file <a class="el" href="Simplex_8cpp_source.html">Simplex.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matrix_8cpp_source.html#l00052">mlir::Matrix::swapRows()</a>.</p>

</div>
</div>
<a id="ac0449d05f08c3cd8b363c90ab0d40903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0449d05f08c3cd8b363c90ab0d40903">&#9670;&nbsp;</a></span>isUnbounded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::Simplex::isUnbounded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the polytope is unbounded, i.e., extends to infinity in some direction. </p>
<p>Otherwise, returns false. </p>

<p class="definition">Definition at line <a class="el" href="Simplex_8cpp_source.html#l00483">483</a> of file <a class="el" href="Simplex_8cpp_source.html">Simplex.cpp</a>.</p>

<p class="reference">References <a class="el" href="Simplex_8cpp_source.html#l00471">computeOptimum()</a>, <a class="el" href="classmlir_1_1Simplex.html#a6175b9ad18f1d01d5e680b48f1e02c12a08a38277b0309070706f6652eeae9a53">Down</a>, and <a class="el" href="classmlir_1_1Simplex.html#a6175b9ad18f1d01d5e680b48f1e02c12a258f49887ef8d14ac268c92b02503aaa">Up</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01046">mlir::FlatAffineConstraints::isIntegerEmpty()</a>.</p>

</div>
</div>
<a id="aac3bf994f055577be5ac0efaacb9e7ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3bf994f055577be5ac0efaacb9e7ef">&#9670;&nbsp;</a></span>makeProduct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Simplex.html">Simplex</a> mlir::Simplex::makeProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Simplex.html">Simplex</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Simplex.html">Simplex</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a tableau to represent a pair of points in the given tableaus, one in tableau A and one in B. </p>
<p>Make a tableau to represent a pair of points in the original tableau.</p>
<p>The product constraints and variables are stored as: first A's, then B's.</p>
<p>The product tableau has row layout: A's rows, B's rows.</p>
<p>It has column layout: denominator, constant, A's columns, B's columns. </p>

<p class="definition">Definition at line <a class="el" href="Simplex_8cpp_source.html#l00513">513</a> of file <a class="el" href="Simplex_8cpp_source.html">Simplex.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgOps_8cpp_source.html#l01110">mlir::linalg::concat()</a>, <a class="el" href="Simplex_8cpp_source.html#l00384">numConstraints()</a>, <a class="el" href="Simplex_8cpp_source.html#l00383">numVariables()</a>, and <a class="el" href="Matrix_8cpp_source.html#l00047">mlir::Matrix::resizeVertically()</a>.</p>

</div>
</div>
<a id="aa73176a14b8a77a48f126657c3040aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73176a14b8a77a48f126657c3040aed">&#9670;&nbsp;</a></span>markEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::Simplex::markEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the tableau as being empty. </p>
<p>Mark this tableau empty and push an entry to the undo stack. </p>

<p class="definition">Definition at line <a class="el" href="Simplex_8cpp_source.html#l00348">348</a> of file <a class="el" href="Simplex_8cpp_source.html">Simplex.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Simplex_8cpp_source.html#l00360">addInequality()</a>.</p>

</div>
</div>
<a id="a79f019a5ef3385eb50b8695672c88b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f019a5ef3385eb50b8695672c88b09">&#9670;&nbsp;</a></span>numConstraints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::Simplex::numConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of constraints in the tableau. </p>

<p class="definition">Definition at line <a class="el" href="Simplex_8cpp_source.html#l00384">384</a> of file <a class="el" href="Simplex_8cpp_source.html">Simplex.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Simplex_8cpp_source.html#l00513">makeProduct()</a>.</p>

</div>
</div>
<a id="ac5093db596f6f1fe2b5b334eb071bf5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5093db596f6f1fe2b5b334eb071bf5d">&#9670;&nbsp;</a></span>numVariables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::Simplex::numVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of variables in the tableau. </p>

<p class="definition">Definition at line <a class="el" href="Simplex_8cpp_source.html#l00383">383</a> of file <a class="el" href="Simplex_8cpp_source.html">Simplex.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Simplex_8cpp_source.html#l00513">makeProduct()</a>.</p>

</div>
</div>
<a id="a7399106a9637cf483e30dc6ef1363656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7399106a9637cf483e30dc6ef1363656">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::Simplex::print </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the tableau's internal state. </p>

<p class="definition">Definition at line <a class="el" href="Simplex_8cpp_source.html#l01044">1044</a> of file <a class="el" href="Simplex_8cpp_source.html">Simplex.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Simplex_8cpp_source.html#l01079">dump()</a>.</p>

</div>
</div>
<a id="adac6124cee1747dfc662d1923447e3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac6124cee1747dfc662d1923447e3a8">&#9670;&nbsp;</a></span>rollback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::Simplex::rollback </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>snapshot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rollback to a snapshot. This invalidates all later snapshots. </p>
<p>Rollback to the specified snapshot.</p>
<p>We undo all the log entries until the log size when the snapshot was taken is reached. </p>

<p class="definition">Definition at line <a class="el" href="Simplex_8cpp_source.html#l00445">445</a> of file <a class="el" href="Simplex_8cpp_source.html">Simplex.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Simplex_8cpp_source.html#l00471">computeOptimum()</a>, and <a class="el" href="Simplex_8cpp_source.html#l00931">findIntegerSample()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a5bd6cf78411f5b949fa24d1a1932cc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd6cf78411f5b949fa24d1a1932cc66">&#9670;&nbsp;</a></span>GBRSimplex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfriend.html">friend</a> class <a class="el" href="classmlir_1_1GBRSimplex.html">GBRSimplex</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Simplex_8h_source.html#l00200">200</a> of file <a class="el" href="Simplex_8h_source.html">Simplex.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Analysis/Presburger/<a class="el" href="Simplex_8h_source.html">Simplex.h</a></li>
<li>lib/Analysis/Presburger/<a class="el" href="Simplex_8cpp_source.html">Simplex.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Aug 8 2020 16:27:20 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
