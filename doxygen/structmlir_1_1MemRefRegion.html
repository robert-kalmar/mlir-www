<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::MemRefRegion Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">12.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structmlir_1_1MemRefRegion-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::MemRefRegion Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A region of a memref's data space; this is typically constructed by analyzing load/store op's on this memref and the index space of loops surrounding such op's.  
 <a href="structmlir_1_1MemRefRegion.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="Analysis_2Utils_8h_source.html">mlir/Analysis/Utils.h</a>&quot;</code></p>
<div class="dynheader">
Collaboration diagram for mlir::MemRefRegion:</div>
<div class="dyncontent">
<div class="center"><img src="structmlir_1_1MemRefRegion__coll__graph.png" border="0" usemap="#mlir_1_1MemRefRegion_coll__map" alt="Collaboration graph"/></div>
<map name="mlir_1_1MemRefRegion_coll__map" id="mlir_1_1MemRefRegion_coll__map">
<area shape="rect" id="node2" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value..." alt="" coords="58,365,142,392"/>
<area shape="rect" id="node4" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non&#45;nullable wrapper around..." alt="" coords="182,365,282,392"/>
<area shape="rect" id="node5" href="classmlir_1_1LocationAttr.html" title="Location objects represent source locations information in MLIR. " alt="" coords="217,269,338,295"/>
<area shape="rect" id="node6" href="classmlir_1_1Attribute.html" title="Attributes are known&#45;constant values of operations and functions. " alt="" coords="227,185,327,212"/>
<area shape="rect" id="node7" href="classmlir_1_1AttributeStorage.html" title="Base storage class appearing in an attribute. " alt="" coords="205,96,350,123"/>
<area shape="rect" id="node8" href="classmlir_1_1StorageUniquer_1_1BaseStorage.html" title="This class acts as the base storage that all storage classes must derived from. " alt="" coords="207,5,348,47"/>
<area shape="rect" id="node10" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. " alt="" coords="377,365,551,392"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a94163255db4acde7702f9b8de48b7982"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#a94163255db4acde7702f9b8de48b7982">MemRefRegion</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> <a class="el" href="structmlir_1_1MemRefRegion.html#a41c25453cbeaa5d9345d97af75e08fd7">loc</a>)</td></tr>
<tr class="separator:a94163255db4acde7702f9b8de48b7982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add33daeb279e80255487b6ec186db58b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#add33daeb279e80255487b6ec186db58b">compute</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, unsigned loopDepth, <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceState=nullptr, bool addMemRefDimBounds=true)</td></tr>
<tr class="memdesc:add33daeb279e80255487b6ec186db58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the memory region accessed by this memref with the region represented as constraints symbolic/parametric in 'loopDepth' loops surrounding opInst.  <a href="#add33daeb279e80255487b6ec186db58b">More...</a><br /></td></tr>
<tr class="separator:add33daeb279e80255487b6ec186db58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aeb7fda8e9279474e2596bdff711433"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#a8aeb7fda8e9279474e2596bdff711433">getConstraints</a> ()</td></tr>
<tr class="separator:a8aeb7fda8e9279474e2596bdff711433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2c073abc47a8a4c461318484f2e9ea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#abb2c073abc47a8a4c461318484f2e9ea">getConstraints</a> () const</td></tr>
<tr class="separator:abb2c073abc47a8a4c461318484f2e9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f77f916448c7949d85cf873a1950375"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#a8f77f916448c7949d85cf873a1950375">isWrite</a> () const</td></tr>
<tr class="separator:a8f77f916448c7949d85cf873a1950375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154d177f4d61387d7925c2873d72c8da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#a154d177f4d61387d7925c2873d72c8da">setWrite</a> (bool flag)</td></tr>
<tr class="separator:a154d177f4d61387d7925c2873d72c8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a7d17a661ec58a29ce543121f4bc9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#a22a7d17a661ec58a29ce543121f4bc9d">getConstantBoundingSizeAndShape</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *shape=nullptr, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt;&gt; *lbs=nullptr, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *lbDivisors=nullptr) const</td></tr>
<tr class="memdesc:a22a7d17a661ec58a29ce543121f4bc9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant upper bound on the number of elements in this region if bounded by a known constant (always possible for static shapes), None otherwise.  <a href="#a22a7d17a661ec58a29ce543121f4bc9d">More...</a><br /></td></tr>
<tr class="separator:a22a7d17a661ec58a29ce543121f4bc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772a10d9c01365d3d3a697f8679e1afc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#a772a10d9c01365d3d3a697f8679e1afc">getLowerAndUpperBound</a> (unsigned pos, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;lbMap, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;ubMap) const</td></tr>
<tr class="memdesc:a772a10d9c01365d3d3a697f8679e1afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the lower and upper bound map for the dimensional identifier at <code>pos</code>.  <a href="#a772a10d9c01365d3d3a697f8679e1afc">More...</a><br /></td></tr>
<tr class="separator:a772a10d9c01365d3d3a697f8679e1afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f83f0a4b7c3393b18dd32a3c83b5db6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#a9f83f0a4b7c3393b18dd32a3c83b5db6">getConstantBoundOnDimSize</a> (unsigned pos, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *lb=nullptr, int64_t *lbFloorDivisor=nullptr) const</td></tr>
<tr class="memdesc:a9f83f0a4b7c3393b18dd32a3c83b5db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around <a class="el" href="classmlir_1_1FlatAffineConstraints.html#acee472dcf0f37342df02e5af53b7aa45" title="Returns the smallest known constant bound for the extent of the specified identifier (pos^th)...">FlatAffineConstraints::getConstantBoundOnDimSize()</a>.  <a href="#a9f83f0a4b7c3393b18dd32a3c83b5db6">More...</a><br /></td></tr>
<tr class="separator:a9f83f0a4b7c3393b18dd32a3c83b5db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaecac872899184676e1fde7b2460e1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#abaecac872899184676e1fde7b2460e1c">getRegionSize</a> ()</td></tr>
<tr class="memdesc:abaecac872899184676e1fde7b2460e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of this <a class="el" href="structmlir_1_1MemRefRegion.html" title="A region of a memref&#39;s data space; this is typically constructed by analyzing load/store op&#39;s on this...">MemRefRegion</a> in bytes.  <a href="#abaecac872899184676e1fde7b2460e1c">More...</a><br /></td></tr>
<tr class="separator:abaecac872899184676e1fde7b2460e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2761578967822bb7853e072a1a29bac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#aa2761578967822bb7853e072a1a29bac">unionBoundingBox</a> (const <a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a> &amp;other)</td></tr>
<tr class="separator:aa2761578967822bb7853e072a1a29bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22317444c57ececdfd0b3f5497d1971c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#a22317444c57ececdfd0b3f5497d1971c">getRank</a> () const</td></tr>
<tr class="memdesc:a22317444c57ececdfd0b3f5497d1971c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank of the memref that this region corresponds to.  <a href="#a22317444c57ececdfd0b3f5497d1971c">More...</a><br /></td></tr>
<tr class="separator:a22317444c57ececdfd0b3f5497d1971c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af4996f781f24e9f3c57256a95ae58b8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#af4996f781f24e9f3c57256a95ae58b8c">memref</a></td></tr>
<tr class="memdesc:af4996f781f24e9f3c57256a95ae58b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memref that this region corresponds to.  <a href="#af4996f781f24e9f3c57256a95ae58b8c">More...</a><br /></td></tr>
<tr class="separator:af4996f781f24e9f3c57256a95ae58b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e52e7911cae506b5b206f9dc6b3642"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#ae9e52e7911cae506b5b206f9dc6b3642">write</a></td></tr>
<tr class="memdesc:ae9e52e7911cae506b5b206f9dc6b3642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read or write.  <a href="#ae9e52e7911cae506b5b206f9dc6b3642">More...</a><br /></td></tr>
<tr class="separator:ae9e52e7911cae506b5b206f9dc6b3642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c25453cbeaa5d9345d97af75e08fd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#a41c25453cbeaa5d9345d97af75e08fd7">loc</a></td></tr>
<tr class="memdesc:a41c25453cbeaa5d9345d97af75e08fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">If there is more than one load/store op associated with the region, the location information would correspond to one of those op's.  <a href="#a41c25453cbeaa5d9345d97af75e08fd7">More...</a><br /></td></tr>
<tr class="separator:a41c25453cbeaa5d9345d97af75e08fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78b96081a1d38fd5d731dfacca3deb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html#af78b96081a1d38fd5d731dfacca3deb8">cst</a></td></tr>
<tr class="memdesc:af78b96081a1d38fd5d731dfacca3deb8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Region.html" title="This class contains a list of basic blocks and a link to the parent operation it is attached to...">Region</a> (data space) of the memref accessed.  <a href="#af78b96081a1d38fd5d731dfacca3deb8">More...</a><br /></td></tr>
<tr class="separator:af78b96081a1d38fd5d731dfacca3deb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A region of a memref's data space; this is typically constructed by analyzing load/store op's on this memref and the index space of loops surrounding such op's. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8h_source.html#l00173">173</a> of file <a class="el" href="Analysis_2Utils_8h_source.html">Utils.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a94163255db4acde7702f9b8de48b7982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94163255db4acde7702f9b8de48b7982">&#9670;&nbsp;</a></span>MemRefRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::MemRefRegion::MemRefRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8h_source.html#l00174">174</a> of file <a class="el" href="Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="add33daeb279e80255487b6ec186db58b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add33daeb279e80255487b6ec186db58b">&#9670;&nbsp;</a></span>compute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> MemRefRegion::compute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>loopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *&#160;</td>
          <td class="paramname"><em>sliceState</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addMemRefDimBounds</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the memory region accessed by this memref with the region represented as constraints symbolic/parametric in 'loopDepth' loops surrounding opInst. </p>
<p>Computes the memory region accessed by this memref with the region represented as constraints symbolic/parametric in 'loopDepth' loops surrounding opInst and any additional Function symbols.</p>
<p>The computed region's 'cst' field has exactly as many dimensional identifiers as the rank of the memref, and <em>potentially</em> additional symbolic identifiers which could include any of the loop IVs surrounding opInst up until 'loopDepth' and another additional Function symbols involved with the access (for eg., those appear in affine.apply's, loop bounds, etc.). If 'sliceState' is non-null, operands from 'sliceState' are added as symbols, and the following constraints are added to the system: *) Inequality constraints which represent loop bounds for 'sliceState' operands which are loop IVS (these represent the destination loop IVs of the slice, and are added as symbols to <a class="el" href="structmlir_1_1MemRefRegion.html" title="A region of a memref&#39;s data space; this is typically constructed by analyzing load/store op&#39;s on this...">MemRefRegion</a>'s constraint system). *) Inequality constraints for the slice bounds in 'sliceState', which represent the bounds on the loop IVs in this constraint system w.r.t to slice operands (which correspond to symbols). If 'addMemRefDimBounds' is true, constant upper/lower bounds [0, memref.getDimSize(i)) are added for each MemRef dimension 'i'.</p>
<p>For example, the memref region for this operation at loopDepth = 1 will be:</p>
<p>affine.for i = 0 to 32 { affine.for ii = i to (d0) -&gt; (d0 + 8) (i) { load A[ii] } }</p>
<p>{memref = A, write = false, {i &lt;= m0 &lt;= i + 7} } The last field is a 2-d <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a> symbolic in i.</p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00196">196</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l02353">mlir::AffineMap::dump()</a>, <a class="el" href="Operation_8cpp_source.html#l00278">mlir::Operation::emitError()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01682">mlir::extractForInductionVars()</a>, <a class="el" href="LogicalResult_8h_source.html#l00046">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00033">mlir::failure()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00660">mlir::MemRefAccess::getAccessMap()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00101">mlir::AffineValueMap::getAffineMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01672">mlir::getForInductionVarOwner()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00033">mlir::getLoopIVs()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00203">mlir::AffineMap::getNumDims()</a>, <a class="el" href="AffineValueMap_8h_source.html#l00068">mlir::AffineValueMap::getNumOperands()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00207">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00093">mlir::AffineValueMap::getOperand()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00896">mlir::MemRefAccess::getRank()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00900">mlir::MemRefAccess::isStore()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00222">mlir::isValidSymbol()</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00058">mlir::ComputationSliceState::ivs</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00064">mlir::ComputationSliceState::lbOperands</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00060">mlir::ComputationSliceState::lbs</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00047">mlir::MemRefAccess::memref</a>, <a class="el" href="LogicalResult_8h_source.html#l00040">mlir::succeeded()</a>, <a class="el" href="LogicalResult_8h_source.html#l00026">mlir::success()</a>, and <a class="el" href="Analysis_2Utils_8h_source.html#l00062">mlir::ComputationSliceState::ubs</a>.</p>

</div>
</div>
<a id="a22a7d17a661ec58a29ce543121f4bc9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a7d17a661ec58a29ce543121f4bc9d">&#9670;&nbsp;</a></span>getConstantBoundingSizeAndShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt; MemRefRegion::getConstantBoundingSizeAndShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>shape</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>lbs</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>lbDivisors</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant upper bound on the number of elements in this region if bounded by a known constant (always possible for static shapes), None otherwise. </p>
<p>Note that the symbols of the region are treated specially, i.e., the returned bounding constant holds for <em>any given</em> value of the symbol identifiers. The 'shape' vector is set to the corresponding dimension-wise bounds major to minor. We use int64_t instead of uint64_t since index types can be at most int64_t. <code>lbs</code> are set to the lower bounds for each of the rank dimensions, and lbDivisors contains the corresponding denominators for floorDivs. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00095">95</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardTypes_8h_source.html#l00300">mlir::ShapedType::isDynamic()</a>, and <a class="el" href="Analysis_2Utils_8h_source.html#l00060">mlir::ComputationSliceState::lbs</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01709">generateCopy()</a>.</p>

</div>
</div>
<a id="a9f83f0a4b7c3393b18dd32a3c83b5db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f83f0a4b7c3393b18dd32a3c83b5db6">&#9670;&nbsp;</a></span>getConstantBoundOnDimSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;int64_t&gt; mlir::MemRefRegion::getConstantBoundOnDimSize </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>lb</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>lbFloorDivisor</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A wrapper around <a class="el" href="classmlir_1_1FlatAffineConstraints.html#acee472dcf0f37342df02e5af53b7aa45" title="Returns the smallest known constant bound for the extent of the specified identifier (pos^th)...">FlatAffineConstraints::getConstantBoundOnDimSize()</a>. </p>
<p>'pos' corresponds to the position of the memref shape's dimension (major to minor) which matches 1:1 with the dimensional identifier positions in </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8h_source.html#l00241">241</a> of file <a class="el" href="Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a8aeb7fda8e9279474e2596bdff711433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aeb7fda8e9279474e2596bdff711433">&#9670;&nbsp;</a></span>getConstraints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a>* mlir::MemRefRegion::getConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8h_source.html#l00212">212</a> of file <a class="el" href="Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01540">findHighestBlockForPlacement()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01709">generateCopy()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02000">getFullMemRefAsRegion()</a>, and <a class="el" href="Analysis_2Utils_8cpp_source.html#l00174">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="abb2c073abc47a8a4c461318484f2e9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2c073abc47a8a4c461318484f2e9ea">&#9670;&nbsp;</a></span>getConstraints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a>* mlir::MemRefRegion::getConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8h_source.html#l00213">213</a> of file <a class="el" href="Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a772a10d9c01365d3d3a697f8679e1afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772a10d9c01365d3d3a697f8679e1afc">&#9670;&nbsp;</a></span>getLowerAndUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MemRefRegion::getLowerAndUpperBound </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>lbMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>ubMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the lower and upper bound map for the dimensional identifier at <code>pos</code>. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00155">155</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineMap_8cpp_source.html#l00215">mlir::AffineMap::getNumInputs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01709">generateCopy()</a>.</p>

</div>
</div>
<a id="a22317444c57ececdfd0b3f5497d1971c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22317444c57ececdfd0b3f5497d1971c">&#9670;&nbsp;</a></span>getRank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned MemRefRegion::getRank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the rank of the memref that this region corresponds to. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00091">91</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a id="abaecac872899184676e1fde7b2460e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaecac872899184676e1fde7b2460e1c">&#9670;&nbsp;</a></span>getRegionSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt; MemRefRegion::getRegionSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of this <a class="el" href="structmlir_1_1MemRefRegion.html" title="A region of a memref&#39;s data space; this is typically constructed by analyzing load/store op&#39;s on this...">MemRefRegion</a> in bytes. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00365">365</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardTypes_8cpp_source.html#l00457">mlir::MemRefType::getAffineMaps()</a>, and <a class="el" href="Analysis_2Utils_8cpp_source.html#l00350">getMemRefEltSizeInBytes()</a>.</p>

</div>
</div>
<a id="a8f77f916448c7949d85cf873a1950375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f77f916448c7949d85cf873a1950375">&#9670;&nbsp;</a></span>isWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::MemRefRegion::isWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8h_source.html#l00214">214</a> of file <a class="el" href="Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01709">generateCopy()</a>.</p>

</div>
</div>
<a id="a154d177f4d61387d7925c2873d72c8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154d177f4d61387d7925c2873d72c8da">&#9670;&nbsp;</a></span>setWrite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::MemRefRegion::setWrite </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8h_source.html#l00215">215</a> of file <a class="el" href="Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">References <a class="el" href="Analysis_2Utils_8h_source.html#l00060">mlir::ComputationSliceState::lbs</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02000">getFullMemRefAsRegion()</a>.</p>

</div>
</div>
<a id="aa2761578967822bb7853e072a1a29bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2761578967822bb7853e072a1a29bac">&#9670;&nbsp;</a></span>unionBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> MemRefRegion::unionBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00174">174</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Analysis_2Utils_8h_source.html#l00212">getConstraints()</a>, and <a class="el" href="Analysis_2Utils_8h_source.html#l00258">memref</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af78b96081a1d38fd5d731dfacca3deb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78b96081a1d38fd5d731dfacca3deb8">&#9670;&nbsp;</a></span>cst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> mlir::MemRefRegion::cst</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Region.html" title="This class contains a list of basic blocks and a link to the parent operation it is attached to...">Region</a> (data space) of the memref accessed. </p>
<p>This set will thus have at least as many dimensional identifiers as the shape dimensionality of the memref, and these are the leading dimensions of the set appearing in that order (major to minor / outermost to innermost). There may be additional identifiers since getMemRefRegion() is called with a specific loop depth, and thus the region is symbolic in the outer surrounding loops at that depth. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8h_source.html#l00275">275</a> of file <a class="el" href="Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a41c25453cbeaa5d9345d97af75e08fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c25453cbeaa5d9345d97af75e08fd7">&#9670;&nbsp;</a></span>loc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Location.html">Location</a> mlir::MemRefRegion::loc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If there is more than one load/store op associated with the region, the location information would correspond to one of those op's. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8h_source.html#l00265">265</a> of file <a class="el" href="Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01709">generateCopy()</a>.</p>

</div>
</div>
<a id="af4996f781f24e9f3c57256a95ae58b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4996f781f24e9f3c57256a95ae58b8c">&#9670;&nbsp;</a></span>memref</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::MemRefRegion::memref</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memref that this region corresponds to. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8h_source.html#l00258">258</a> of file <a class="el" href="Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01709">generateCopy()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02252">mlir::generateCopyForMemRegion()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02000">getFullMemRefAsRegion()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01584">getMultiLevelStrides()</a>, and <a class="el" href="Analysis_2Utils_8cpp_source.html#l00174">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="ae9e52e7911cae506b5b206f9dc6b3642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e52e7911cae506b5b206f9dc6b3642">&#9670;&nbsp;</a></span>write</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::MemRefRegion::write</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read or write. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8h_source.html#l00261">261</a> of file <a class="el" href="Analysis_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>include/mlir/Analysis/<a class="el" href="Analysis_2Utils_8h_source.html">Utils.h</a></li>
<li>lib/Analysis/<a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Aug 8 2020 16:27:19 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
